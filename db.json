{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/ASAN、valgrind（内存泄露的检测工具）.md","hash":"9b9554027eb0147318d2ab5cfc71ad53a4f676dd","modified":1758109443061},{"_id":"source/about/index.md","hash":"f20f465fcc4a8f7a0a7391fb51aa4e6183c5519f","modified":1758106313771},{"_id":"source/_posts/gperftools（Google 提供的开源性能优化工具集）.md","hash":"52f0b7e02fd420523a4fcfeeca45eb82d57eacdf","modified":1758109469044},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1758105556686},{"_id":"source/_posts/perf（Linux 下的性能分析器）.md","hash":"ca12b5d1c90ee010fb768a3d4de506b862051804","modified":1758109500533},{"_id":"source/_posts/tools_comparison.md","hash":"89895ff458fd4ca51ecf23858f2a2eaf218d212e","modified":1758109527980},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1750151776000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1750151776000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1750151776000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1750151776000},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1750151776000},{"_id":"themes/fluid/README.md","hash":"7d6055e6510da37dfe4f6ca5b7540b652b877220","modified":1750151776000},{"_id":"themes/fluid/README_en.md","hash":"71f3ebf00a4a3d3da73f609c75fbfa039600d1d1","modified":1750151776000},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1750151776000},{"_id":"themes/fluid/package.json","hash":"7746460fc2eba7439b494c46aa9b5ded81370819","modified":1750151776000},{"_id":"themes/fluid/_config.yml","hash":"7d9f119bb56fe075a7461bd1f18e2304454d70fb","modified":1750151776000},{"_id":"themes/fluid/languages/de.yml","hash":"58dccef1d98b472dc4e6f4693c2297b0c9c5afba","modified":1750151776000},{"_id":"themes/fluid/languages/en.yml","hash":"9c580471257f5a32bee701a059a45ea96755dcdc","modified":1750151776000},{"_id":"themes/fluid/languages/eo.yml","hash":"7c1a0c9f6186b6643b19d3980f055329bdb4efa4","modified":1750151776000},{"_id":"themes/fluid/languages/es.yml","hash":"026ddf1a49bf8ddfef6ed86ab4d6af143c1dd95f","modified":1750151776000},{"_id":"themes/fluid/languages/ru.yml","hash":"93818f8bf07195fb1ebffbb5210e531b0e3a6ec4","modified":1750151776000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"a60847136709bb95586a98d9d67b50390a8d2c96","modified":1750151776000},{"_id":"themes/fluid/languages/ja.yml","hash":"550b95d3614a64592f02666938d235e9f11e449e","modified":1750151776000},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"e1043de394f6dcf5c0647adcfdefe60637f78426","modified":1750151776000},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"51c2b4d64c6992a39bfd2586a1bdf5fbbbdf0175","modified":1750151776000},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1750151776000},{"_id":"themes/fluid/layout/about.ejs","hash":"052e9fc19c753f53fdc083c7fb098e3668880140","modified":1750151776000},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1750151776000},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1750151776000},{"_id":"themes/fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1750151776000},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1750151776000},{"_id":"themes/fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1750151776000},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1750151776000},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1750151776000},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1750151776000},{"_id":"themes/fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1750151776000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1750151776000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"554c0d0e086a0784d83ee71c83f8bceeb60aecc8","modified":1750151776000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"c8b0d49c49e3c88872fd3b37909345ff5b2b6aa0","modified":1750151776000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1750151776000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1750151776000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"fff07ce0472afc368d388637cb9d438195da9b5b","modified":1750151776000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1750151776000},{"_id":"themes/fluid/.github/workflows/cr.yaml","hash":"19a8a00f5ba9607d82265572fe1202b64a8b0822","modified":1750151776000},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"6f02e6440d88629229556e3fd47d0280fe2240db","modified":1750151776000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"1dadb118d580280524ed0a5f69bd34d234a92276","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"40c8b0852873032e7aaef3f68e8ea08706cdef13","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"67be642f99482c07904474f410cfbc2f99003288","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1750151776000},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1750151776000},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1750151776000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1750151776000},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1750151776000},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1750151776000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1750151776000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1750151776000},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1750151776000},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1750151776000},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1750151776000},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1750151776000},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1750151776000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1750151776000},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1750151776000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1750151776000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1750151776000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1750151776000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1750151776000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"6eaf53cf4bfc756a65bda18184cf8998a12c861d","modified":1750151776000},{"_id":"themes/fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1750151776000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1750151776000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1750151776000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1750151776000},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1750151776000},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1750151776000},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1750151776000},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1750151776000},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1750151776000},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1750151776000},{"_id":"themes/fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1750151776000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1750151776000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1750151776000},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1750151776000},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1750151776000},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1750151776000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1750151776000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1750151776000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1750151776000},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1750151776000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1750151776000},{"_id":"themes/fluid/source/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1750151776000},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1750151776000},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1750151776000},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1750151776000},{"_id":"themes/fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1750151776000},{"_id":"themes/fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1750151776000},{"_id":"themes/fluid/source/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"3d08c73b77e412d2f06a24d9344565fc7dbc76f8","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"954a29b58d72647d20450da270b5d8fb2e0824f5","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"e6dcbf1c2f56314d56bb46b50aca86ff68cacebd","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"cbfa32c5f5973133afd043853b24f8200455cb2d","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"54dd479dbb440126e4ddd9d902229db5afaaae98","modified":1750151776000},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1750151776000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1750151776000},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1750151776000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1750151776000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1750151776000},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1750151776000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1750151776000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1750151776000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1750151776000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1750151776000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"7eee3f78296a3c81849a5415d1d43dcc6e03e6aa","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"d42b748f2f49ef32aafb1a21d75991d2459da927","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1750151776000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1750151776000},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1750151776000},{"_id":"public/local-search.xml","hash":"26f20e68c0a6b7b2d9240af68e7d980b875ac13b","modified":1758109537939},{"_id":"public/about/index.html","hash":"f9618efbf6fe982d07f58f3e2a1e12466b227796","modified":1758109537939},{"_id":"public/2025/09/17/ASAN、valgrind（内存泄露的检测工具）/index.html","hash":"18e9bf9bd4eebd068f2ecd01bb217b76ce61ff02","modified":1758109537939},{"_id":"public/2025/09/17/gperftools（Google 提供的开源性能优化工具集）/index.html","hash":"59324d4601ebfea17a97e56f1881f0036608cd9b","modified":1758109537939},{"_id":"public/2025/09/17/tools_comparison/index.html","hash":"a49e2ab1bed60ef828be3f45b354d689bc40924a","modified":1758109537939},{"_id":"public/2025/09/17/hello-world/index.html","hash":"43a450496ccb548c8b3651361d5da9c11a41fadd","modified":1758109537939},{"_id":"public/2025/09/17/perf（Linux 下的性能分析器）/index.html","hash":"59c0f060c953657d00debc20c60b5c84326225ff","modified":1758109537939},{"_id":"public/categories/数据结构与算法/index.html","hash":"ce7a007312d0b3ff0ef5998de6513f0ea5af2eb5","modified":1758109537939},{"_id":"public/archives/index.html","hash":"c3a2a89108e5974b376a1b6c575dc1ed89c44b7c","modified":1758109537939},{"_id":"public/archives/2025/index.html","hash":"27abcdedc28e8abec207ecac90dcefddb2d7239a","modified":1758109537939},{"_id":"public/archives/2025/09/index.html","hash":"62ded46db15c5f3112ff4f50b5756d8a0701c0ff","modified":1758109537939},{"_id":"public/index.html","hash":"56629539ea3519849ce2a75911561f539b3c0cca","modified":1758109537939},{"_id":"public/tags/学习笔记/index.html","hash":"f314bfe9d3ad0b674e629765c46035bcd1bbaf32","modified":1758109537939},{"_id":"public/tags/算法/index.html","hash":"6660a8214f30127f24c6308390390ad19c91c448","modified":1758109537939},{"_id":"public/404.html","hash":"1da20efeb6965474d2e6733cc1a87fafc707a704","modified":1758109537939},{"_id":"public/tags/index.html","hash":"161fd90792883f06e78eb05c151e8367875e1894","modified":1758109537939},{"_id":"public/categories/index.html","hash":"a1c8a48a959997166ad02a12db627d7872369f3b","modified":1758109537939},{"_id":"public/links/index.html","hash":"93f3b2fe27eeeade9997522c7349a34e0aee6402","modified":1758109537939},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1758109537939},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1758109537939},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1758109537939},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1758109537939},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1758109537939},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1758109537939},{"_id":"public/css/main.css","hash":"14ebd9b515085666cee29bbcbe362ad3604ab62a","modified":1758109537939},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1758109537939},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1758109537939},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1758109537939},{"_id":"public/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1758109537939},{"_id":"public/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1758109537939},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1758109537939},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1758109537939},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1758109537939},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1758109537939},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1758109537939},{"_id":"public/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1758109537939},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1758109537939}],"Category":[{"name":"数据结构与算法","_id":"cmfnx0xvv0003bsvpas454uou"}],"Data":[],"Page":[{"title":"about","date":"2025-09-17T10:51:53.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2025-09-17 18:51:53\n---\n","updated":"2025-09-17T10:51:53.771Z","path":"about/index.html","comments":1,"layout":"page","_id":"cmfnx0xvr0000bsvp243jcotw","content":"","excerpt":"","more":""}],"Post":[{"title":"ASAN、valgrind（内存泄露的检测工具）","date":"2025-09-17T12:00:00.000Z","_content":"\n# ASAN、valgrind（内存泄露的检测工具）\n\n## 一、工具概览\n\n### ASan\n\n#### 什么是 AddressSanitizer？\n\n[AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer)（又名 ASan）是一款适用于 C/C++ 的内存错误检测器。\n\n#### 主要检测什么问题？\n\nASan可以检测出程序中不合理的内存使用行为，主要包括以下行为：\n\n| **错误行为**              | **简介**                                                     |\n| ------------------------- | ------------------------------------------------------------ |\n| global buffer overflow    | 全局内存访问越界                                             |\n| heap buffer overflow      | 堆内存访问越界[github.com](https://github.com/google/sanitizers/wiki/AddressSanitizerExampleHeapOutOfBounds) |\n| initialization order bugs | 全局变量初始化顺序异常全局变量初始化间存在依赖，导致实际运行时因初始化顺序问题导致的初始值异常 |\n| memory leaks              | 内存泄漏在程序正常退出时输出报告                             |\n| stack buffer overflow     | 栈内存访问越界                                               |\n| use after free            | 访问已经释放的内存，在释放内存后仍然尝试访问此内存[AddressSanitizerExampleUseAfterFree · google/sanitizers Wiki](https://github.com/google/sanitizers/wiki/AddressSanitizerExampleUseAfterFree) |\n| use after return          | 访问生命周期结束的对象在函数退出后尝试访问函数内声明的局部变量 |\n| user after scope          | 访问生命周期结束的对象在\"{}\"包起来的代码块外访问代码块内声明的局部变量 |\n\n### Valgrind\n\n#### 什么是 Valgrind（重点是 Memcheck）？\n\nValgrind 是一个用于构建动态分析工具的插桩框架。Valgrind 中的一些工具可以自动检测许多内存管理和线程错误，并详细分析您的程序。还可以使用 Valgrind 构建新的工具。\n\nValgrind 发行版目前包含七个生产级工具：一个内存错误检测器、两个线程错误检测器、一个缓存和分支预测分析器、一个调用图生成缓存和分支预测分析器，以及两个不同的堆分析器。其中最受欢迎的工具是 Memcheck。它可以检测 C 和 C++ 程序中常见的许多内存相关错误，这些错误可能导致程序崩溃和不可预测的行为。\n\n#### 主要检测什么问题？\n\n检测内存泄露，数组越界等一些程序中常见的错误。特别的，它的 memcheck 工具能够检测内存泄漏、未初始化内存的使用和非法的内存访问。\n\n## 二、原理机制\n\n### ASan工作机制\n\n详细的工作原理官方文档：https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm\n\n#### 工作原理\n\nGoogle ASan工具ASAN，全称 AddressSanitizer，也即地址消毒技术。可以用来检测内存问题，例如[缓冲区溢出](https://so.csdn.net/so/search?q=缓冲区溢出&spm=1001.2101.3001.7020)或对悬空指针的非法访问等。\nASan主要是进行[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)级别的HOOK与插桩,目前主流Clang，GCC，MSVC都支持，再结合运行时对影子内存的诊断输出，相当于双管齐下，整体效果不错；官方说是2倍左右性能开销，1/8的内存到2倍的开销。\n\nAddressSanitizer主要包括两部分：插桩(Instrumentation)和动态运行库(Run-time library)。插桩主要是针对在llvm编译器级别对访问内存的操作(store，load，alloca等)，将它们进行处理。动态运行库主要提供一些运行时的复杂的功能(比如poison/unpoison shadow memory)以及将malloc,free等系统调用函数hook住。\n\n##### 内存操作进行插桩\n\n对new,malloc,delete,free,memcpy,其它内存访问等操作进行编译时替换与代码插入，是编译器完成的；加了ASAN相关的编译选项后，代码中的每一次内存访问操作都会被编译器修改为如下方式：\n\n编译前:\n\n```c++\n*address = ...;    // or   ... = *address;\n```\n\n编译后：\n\n```c++\nif (IsPoisoned(address)) { // 判断内存是否中毒\n  ReportError(address, kAccessSize, kIsWrite);\n}\n*address = ...;  // or: ... = *address;\n```\n\n该方式的关键点就在于读写内存前会判断地址是否处于“中毒”状态，还有如何把`IsPoisoned`实现的非常快，把`ReportError`实现的非常紧凑，从而避免插入的代码过多。\n\neg：\n\n未插桩的代码：\n\n```c++\nvoid foo() {\n  char a[8];\n  ...\n  return;\n}\n```\n\n插桩后的代码：\n\n```c++\nvoid foo() {\n  char redzone1[32];  // 32-byte aligned\n  char a[8];          // 32-byte aligned\n  char redzone2[24]; \n  char redzone3[32];  // 32-byte aligned\n  int  *shadow_base = MemToShadow(redzone1);\n  shadow_base[0] = 0xffffffff;  // poison redzone1\n  shadow_base[1] = 0xffffff00;  // poison redzone2, unpoison 'a'\n  shadow_base[2] = 0xffffffff;  // poison redzone3\n  ...\n  shadow_base[0] = shadow_base[1] = shadow_base[2] = 0; // unpoison all\n  return;\n}\n```\n\n##### 内存映射与诊断\n\n按照一定的算法对原始内存进行一分影子内存的拷贝生成，目前不是1：1的拷贝，而是巧妙的按1/8大小进行处理，并进行一定的下毒与标记，减少内存的浪费。正常访问内存前，先对影子内存进行检查访问，如果发现数据不对，就进行诊断报错处理。\n\n运行时库（libasan.so）malloc/free函数进行了替换，在malloc函数中额外的分配了Redzone区域的内存，将与Redzone区域对应的影子内存加锁，主要的内存区域对应的影子内存不加锁。redzone 被标记为中毒状态，free函数将所有分配的内存区域加锁，并放到了隔离区域的队列中(保证在一定的时间内不会再被malloc函数分配)，并被标记为中毒状态。\n\n![mapping图片](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250514220252808.png)\n\n##### 防护缓冲区溢出的基本步骤\n\n中毒状态：内存对应的 shadow 区标记该内存不能访问的状态\n\n```mermaid\nflowchart TD\n    A[创建 redzone<br>在全局变量、堆、栈前后插入<br>并标记为中毒状态] --> B[建立影子内存区<br>8 字节内存对应 1 字节影子]\n    B --> C[访问 redzone（如读写）<br>对应影子内存为中毒状态<br>触发报错]\n    C --> D[报错信息：进程号、错误类型、<br>源文件名、行号、函数调用关系、<br>影子内存状态（出错部分中括号标注）]\n```\n\n\n\n##### 内存泄漏检测原理\n\n\n\n```mermaid\nflowchart TD\n    A[\"ASAN 接管内存申请接口<br>(用户使用的内存全部由 ASAN 管理)\"] --> B[\"进程退出时触发 ASAN 内存泄漏检测<br>(可通过复位、重启等方式触发)\"]\n    B --> C[遍历所有未释放堆内存]\n    C --> D{该内存是否仍被引用？}\n    D -- 是 --> F[跳过，未泄漏]\n    D -- 否 --> E[认定为内存泄漏<br>输出内存大小与申请调用栈]\nclassDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n#### 源码路径\n\n| 路径                                                       | 文件/模块                       | 作用                                   |\n| ---------------------------------------------------------- | ------------------------------- | -------------------------------------- |\n| `asan_rtl.cpp`                                             | 运行时库入口（RunTime Library） | 初始化 ASan、设置 hook、启动检测等     |\n| `asan_interceptors.cpp`                                    | 标准函数拦截器                  | 重写 `memcpy`、`malloc`、`free` 等函数 |\n| `asan_report.cpp`                                          | 报告错误栈信息                  | 打印报错信息、栈追踪、源码位置等       |\n| `asan_mapping.h`                                           | Shadow memory 映射逻辑          | 1:8 映射关系，关键 shadow 计算         |\n| `asan_allocator.cpp`                                       | 自定义内存分配器                | 包含红区、对齐等安全逻辑               |\n| `asan_poisoning.cpp`                                       | 中毒/恢复接口                   | 调用 poison/unpoison 改变内存状态      |\n| `asan_thread.cpp`                                          | 线程管理                        | TLS、线程栈信息维护等                  |\n| `llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp` | 插桩入口                        | 插入对 `shadow memory` 的访问检查代码  |\n\n#### 源码分析\n\n运行时库入口：\n\n```mermaid\ngraph TD\n  A[\"compiler-rt/lib/asan/asan_rtl.cpp/__asan_init()\"] --> B[\"asan_activation.cpp/AsanActivate()激活Asan\"]\n  A --> C[\"AsanInitFromRtl()\"]\n  C --> D[\"AsanInitInternal()\"]\n  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n```c++\nstatic bool AsanInitInternal() {\n    ……\n    // 设置内存毒化和分配上下文大小\n    SetCanPoisonMemory(flags()->poison_heap);\n  \tSetMallocContextSize(common_flags()->malloc_context_size);\n    ……\n    // 初始化拦截器\n    InitializeAsanInterceptors();\n    ……\n    // 初始化影子内存\n    InitializeShadowMemory();\n    ……\n    // 初始化分配器\n    AllocatorOptions allocator_options;\n  \tallocator_options.SetFrom(flags(), common_flags());\n    InitializeAllocator(allocator_options);\n    ……\n    // 创建主线程，初始化反编辑器\n    AsanThread *main_thread = CreateMainThread();\n  \tCHECK_EQ(0, main_thread->tid());\n    force_interface_symbols();  // no-op.\n    SanitizerInitializeUnwinder();\n    ……\n}\n```\n\n`asan_mapping.h` 查看 shadow memory 的映射计算公式：\n\n```c++\n#define ASAN_SHADOW_SCALE 3\n……\n#    define MEM_TO_SHADOW(mem) \\\n      (((mem) >> ASAN_SHADOW_SCALE) + (ASAN_SHADOW_OFFSET))\n#    define SHADOW_TO_MEM(mem) \\\n      (((mem) - (ASAN_SHADOW_OFFSET)) << (ASAN_SHADOW_SCALE))\n```\n\n\n\n### Valgrind工作机制\n\n#### 工作原理\n\nValgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。最直观的表达就是：`Valgrind内核 + 工具插件 = Valgrind工具`。在Valgrind框架下编写一个二进制程序动态分析工具比从零开始简很多，因为Valgrind内核为新工具的编写提供了许多通用的工具集，比如错误记录、动态插桩等。\n\n当Valgrind工具程序启动时：\n\n1. 将需要分析的程序加载与工具程序同一个进程空间中；\n2. 使用`JIT（just-in-time）`的动态二进制重编译技术，将代码分成一个个小的代码块实施重编译；\n3. 在重编译过程中，**Valgrind内核会将相应代码块的机器码转化成中间表示**，插件会在中间代码中进行相应分析代码的**插桩**，最后通过内核把中间表示转换成原本的机器码，在目标机器上执行；**（源机器码 --> 插桩 --> 目标机器码）**\n4. Valgrind内核大部分时间花在上述机器码和中间表示的相互翻译执行中，**而原程序的所有机器码并没有执行，执行的都是插桩后的代码**\n\n所有的Valgrind工具都是使用**静态链接**的可执行文件，里面包含了Valgrind内核和工具插件。虽然这样会导致每个工具程序中都需要包含一份Valgrind内核，内核大概2.5MB左右，稍微浪费一些磁盘空间，但是静态链接可以使整个可执行文件加载到非标准的启动地址，方便把待分析程序加载进同一个进程空间中，然后使用Valgrind重编译技术将待分析程序机器码重编译到别的地址执行。\n\n##### 核心框架\n\nValgrind的体系结构如下图所示：\n\n![img](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509144807842.png)\n\n##### 工具启动\n\n```mermaid\ngraph TD\n    A[命令行运行 valgrind --tool=&lt;tool&gt;] --> B[valgrind 程序根据 tool 参数调用 execv]\n    B --> C[加载对应的 Valgrind 工具插件]\n    C --> D[Valgrind 内核初始化子系统<br>（地址空间管理器、内存分配器等）]\n    D --> E[映射目标程序的 .text/.data 段<br>配置堆栈等]\n    E --> F[初始化命令行参数<br>并加载工具插件]\n    F --> G[加载更多子系统：<br>翻译表、信号处理、调度器、调试信息等]\n    G --> H[准备完毕，开始执行目标程序第一条指令<br>进行 JIT 重编译（插桩）并运行]\n```\n\n##### 中间表示（VEX）\n\n在Valgrind的重编译的过程中，使用的中间表示是一种平台无关的语言——VEX，通过屏蔽硬件平台的差异性，节省了大量针对不同平台的插桩代码。\n\n- Statement（结构体`IRStmt`）表示有副作用的操作，如写寄存器、写内存、临时变量赋值等。其中，Statement由Expression组成。\n\n- Expression (结构体`IRExpr`) 表示没有副作用的操作，如读内存、做算术运算等，这些操作可以包含子表达式和表达式树。\n\n- 在Valgrind中，代码被分解成多个小的代码块，每个代码块里包含VEX的Statement列表。每个代码块的结构体是`IRSB`，`IRSB`是单入口多出口的，代码如下所示：\n\n  ```c++\n  typedef\n     struct {\n        IRTypeEnv* tyenv; // 表明IRSB中每个临时变量的类型\n        IRStmt**   stmts; // VEX语句列表\n        Int        stmts_size; // Statements总长度\n        Int        stmts_used; // 实际上使用的Statements的数目\n        IRExpr*    next; // 下一跳的位置\n        IRJumpKind jumpkind; // 最后代码块结束jump的类型\n        Int        offsIP; // IP寄存器的偏移\n     }\n     IRSB;\n  ```\n\n- Valgrind根据一定规则将代码划分为很多小代码块后，会进行以下八个阶段，将插件的分析代码进行插桩并优化：\n\n  ```mermaid\n  graph TD\n      A[反汇编：机器码] --> B[树状中间表示]\n      B --> C[扁平中间表示]\n      C --> D[带桩的扁平中间表示]:::important\n      D --> E[优化的扁平中间表示]\n      E --> F[汇编：带桩的树状中间表示]:::important\n      F --> G[目标汇编代码]\n      G --> H[寄存器优化的目标汇编代码]\n      H --> I[机器码]\n   classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n  ```\n\n- JIT执行：\n\n  ```mermaid\n  flowchart TD\n      A[插桩后的机器码生成] --> B[保存到固定大小的哈希表<br>（线性探测，80%阈值）]:::important\n      B --> C{哈希表是否达到80%容量？}\n      C -- 是 --> D[FIFO策略<br>丢弃1/8最旧的代码块]\n      C -- 否 --> E[继续执行]\n      E --> F[代码块执行完毕]\n      D --> F\n      F --> G[进入dispatcher（汇编实现）]\n      G --> H{dispatcher快速缓存命中？}\n      H -- 是 --> I[切换到下一个代码块（快速跳转）]\n      H -- 否 --> J[进入scheduler（C实现）]\n      J --> K{哈希表中存在目标代码块？}\n      K -- 是 --> L[更新dispatcher缓存<br>并跳转]\n      K -- 否 --> M[重新插桩编译<br>加入哈希表并更新dispatcher缓存]\n      M --> L\n   classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n  ```\n\n##### Memcheck 检测原理\n\n**Memcheck**检测内存问题的原理如下图所示：\n\n![内存检查原理](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509150159067.jpeg)\n\nMemcheck 能够检测出内存问题，关键在于其建立了两个全局表。\n\n- Valid-Value 表：对于进程的整个地址空间中的每一个字节(byte)，都有与之对应的 8 个 bits；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。\n- Valid-Address 表：对于进程整个地址空间中的每一个字节(byte)，还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。\n\n![memcheck影子内存](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509171919962.png)\n\n**检测原理**：\n\n- 当要读写内存中某个字节时，首先检查这个字节对应的 A bit。如果该A bit显示该位置是无效位置，memcheck 则报告读写错误。\n- 内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 memcheck 会检查对应的V bits，如果该值尚未初始化，则会报告使用未初始化内存错误。\n\n##### Valgrind回调Memcheck\n\n```c++\nstatic void mc_pre_clo_init( void );\nstatic void mc_post_clo_init ( void );\nIRSB* MC_(instrument) ( VgCallbackClosure* closure,\n                        IRSB* sb_in,\n                        const VexGuestLayout* layout,\n                        const VexGuestExtents* vge,\n                        const VexArchInfo* archinfo_host,\n                        IRType gWordTy, IRType hWordTy );\nstatic void mc_fini ( Int exitcode );\n```\n\n上述四个接口，由Valgrind在不同阶段调用。其中，`mc_pre_clo_init` 和 `mc_post_clo_init`用于初始化memcheck插件，`MC_(instrument)` 是在scheduler需要translate的插桩阶段会调用。\n\n```c++\n   VG_(track_new_mem_startup)     ( mc_new_mem_startup );\n   VG_(track_new_mem_mmap)        ( mc_new_mem_mmap );\n   VG_(track_change_mem_mprotect) ( mc_new_mem_mprotect );\n   VG_(track_copy_mem_remap)      ( MC_(copy_address_range_state) );\n   VG_(track_die_mem_stack_signal)( MC_(make_mem_noaccess) );\n   VG_(track_die_mem_brk)         ( MC_(make_mem_noaccess) );\n   VG_(track_die_mem_munmap)      ( MC_(make_mem_noaccess) );\n...\n   VG_(track_die_mem_stack)       ( mc_die_mem_stack     );\n   VG_(track_ban_mem_stack)       ( MC_(make_mem_noaccess) );\n   VG_(track_pre_mem_read)        ( check_mem_is_defined );\n   VG_(track_pre_mem_read_asciiz) ( check_mem_is_defined_asciiz );\n   VG_(track_pre_mem_write)       ( check_mem_is_addressable );\n   VG_(track_post_mem_write)      ( mc_post_mem_write );\n   VG_(track_post_reg_write)                  ( mc_post_reg_write );\n   VG_(track_post_reg_write_clientcall_return)( mc_post_reg_write_clientcall );\n```\n\n上述这些 `VG_(track_*)` 函数是用于向Valgrind内核注册相应的事件监控，这些事件难以通过插桩来拦截的，如堆块的分配、堆栈指针的修改、信号处理等。当注册的事件发生时，Valgrind内核会调用Memcheck注册的函数。\n\n#### 工具包\n\n##### Memcheck※\n\nMemcheck检测内存管理问题，主要针对C和C++程序。当一个程序在Memcheck的监督下运行时，所有对内存的读取和写入都会被检查，并拦截对malloc/new/free/delete的调用。因此，Memcheck可以检测您的程序是否：\n\n- 访问不应该访问的内存（尚未分配的区域、已释放的区域、超过堆块末尾的区域、堆栈中不可访问的区域）。\n- 以危险的方式使用未初始化的值。\n- 内存泄漏。\n- 对堆块执行错误的释放（双重释放、不匹配的释放）。\n- 将重叠的源内存块和目标内存块传递给memcpy()和相关函数。\n\nMemcheck会在这些错误发生时立即报告，给出发生错误的源行号，以及为到达该行而调用的函数的堆栈跟踪。Memcheck在字节级别跟踪可寻址性，在位级别跟踪值的初始化。因此，它可以检测单个未初始化位的使用，并且不会报告位字段操作中的虚假错误。Memcheck运行的程序比正常速度慢10-30倍。\n\n##### Cachegrind\n\nCachegrind是一个缓存探查器。它对CPU中的I1、D1和L2缓存执行详细的模拟，因此可以准确地确定代码中缓存未命中的来源。它通过每个函数、每个模块和整个程序摘要来识别每行源代码的缓存未命中、内存引用和执行的指令的数量。它适用于用任何语言编写的程序。Cachegrind运行的程序比正常速度慢20-100倍。\n\n##### Callgrind\n\nJosef Weidendorfer的Callgrind是对Cachegrind的扩展。它提供了Cachegrind所做的所有信息，以及关于调用图的额外信息。它在3.2.0版本中被集成到Valgrind的主版本中。单独提供的是一个令人惊叹的可视化工具[KCachegrind](https://kcachegrind.sourceforge.net/html/Home.html)，它可以更好地概述Callgrind收集的数据；它还可以用于可视化Cachegrind的输出。\n\n##### Massif\n\nMassif是一个堆探查器。它通过获取程序堆的定期快照来执行详细的堆评测。它生成一个图表，显示堆使用情况随时间的变化，包括程序中哪些部分负责最多内存分配的信息。该图由一个文本或HTML文件补充，该文件包括更多信息，用于确定在哪里分配了最多的内存。Massif运行程序的速度比正常速度慢20倍。\n\n##### Helgrind\n\nHelgrind是一个线程调试器，用于在多线程程序中查找数据竞赛。它查找由多个（POSIX p-）线程访问的内存位置，但找不到一致使用的（pthread_mutex_）锁。这样的位置指示线程之间缺少同步，并且可能导致难以找到与定时相关的问题。它对任何使用pthreads的程序都很有用。这是一个有点实验性的工具，所以这里特别欢迎您的反馈。\n\n##### DRD\n\nDRD是一种用于检测多线程C和C++程序中错误的工具。该工具适用于任何使用POSIX线程原语或使用在POSIX线程基元之上构建的线程概念的程序。虽然Helgrind可以检测到违反锁定顺序的情况，但对于大多数程序来说，DRD执行其分析所需的内存较少。\n\n##### Lackey，Nulgrind\n\nLackey和Nulgrind也包括在Valgrind分布中。它们做的不多，只是为了测试和演示。\n\n##### DHAT\n\nDHAT是一个用于检查程序如何使用堆分配的工具。它跟踪分配的块，并检查每次内存访问，以找到要访问的块（如果有的话）。它还附带了一个GUI，以便于探索配置文件结果\n\n#### 源码路径\n\n| 步骤                      | 入口源码                                         | 阅读重点                                                     |\n| ------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |\n| 1️⃣ 启动流程                | `coregrind/m_main.c` 中的 `main()` 函数          | Valgrind 启动逻辑、注册工具、加载用户程序                    |\n| 2️⃣ 工具注册                | `memcheck/mc_main.c` 中的 `mc_pre_clo_init()`    | Memcheck 是如何作为插件注册并接管分析任务的                  |\n| 3️⃣ 插桩入口                | `memcheck/mc_translate.c` 中的 `MC_(instrument)` | 如何在 VEX IR 上插入 shadow memory 逻辑来检测读写            |\n| 4️⃣ shadow memory 实现      | `memcheck/mc_machine.c`、`mc_memory.c`           | 如何为用户空间内存建立 shadow 映射<br>如何检查是否初始化、是否重叠写入等 |\n| 5️⃣ 报错逻辑                | `memcheck/mc_errors.c`                           | 各类内存错误的触发条件、错误消息打印函数                     |\n| 6️⃣ VEX IR 转换（了解即可） | `VEX/pub/libvex.h`、`coregrind/m_translate.c`    | 了解如何将指令翻译成 IR 并应用插件逻辑                       |\n\n#### 源码分析\n\n##### 启动流程\n\n```mermaid\ngraph TD\n  A[\"coregrind/m_main.c/valgrind_main()\"] --> B[\"启动调试信息\"]\n  A --> C[\"启动地址空间管理器\"]\n  A --> D[\"启动动态内存管理器\"]\n  B --> E[\"识别cpu类型\"]\n  C --> E\n  D --> E\n  E --> F[\"识别工具类型\"]\n  F --> G[\"设置默认的 vex 控制参数\"]\n  G --> H[\"初始化工具tl_pre_clo_init()/tool_post_clo_init()\"]:::important\n  H --> J[\"初始化调度器\"]\n  J --> K[\"设置一些堆栈状态，运行\"]\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n##### 工具注册（以memcheck为例）\n\n```mermaid\ngraph TD\n  A[\"memcheck/mc_main.c/mc_pre_clo_init()\"] --> B[\"VG_(basic_tool_funcs)\"]\n  B --> C[\"插桩入口MC_(instrument)\"]:::important\n  A --> D[\"VG_(needs_tool_errors)\"]\n  D --> E[\"报错逻辑入口MC_(eq_Error)\"]\n  A --> F[\"初始化shadow映射init_shadow_memory()\"]\n  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n```c++\n// mermaid --启动调试信息\n// memcheck/mc_main.c\nstatic void mc_pre_clo_init(void)\n{\n   ……\n   // 注册工具，插桩入口\n   VG_(basic_tool_funcs)          (mc_post_clo_init,\n                                   MC_(instrument),\n                                   mc_fini);\n   ……\n   // 报错逻辑入口\n   VG_(needs_tool_errors)         (MC_(eq_Error),\n                                   MC_(before_pp_Error),\n                                   MC_(pp_Error),\n                                   True,/*show TIDs for errors*/\n                                   MC_(update_Error_extra),\n                                   MC_(is_recognised_suppression),\n                                   MC_(read_extra_suppression_info),\n                                   MC_(error_matches_suppression),\n                                   MC_(get_error_name),\n                                   MC_(get_extra_suppression_info),\n                                   MC_(print_extra_suppression_use),\n                                   MC_(update_extra_suppression_use));\n   ……\n   // shadow映射\n   init_shadow_memory();\n   ……\n}\n```\n\n### 实现的不同之处\n\n|              | AddressSanitizer (ASan)                                  | Valgrind                                             |\n| ------------ | -------------------------------------------------------- | ---------------------------------------------------- |\n| 实现方式     | 编译期插桩（基于 Clang/LLVM 插入检查代码）               | 动态二进制插桩（运行时在二进制层面插桩）             |\n| 插桩时机     | 编译时                                                   | 运行时                                               |\n| 插桩方式     | 修改 LLVM IR，插入 shadow memory 检查逻辑                | 使用 JIT 模拟器重写程序指令                          |\n| 内存状态追踪 | 使用 Shadow Memory，通常 1:8 映射                        | 通过完整模拟 CPU 访问并维护虚拟内存状态              |\n| 运行时依赖   | 编译后程序链接 runtime 库（compiler-rt）                 | 不修改原程序，Valgrind 作为宿主启动目标程序          |\n| 性能开销     | 较低（~2x）                                              | 较高（10x-50x）                                      |\n| 可移植性     | 与编译器强绑定（Clang）                                  | 与平台强绑定（对 x86/x86_64 支持好）                 |\n| 检测能力     | 精度高但主要针对 Heap/Stack/Global 的越界/Use-After-Free | 检测更全面，包含内存泄漏、未初始化变量、未定义行为等 |\n| 可扩展性     | 可通过编译器 Pass 扩展                                   | 可通过开发工具插件（如 Helgrind, DRD）扩展           |\n\n## 三、安装与使用方式\n\n### ASan 使用\n\n#### 安装Asan\n\n在 Ubuntu 上，**ASan (AddressSanitizer)** **不需要单独安装**，因为它是 **GCC** 或 **Clang** 编译器自带的功能模块。你只需要确保你的 **GCC** 或 **Clang** 版本支持 ASan（一般 Ubuntu 18.04+ 默认都支持）。\n\n#### 使用Asan\n\n1. 使用要求：编译时加上 `-fsanitize=address -g`（`-fsanitize=address`：启用 AddressSanitizer，`-g`：生成调试符号，方便错误定位到具体源码行号）\n\n   ```bash\n   # eg\n   g++ -fsanitize=address -g your_code.cpp -o your_program\n   # -fno-omit-frame-pointer 让栈追溯信息更加友好\n   ```\n\n2. 编译后直接运行，出现非法内存访问、溢出、use-after-free 等时，ASan 会自动终止程序并输出详细错误栈信息。\n\n   ```bash\n   ./your_program\n   ```\n\n3. 进阶配置：可以通过环境变量控制 ASan 行为：\n\n   - 显示更多详细信息：\n\n     ```bash\n     export ASAN_OPTIONS=verbosity=1\n     ```\n\n   - 打印出泄漏检测（需要加 `-fsanitize=leak`）：\n\n     ```bash\n     export ASAN_OPTIONS=detect_leaks=1\n     ```\n\n     ```bash\n     # eg：\n     export ASAN_OPTIONS=detect_leaks=1:abort_on_error=1\n     ./your_program\n     ```\n\n     | **flag**                      | **含义**                                                     |\n     | ----------------------------- | ------------------------------------------------------------ |\n     | halt_on_error                 | 默认为1，ASan检测到错误后会中止程序设为0后，ASan检测到错误后不会中止程序 |\n     | log_path                      | 设置错误信息的输出路径                                       |\n     | detect_stack_use_after_return | 是否检测use after return错误默认为0，即关闭该检测功能        |\n     | help=1                        | 输出所有支持的参数                                           |\n\n- 编译加上 `-fsanitize=address -g`\n\n  \n\n更多ASAN_OPTIONS可以参考：https://github.com/google/sanitizers/wiki/AddressSanitizerFlags\n\n### Valgrind 使用\n\n#### 安装 Valgrind\n\n```sh\nsudo apt install valgrind \n```\n\n![image-20250426221902277](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426221902305.png)\n\n#### 使用valgrind\n\n1. 使用要求：编译程序时使用调试信息选项 -g（使用编译程序以-g包含调试信息，以便 Memcheck 的错误消息包含准确的行号。-O0如果您可以忍受速度变慢，使用也是一个好主意。 -O1错误消息中的行号可能不准确，但通常情况下，在编译的代码上运行 Memcheck-O1效果很好，而且与直接运行相比，速度提升-O0非常显著。 -O2不建议使用及以上版本，因为 Memcheck 偶尔会报告实际上并不存在未初始化值的错误）。\n2. 使用方法：使用 valgrind 运行程序：valgrind --leak-check=full ./your_program\n3. 常用选项：\n   - --leak-check=full：启用详细的内存泄漏检测。\n   - --track-origins=yes：在内存未初始化时，报告其来源。\n   - --log-file=filename：将 Valgrind 的输出写入文件 filename\n\n## 四、检测能力比较\n\n| 比较项         | ASan                            | Valgrind                          |\n| -------------- | ------------------------------- | --------------------------------- |\n| 检测内存越界   | ✅ 高效准确                      | ✅ 高效准确                        |\n| 检测内存泄漏   | ✅（可选配 LeakSanitizer）       | ✅（默认内置）                     |\n| 检测未初始化读 | ❌（需要另加 MSan）              | ✅                                 |\n| 检测堆栈溢出   | ✅（有限支持）                   | ✅（通过 Memcheck 支持）           |\n| 检测速度       | 🔥 极快（通常 2x-3x 原程序速度） | 🐢 较慢（通常 10x-50x 原程序速度） |\n| 支持大程序     | ✅ 支持大内存程序                | ❌ 容易内存爆掉                    |\n| 平台支持       | Linux、macOS、Windows (部分)    | Linux、macOS（Windows 支持差）    |\n\n## 五、输出示例与解读\n\n### ASan 错误输出示例\n\n#### 验证代码\n\n```c++\nint main(int argc, char **argv) {\n  int *array = new int[100];\n  delete [] array;\n  return array[argc];  // BOOM\n}\n// RUN: clang -O -g -fsanitize=address %t && ./a.out\n```\n\n#### 验证结果\n\n```c++\n=================================================================\n==6254== ERROR: AddressSanitizer: heap-use-after-free on address 0x603e0001fc64 at pc 0x417f6a bp 0x7fff626b3250 sp 0x7fff626b3248\nREAD of size 4 at 0x603e0001fc64 thread T0\n    #0 0x417f69 in main example_UseAfterFree.cc:5\n    #1 0x7fae62b5076c (/lib/x86_64-linux-gnu/libc.so.6+0x2176c)\n    #2 0x417e54 (a.out+0x417e54)\n0x603e0001fc64 is located 4 bytes inside of 400-byte region [0x603e0001fc60,0x603e0001fdf0)\nfreed by thread T0 here:\n    #0 0x40d4d2 in operator delete[](void*) /home/kcc/llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:61\n    #1 0x417f2e in main example_UseAfterFree.cc:4\npreviously allocated by thread T0 here:\n    #0 0x40d312 in operator new[](unsigned long) /home/kcc/llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:46\n    #1 0x417f1e in main example_UseAfterFree.cc:3\nShadow bytes around the buggy address:\n  0x1c07c0003f30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x1c07c0003f40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x1c07c0003f50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x1c07c0003f60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x1c07c0003f70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x1c07c0003f80: fa fa fa fa fa fa fa fa fa fa fa fa[fd]fd fd fd\n  0x1c07c0003f90: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x1c07c0003fa0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x1c07c0003fb0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fa fa\n  0x1c07c0003fc0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x1c07c0003fd0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:     fa\n  Heap righ redzone:     fb\n  Freed Heap region:     fd\n  Stack left redzone:    f1\n  Stack mid redzone:     f2\n  Stack right redzone:   f3\n  Stack partial redzone: f4\n  Stack after return:    f5\n  Stack use after scope: f8\n  Global redzone:        f9\n  Global init order:     f6\n  Poisoned by user:      f7\n  ASan internal:         fe\n==6254== ABORTING\n```\n\n#### 结果分析\n\n```sh\n1. 错误类型摘要\n    # ASan 检测到错误类型是 heap-use-after-free，表示访问了已经释放的堆内存。\n    ==6254== ERROR: AddressSanitizer: heap-use-after-free on address 0x603e0001fc64\n\n2. 出错位置\n    # 错误发生在 example_UseAfterFree.cc 文件的第5行 main 函数中。\n    # 出错时正在读取（READ）4字节的数据。\n    READ of size 4 at 0x603e0001fc64 thread T0\n      #0 0x417f69 in main example_UseAfterFree.cc:5\n      #1 0x7fae62b5076c (/lib/x86_64-linux-gnu/libc.so.6+0x2176c)\n      #2 0x417e54 (a.out+0x417e54)\n\n3. 内存分配与释放信息\n    # 这块内存是在 example_UseAfterFree.cc 文件第3行通过 new[] 分配的。\n    previously allocated by thread T0 here:\n      #0 0x40d312 in operator new[](unsigned long)\n      #1 0x417f1e in main example_UseAfterFree.cc:3\n\n    # 这块内存已经在第4行通过 delete[] 被释放。\n    freed by thread T0 here:\n      #0 0x40d4d2 in operator delete[](void*)\n      #1 0x417f2e in main example_UseAfterFree.cc:4\n\n4. Shadow Memory 状态\n    # 出错地址周围的 Shadow Memory 信息如下：\n    Shadow bytes around the buggy address:\n      0x1c07c0003f80: fa fa fa fa fa fa fa fa fa fa fa fa [fd]fd fd fd\n    # 其中 fd 表示 \"Freed Heap Region\"，即已经释放的堆内存。\n    # 说明正在访问一块已经释放的堆区域，因此发生了 heap-use-after-free 错误。\n\n5. Shadow Byte Legend\n    # Shadow Byte 各个标记含义：\n    - 00: 正常可访问内存\n    - fd: 已释放的堆内存（Freed Heap region）\n    - fa: 堆红区（Heap redzone，用于保护越界）\n```\n\n更多例子在：https://github.com/google/sanitizers/wiki/addresssanitizer的introduction部分\n\n### Valgrind 输出示例\n\n#### 验证代码\n\n```c++\n#include <iostream>\nvoid func(){\n    int* p = new int(10); // 只申请不回收，leak\n}\nint main(){\n\n    func();\n    return 0;\n}\n// sh命令\ng++ test.cpp -g\nvalgrind --leak-check=full ./a.out\n```\n\n#### 验证结果\n\n```sh\n[root:~/stutest]# valgrind --leak-check=full ./a.out \n==1536437== Memcheck, a memory error detector\n==1536437== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==1536437== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info\n==1536437== Command: ./a.out\n==1536437== \n==1536437== \n==1536437== HEAP SUMMARY: # 堆摘要\n==1536437==     in use at exit: 4 bytes in 1 blocks\n==1536437==   total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated\n==1536437== \n==1536437== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1\n==1536437==    at 0x48657B8: operator new(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)\n==1536437==    by 0x1088E3: func() (test.cpp:4)\n==1536437==    by 0x108907: main (test.cpp:9)\n==1536437== \n==1536437== LEAK SUMMARY: # 泄露摘要\n==1536437==    definitely lost: 4 bytes in 1 blocks\n==1536437==    indirectly lost: 0 bytes in 0 blocks\n==1536437==      possibly lost: 0 bytes in 0 blocks\n==1536437==    still reachable: 0 bytes in 0 blocks\n==1536437==         suppressed: 0 bytes in 0 blocks\n==1536437== \n==1536437== For lists of detected and suppressed errors, rerun with: -s\n==1536437== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n```\n\n#### 结果分析\n\n```sh\n1. 堆摘要：\n\t# 在程序结束时，有 4 字节的内存仍然在使用，这意味着有一块 4 字节的内存没有被释放。\n    in use at exit: 4 bytes in 1 blocks\n    # 程序总共进行了 2 次内存分配操作（allocs），但是只进行了 1 次内存释放操作（frees），总共分配了 72,708 字节的内存。\n    total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated\n2. 泄漏摘要\n\t# Valgrind 确认有 4 字节内存泄漏，这次泄漏的详细信息如下：\n\t4 bytes in 1 blocks are definitely lost in loss record 1 of 1\n\t# 内存是在调用 operator new 时分配的，这通常表示你使用了 new 操作符分配了内存。\n\tat 0x486578B: operator new(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)\n\t# func() 函数中进行了内存分配，这是导致内存泄漏的地方。\n\tby 0x1088E3: func() (test.cpp:4)\n\t# main 函数调用了 func()，导致了内存泄漏。\n\tby 0x108907: main (test.cpp:9)\n3. 错误摘要\n\t# 总共检测到 1 个内存泄漏错误，且没有任何错误被抑制。\n    ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n```\n\n### 常见内存泄漏的场景\n\n```c++\n#include <iostream>\n#include <cstring>\n\nvoid memoryLeak1() {\n    // 简单的内存泄漏，没有释放分配的内存\n    int* leakyArray = new int[100];\n    // 忘记释放 leakyArray\n}\n\nvoid memoryLeak2() {\n    // 动态分配的内存覆盖了原先分配的内存，导致原内存泄漏\n    char* leakyString = new char[25];\n    strcpy(leakyString, \"Initial allocation\");\n    \n    // 重新分配，原内存未释放\n    leakyString = new char[50];\n    strcpy(leakyString, \"Reallocation causes leak\");\n\n    delete[] leakyString; // 释放第二次分配的内存\n}\n\nvoid memoryLeak3() {\n    // 部分内存泄漏，未释放结构体中的某些成员\n    struct Node {\n        int* value;\n        Node* next;\n    };\n\n    Node* node = new Node;\n    node->value = new int(10);\n    node->next = nullptr;\n\n    delete node; // 只释放了 node，没有释放 node->value\n}\n\nvoid memoryLeak4() {\n    // 使用未初始化的指针\n    int* uninitializedPtr;\n    *uninitializedPtr = 42; // 未定义行为\n}\n\nint main() {\n    memoryLeak1();\n    memoryLeak2();\n    memoryLeak3();\n    memoryLeak4();\n\n    std::cout << \"Done testing memory leaks!\" << std::endl;\n    return 0;\n}\n```\n\n## 六、常见问题与坑\n\n### **ASan 常见问题**\n\n- 与某些库冲突（如 glibc 的 hook）\n- 需要匹配 libc 版本\n- asan版本程序在Linux环境下运行时会额外申请20TB的虚拟内存，会增加大量的虚拟内存使用\n  - 需要确保/proc/sys/vm/overcommit_memory的值不为2\n  - 这也可以作为检验ASan是否工作的标志\n- asan工具不是万能的，必须要跑到有问题的代码才可以暴露出来\n\n### **Valgrind 常见问题**\n\n- 运行特别慢\n- 不支持 AVX-512、SIMD 优化程序\n- 对于一些静态分配或在堆栈上分配的数组的超出范围的读取或写入，Valgrind 可能无法检测到\n- 在检测某些复杂的内存错误场景时，可能会出现误报或漏报的情况\n\n## 七、实战应用场景建议\n\n### 什么时候优先用 ASan？\n\n- 开发阶段，快速找到内存错误\n- 代码量很大的时候用Asan\n\n### 什么时候优先用 Valgrind？\n\n- 找难以发现的泄漏和未初始化读问题，做深入分析\n\n| 场景/目标                             | 适用工具                        | 原因说明                                                    |\n| ------------------------------------- | ------------------------------- | ----------------------------------------------------------- |\n| 1. 内存越界访问检测                   | ✅ ASan & ✅ Valgrind             | 两者均可，但 ASan 检测更快且栈信息更清晰                    |\n| 2. Use-After-Free 检测                | ✅ ASan & ✅ Valgrind             | 都能检测，但 ASan 执行效率更高                              |\n| 3. 内存泄漏检测                       | ✅ Valgrind（Memcheck）          | ASan 对泄漏检测不如 Valgrind 精细（除非搭配 LeakSanitizer） |\n| 4. 未初始化内存使用检测               | ✅ Valgrind                      | ASan 无法检测未初始化使用，Valgrind 的 Undef-Value 检测更强 |\n| 5. 并发线程数据竞争检测               | 🔶 DRD/Helgrind（Valgrind 插件） | ASan 无法检测数据竞争，需用 TSan；Valgrind 插件较弱         |\n| 6. 性能要求较高的场合                 | ✅ ASan                          | Valgrind 开销大，ASan 更适合实战部署前测试                  |\n| 7. 快速集成进 CI/CD                   | ✅ ASan                          | 编译期工具更易于集成测试流程                                |\n| 8. 无法重编译的三方库检测             | ✅ Valgrind                      | ASan 需重新编译，Valgrind 可直接运行已有二进制              |\n| 9. 动态分析研究/教学                  | ✅ Valgrind                      | 更直观、可观测性强、控制粒度高                              |\n| 10. 大型 C++ 项目（如游戏、系统工具） | ✅ ASan                          | 开销小，误报少，更适合持续集成测试                          |\n\n## 八、总结\n\n- 两者优缺点汇总\n- 推荐搭配使用的方法（如开发中用 ASan，发布前用 Valgrind 细扫）\n\n学习资料\n\n- https://valgrind.org/\n- https://hardcore.feishu.cn/docx/doxcnXfsINxeICDFXePBelN3p5f\n\n","source":"_posts/ASAN、valgrind（内存泄露的检测工具）.md","raw":"---\ntitle: \"ASAN、valgrind（内存泄露的检测工具）\"\ndate: 2025-09-17 20:00:00\ntags:\n  - 学习笔记\n  - 算法\ncategories:\n  - 数据结构与算法\n---\n\n# ASAN、valgrind（内存泄露的检测工具）\n\n## 一、工具概览\n\n### ASan\n\n#### 什么是 AddressSanitizer？\n\n[AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer)（又名 ASan）是一款适用于 C/C++ 的内存错误检测器。\n\n#### 主要检测什么问题？\n\nASan可以检测出程序中不合理的内存使用行为，主要包括以下行为：\n\n| **错误行为**              | **简介**                                                     |\n| ------------------------- | ------------------------------------------------------------ |\n| global buffer overflow    | 全局内存访问越界                                             |\n| heap buffer overflow      | 堆内存访问越界[github.com](https://github.com/google/sanitizers/wiki/AddressSanitizerExampleHeapOutOfBounds) |\n| initialization order bugs | 全局变量初始化顺序异常全局变量初始化间存在依赖，导致实际运行时因初始化顺序问题导致的初始值异常 |\n| memory leaks              | 内存泄漏在程序正常退出时输出报告                             |\n| stack buffer overflow     | 栈内存访问越界                                               |\n| use after free            | 访问已经释放的内存，在释放内存后仍然尝试访问此内存[AddressSanitizerExampleUseAfterFree · google/sanitizers Wiki](https://github.com/google/sanitizers/wiki/AddressSanitizerExampleUseAfterFree) |\n| use after return          | 访问生命周期结束的对象在函数退出后尝试访问函数内声明的局部变量 |\n| user after scope          | 访问生命周期结束的对象在\"{}\"包起来的代码块外访问代码块内声明的局部变量 |\n\n### Valgrind\n\n#### 什么是 Valgrind（重点是 Memcheck）？\n\nValgrind 是一个用于构建动态分析工具的插桩框架。Valgrind 中的一些工具可以自动检测许多内存管理和线程错误，并详细分析您的程序。还可以使用 Valgrind 构建新的工具。\n\nValgrind 发行版目前包含七个生产级工具：一个内存错误检测器、两个线程错误检测器、一个缓存和分支预测分析器、一个调用图生成缓存和分支预测分析器，以及两个不同的堆分析器。其中最受欢迎的工具是 Memcheck。它可以检测 C 和 C++ 程序中常见的许多内存相关错误，这些错误可能导致程序崩溃和不可预测的行为。\n\n#### 主要检测什么问题？\n\n检测内存泄露，数组越界等一些程序中常见的错误。特别的，它的 memcheck 工具能够检测内存泄漏、未初始化内存的使用和非法的内存访问。\n\n## 二、原理机制\n\n### ASan工作机制\n\n详细的工作原理官方文档：https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm\n\n#### 工作原理\n\nGoogle ASan工具ASAN，全称 AddressSanitizer，也即地址消毒技术。可以用来检测内存问题，例如[缓冲区溢出](https://so.csdn.net/so/search?q=缓冲区溢出&spm=1001.2101.3001.7020)或对悬空指针的非法访问等。\nASan主要是进行[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)级别的HOOK与插桩,目前主流Clang，GCC，MSVC都支持，再结合运行时对影子内存的诊断输出，相当于双管齐下，整体效果不错；官方说是2倍左右性能开销，1/8的内存到2倍的开销。\n\nAddressSanitizer主要包括两部分：插桩(Instrumentation)和动态运行库(Run-time library)。插桩主要是针对在llvm编译器级别对访问内存的操作(store，load，alloca等)，将它们进行处理。动态运行库主要提供一些运行时的复杂的功能(比如poison/unpoison shadow memory)以及将malloc,free等系统调用函数hook住。\n\n##### 内存操作进行插桩\n\n对new,malloc,delete,free,memcpy,其它内存访问等操作进行编译时替换与代码插入，是编译器完成的；加了ASAN相关的编译选项后，代码中的每一次内存访问操作都会被编译器修改为如下方式：\n\n编译前:\n\n```c++\n*address = ...;    // or   ... = *address;\n```\n\n编译后：\n\n```c++\nif (IsPoisoned(address)) { // 判断内存是否中毒\n  ReportError(address, kAccessSize, kIsWrite);\n}\n*address = ...;  // or: ... = *address;\n```\n\n该方式的关键点就在于读写内存前会判断地址是否处于“中毒”状态，还有如何把`IsPoisoned`实现的非常快，把`ReportError`实现的非常紧凑，从而避免插入的代码过多。\n\neg：\n\n未插桩的代码：\n\n```c++\nvoid foo() {\n  char a[8];\n  ...\n  return;\n}\n```\n\n插桩后的代码：\n\n```c++\nvoid foo() {\n  char redzone1[32];  // 32-byte aligned\n  char a[8];          // 32-byte aligned\n  char redzone2[24]; \n  char redzone3[32];  // 32-byte aligned\n  int  *shadow_base = MemToShadow(redzone1);\n  shadow_base[0] = 0xffffffff;  // poison redzone1\n  shadow_base[1] = 0xffffff00;  // poison redzone2, unpoison 'a'\n  shadow_base[2] = 0xffffffff;  // poison redzone3\n  ...\n  shadow_base[0] = shadow_base[1] = shadow_base[2] = 0; // unpoison all\n  return;\n}\n```\n\n##### 内存映射与诊断\n\n按照一定的算法对原始内存进行一分影子内存的拷贝生成，目前不是1：1的拷贝，而是巧妙的按1/8大小进行处理，并进行一定的下毒与标记，减少内存的浪费。正常访问内存前，先对影子内存进行检查访问，如果发现数据不对，就进行诊断报错处理。\n\n运行时库（libasan.so）malloc/free函数进行了替换，在malloc函数中额外的分配了Redzone区域的内存，将与Redzone区域对应的影子内存加锁，主要的内存区域对应的影子内存不加锁。redzone 被标记为中毒状态，free函数将所有分配的内存区域加锁，并放到了隔离区域的队列中(保证在一定的时间内不会再被malloc函数分配)，并被标记为中毒状态。\n\n![mapping图片](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250514220252808.png)\n\n##### 防护缓冲区溢出的基本步骤\n\n中毒状态：内存对应的 shadow 区标记该内存不能访问的状态\n\n```mermaid\nflowchart TD\n    A[创建 redzone<br>在全局变量、堆、栈前后插入<br>并标记为中毒状态] --> B[建立影子内存区<br>8 字节内存对应 1 字节影子]\n    B --> C[访问 redzone（如读写）<br>对应影子内存为中毒状态<br>触发报错]\n    C --> D[报错信息：进程号、错误类型、<br>源文件名、行号、函数调用关系、<br>影子内存状态（出错部分中括号标注）]\n```\n\n\n\n##### 内存泄漏检测原理\n\n\n\n```mermaid\nflowchart TD\n    A[\"ASAN 接管内存申请接口<br>(用户使用的内存全部由 ASAN 管理)\"] --> B[\"进程退出时触发 ASAN 内存泄漏检测<br>(可通过复位、重启等方式触发)\"]\n    B --> C[遍历所有未释放堆内存]\n    C --> D{该内存是否仍被引用？}\n    D -- 是 --> F[跳过，未泄漏]\n    D -- 否 --> E[认定为内存泄漏<br>输出内存大小与申请调用栈]\nclassDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n#### 源码路径\n\n| 路径                                                       | 文件/模块                       | 作用                                   |\n| ---------------------------------------------------------- | ------------------------------- | -------------------------------------- |\n| `asan_rtl.cpp`                                             | 运行时库入口（RunTime Library） | 初始化 ASan、设置 hook、启动检测等     |\n| `asan_interceptors.cpp`                                    | 标准函数拦截器                  | 重写 `memcpy`、`malloc`、`free` 等函数 |\n| `asan_report.cpp`                                          | 报告错误栈信息                  | 打印报错信息、栈追踪、源码位置等       |\n| `asan_mapping.h`                                           | Shadow memory 映射逻辑          | 1:8 映射关系，关键 shadow 计算         |\n| `asan_allocator.cpp`                                       | 自定义内存分配器                | 包含红区、对齐等安全逻辑               |\n| `asan_poisoning.cpp`                                       | 中毒/恢复接口                   | 调用 poison/unpoison 改变内存状态      |\n| `asan_thread.cpp`                                          | 线程管理                        | TLS、线程栈信息维护等                  |\n| `llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp` | 插桩入口                        | 插入对 `shadow memory` 的访问检查代码  |\n\n#### 源码分析\n\n运行时库入口：\n\n```mermaid\ngraph TD\n  A[\"compiler-rt/lib/asan/asan_rtl.cpp/__asan_init()\"] --> B[\"asan_activation.cpp/AsanActivate()激活Asan\"]\n  A --> C[\"AsanInitFromRtl()\"]\n  C --> D[\"AsanInitInternal()\"]\n  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n```c++\nstatic bool AsanInitInternal() {\n    ……\n    // 设置内存毒化和分配上下文大小\n    SetCanPoisonMemory(flags()->poison_heap);\n  \tSetMallocContextSize(common_flags()->malloc_context_size);\n    ……\n    // 初始化拦截器\n    InitializeAsanInterceptors();\n    ……\n    // 初始化影子内存\n    InitializeShadowMemory();\n    ……\n    // 初始化分配器\n    AllocatorOptions allocator_options;\n  \tallocator_options.SetFrom(flags(), common_flags());\n    InitializeAllocator(allocator_options);\n    ……\n    // 创建主线程，初始化反编辑器\n    AsanThread *main_thread = CreateMainThread();\n  \tCHECK_EQ(0, main_thread->tid());\n    force_interface_symbols();  // no-op.\n    SanitizerInitializeUnwinder();\n    ……\n}\n```\n\n`asan_mapping.h` 查看 shadow memory 的映射计算公式：\n\n```c++\n#define ASAN_SHADOW_SCALE 3\n……\n#    define MEM_TO_SHADOW(mem) \\\n      (((mem) >> ASAN_SHADOW_SCALE) + (ASAN_SHADOW_OFFSET))\n#    define SHADOW_TO_MEM(mem) \\\n      (((mem) - (ASAN_SHADOW_OFFSET)) << (ASAN_SHADOW_SCALE))\n```\n\n\n\n### Valgrind工作机制\n\n#### 工作原理\n\nValgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。最直观的表达就是：`Valgrind内核 + 工具插件 = Valgrind工具`。在Valgrind框架下编写一个二进制程序动态分析工具比从零开始简很多，因为Valgrind内核为新工具的编写提供了许多通用的工具集，比如错误记录、动态插桩等。\n\n当Valgrind工具程序启动时：\n\n1. 将需要分析的程序加载与工具程序同一个进程空间中；\n2. 使用`JIT（just-in-time）`的动态二进制重编译技术，将代码分成一个个小的代码块实施重编译；\n3. 在重编译过程中，**Valgrind内核会将相应代码块的机器码转化成中间表示**，插件会在中间代码中进行相应分析代码的**插桩**，最后通过内核把中间表示转换成原本的机器码，在目标机器上执行；**（源机器码 --> 插桩 --> 目标机器码）**\n4. Valgrind内核大部分时间花在上述机器码和中间表示的相互翻译执行中，**而原程序的所有机器码并没有执行，执行的都是插桩后的代码**\n\n所有的Valgrind工具都是使用**静态链接**的可执行文件，里面包含了Valgrind内核和工具插件。虽然这样会导致每个工具程序中都需要包含一份Valgrind内核，内核大概2.5MB左右，稍微浪费一些磁盘空间，但是静态链接可以使整个可执行文件加载到非标准的启动地址，方便把待分析程序加载进同一个进程空间中，然后使用Valgrind重编译技术将待分析程序机器码重编译到别的地址执行。\n\n##### 核心框架\n\nValgrind的体系结构如下图所示：\n\n![img](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509144807842.png)\n\n##### 工具启动\n\n```mermaid\ngraph TD\n    A[命令行运行 valgrind --tool=&lt;tool&gt;] --> B[valgrind 程序根据 tool 参数调用 execv]\n    B --> C[加载对应的 Valgrind 工具插件]\n    C --> D[Valgrind 内核初始化子系统<br>（地址空间管理器、内存分配器等）]\n    D --> E[映射目标程序的 .text/.data 段<br>配置堆栈等]\n    E --> F[初始化命令行参数<br>并加载工具插件]\n    F --> G[加载更多子系统：<br>翻译表、信号处理、调度器、调试信息等]\n    G --> H[准备完毕，开始执行目标程序第一条指令<br>进行 JIT 重编译（插桩）并运行]\n```\n\n##### 中间表示（VEX）\n\n在Valgrind的重编译的过程中，使用的中间表示是一种平台无关的语言——VEX，通过屏蔽硬件平台的差异性，节省了大量针对不同平台的插桩代码。\n\n- Statement（结构体`IRStmt`）表示有副作用的操作，如写寄存器、写内存、临时变量赋值等。其中，Statement由Expression组成。\n\n- Expression (结构体`IRExpr`) 表示没有副作用的操作，如读内存、做算术运算等，这些操作可以包含子表达式和表达式树。\n\n- 在Valgrind中，代码被分解成多个小的代码块，每个代码块里包含VEX的Statement列表。每个代码块的结构体是`IRSB`，`IRSB`是单入口多出口的，代码如下所示：\n\n  ```c++\n  typedef\n     struct {\n        IRTypeEnv* tyenv; // 表明IRSB中每个临时变量的类型\n        IRStmt**   stmts; // VEX语句列表\n        Int        stmts_size; // Statements总长度\n        Int        stmts_used; // 实际上使用的Statements的数目\n        IRExpr*    next; // 下一跳的位置\n        IRJumpKind jumpkind; // 最后代码块结束jump的类型\n        Int        offsIP; // IP寄存器的偏移\n     }\n     IRSB;\n  ```\n\n- Valgrind根据一定规则将代码划分为很多小代码块后，会进行以下八个阶段，将插件的分析代码进行插桩并优化：\n\n  ```mermaid\n  graph TD\n      A[反汇编：机器码] --> B[树状中间表示]\n      B --> C[扁平中间表示]\n      C --> D[带桩的扁平中间表示]:::important\n      D --> E[优化的扁平中间表示]\n      E --> F[汇编：带桩的树状中间表示]:::important\n      F --> G[目标汇编代码]\n      G --> H[寄存器优化的目标汇编代码]\n      H --> I[机器码]\n   classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n  ```\n\n- JIT执行：\n\n  ```mermaid\n  flowchart TD\n      A[插桩后的机器码生成] --> B[保存到固定大小的哈希表<br>（线性探测，80%阈值）]:::important\n      B --> C{哈希表是否达到80%容量？}\n      C -- 是 --> D[FIFO策略<br>丢弃1/8最旧的代码块]\n      C -- 否 --> E[继续执行]\n      E --> F[代码块执行完毕]\n      D --> F\n      F --> G[进入dispatcher（汇编实现）]\n      G --> H{dispatcher快速缓存命中？}\n      H -- 是 --> I[切换到下一个代码块（快速跳转）]\n      H -- 否 --> J[进入scheduler（C实现）]\n      J --> K{哈希表中存在目标代码块？}\n      K -- 是 --> L[更新dispatcher缓存<br>并跳转]\n      K -- 否 --> M[重新插桩编译<br>加入哈希表并更新dispatcher缓存]\n      M --> L\n   classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n  ```\n\n##### Memcheck 检测原理\n\n**Memcheck**检测内存问题的原理如下图所示：\n\n![内存检查原理](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509150159067.jpeg)\n\nMemcheck 能够检测出内存问题，关键在于其建立了两个全局表。\n\n- Valid-Value 表：对于进程的整个地址空间中的每一个字节(byte)，都有与之对应的 8 个 bits；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。\n- Valid-Address 表：对于进程整个地址空间中的每一个字节(byte)，还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。\n\n![memcheck影子内存](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509171919962.png)\n\n**检测原理**：\n\n- 当要读写内存中某个字节时，首先检查这个字节对应的 A bit。如果该A bit显示该位置是无效位置，memcheck 则报告读写错误。\n- 内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 memcheck 会检查对应的V bits，如果该值尚未初始化，则会报告使用未初始化内存错误。\n\n##### Valgrind回调Memcheck\n\n```c++\nstatic void mc_pre_clo_init( void );\nstatic void mc_post_clo_init ( void );\nIRSB* MC_(instrument) ( VgCallbackClosure* closure,\n                        IRSB* sb_in,\n                        const VexGuestLayout* layout,\n                        const VexGuestExtents* vge,\n                        const VexArchInfo* archinfo_host,\n                        IRType gWordTy, IRType hWordTy );\nstatic void mc_fini ( Int exitcode );\n```\n\n上述四个接口，由Valgrind在不同阶段调用。其中，`mc_pre_clo_init` 和 `mc_post_clo_init`用于初始化memcheck插件，`MC_(instrument)` 是在scheduler需要translate的插桩阶段会调用。\n\n```c++\n   VG_(track_new_mem_startup)     ( mc_new_mem_startup );\n   VG_(track_new_mem_mmap)        ( mc_new_mem_mmap );\n   VG_(track_change_mem_mprotect) ( mc_new_mem_mprotect );\n   VG_(track_copy_mem_remap)      ( MC_(copy_address_range_state) );\n   VG_(track_die_mem_stack_signal)( MC_(make_mem_noaccess) );\n   VG_(track_die_mem_brk)         ( MC_(make_mem_noaccess) );\n   VG_(track_die_mem_munmap)      ( MC_(make_mem_noaccess) );\n...\n   VG_(track_die_mem_stack)       ( mc_die_mem_stack     );\n   VG_(track_ban_mem_stack)       ( MC_(make_mem_noaccess) );\n   VG_(track_pre_mem_read)        ( check_mem_is_defined );\n   VG_(track_pre_mem_read_asciiz) ( check_mem_is_defined_asciiz );\n   VG_(track_pre_mem_write)       ( check_mem_is_addressable );\n   VG_(track_post_mem_write)      ( mc_post_mem_write );\n   VG_(track_post_reg_write)                  ( mc_post_reg_write );\n   VG_(track_post_reg_write_clientcall_return)( mc_post_reg_write_clientcall );\n```\n\n上述这些 `VG_(track_*)` 函数是用于向Valgrind内核注册相应的事件监控，这些事件难以通过插桩来拦截的，如堆块的分配、堆栈指针的修改、信号处理等。当注册的事件发生时，Valgrind内核会调用Memcheck注册的函数。\n\n#### 工具包\n\n##### Memcheck※\n\nMemcheck检测内存管理问题，主要针对C和C++程序。当一个程序在Memcheck的监督下运行时，所有对内存的读取和写入都会被检查，并拦截对malloc/new/free/delete的调用。因此，Memcheck可以检测您的程序是否：\n\n- 访问不应该访问的内存（尚未分配的区域、已释放的区域、超过堆块末尾的区域、堆栈中不可访问的区域）。\n- 以危险的方式使用未初始化的值。\n- 内存泄漏。\n- 对堆块执行错误的释放（双重释放、不匹配的释放）。\n- 将重叠的源内存块和目标内存块传递给memcpy()和相关函数。\n\nMemcheck会在这些错误发生时立即报告，给出发生错误的源行号，以及为到达该行而调用的函数的堆栈跟踪。Memcheck在字节级别跟踪可寻址性，在位级别跟踪值的初始化。因此，它可以检测单个未初始化位的使用，并且不会报告位字段操作中的虚假错误。Memcheck运行的程序比正常速度慢10-30倍。\n\n##### Cachegrind\n\nCachegrind是一个缓存探查器。它对CPU中的I1、D1和L2缓存执行详细的模拟，因此可以准确地确定代码中缓存未命中的来源。它通过每个函数、每个模块和整个程序摘要来识别每行源代码的缓存未命中、内存引用和执行的指令的数量。它适用于用任何语言编写的程序。Cachegrind运行的程序比正常速度慢20-100倍。\n\n##### Callgrind\n\nJosef Weidendorfer的Callgrind是对Cachegrind的扩展。它提供了Cachegrind所做的所有信息，以及关于调用图的额外信息。它在3.2.0版本中被集成到Valgrind的主版本中。单独提供的是一个令人惊叹的可视化工具[KCachegrind](https://kcachegrind.sourceforge.net/html/Home.html)，它可以更好地概述Callgrind收集的数据；它还可以用于可视化Cachegrind的输出。\n\n##### Massif\n\nMassif是一个堆探查器。它通过获取程序堆的定期快照来执行详细的堆评测。它生成一个图表，显示堆使用情况随时间的变化，包括程序中哪些部分负责最多内存分配的信息。该图由一个文本或HTML文件补充，该文件包括更多信息，用于确定在哪里分配了最多的内存。Massif运行程序的速度比正常速度慢20倍。\n\n##### Helgrind\n\nHelgrind是一个线程调试器，用于在多线程程序中查找数据竞赛。它查找由多个（POSIX p-）线程访问的内存位置，但找不到一致使用的（pthread_mutex_）锁。这样的位置指示线程之间缺少同步，并且可能导致难以找到与定时相关的问题。它对任何使用pthreads的程序都很有用。这是一个有点实验性的工具，所以这里特别欢迎您的反馈。\n\n##### DRD\n\nDRD是一种用于检测多线程C和C++程序中错误的工具。该工具适用于任何使用POSIX线程原语或使用在POSIX线程基元之上构建的线程概念的程序。虽然Helgrind可以检测到违反锁定顺序的情况，但对于大多数程序来说，DRD执行其分析所需的内存较少。\n\n##### Lackey，Nulgrind\n\nLackey和Nulgrind也包括在Valgrind分布中。它们做的不多，只是为了测试和演示。\n\n##### DHAT\n\nDHAT是一个用于检查程序如何使用堆分配的工具。它跟踪分配的块，并检查每次内存访问，以找到要访问的块（如果有的话）。它还附带了一个GUI，以便于探索配置文件结果\n\n#### 源码路径\n\n| 步骤                      | 入口源码                                         | 阅读重点                                                     |\n| ------------------------- | ------------------------------------------------ | ------------------------------------------------------------ |\n| 1️⃣ 启动流程                | `coregrind/m_main.c` 中的 `main()` 函数          | Valgrind 启动逻辑、注册工具、加载用户程序                    |\n| 2️⃣ 工具注册                | `memcheck/mc_main.c` 中的 `mc_pre_clo_init()`    | Memcheck 是如何作为插件注册并接管分析任务的                  |\n| 3️⃣ 插桩入口                | `memcheck/mc_translate.c` 中的 `MC_(instrument)` | 如何在 VEX IR 上插入 shadow memory 逻辑来检测读写            |\n| 4️⃣ shadow memory 实现      | `memcheck/mc_machine.c`、`mc_memory.c`           | 如何为用户空间内存建立 shadow 映射<br>如何检查是否初始化、是否重叠写入等 |\n| 5️⃣ 报错逻辑                | `memcheck/mc_errors.c`                           | 各类内存错误的触发条件、错误消息打印函数                     |\n| 6️⃣ VEX IR 转换（了解即可） | `VEX/pub/libvex.h`、`coregrind/m_translate.c`    | 了解如何将指令翻译成 IR 并应用插件逻辑                       |\n\n#### 源码分析\n\n##### 启动流程\n\n```mermaid\ngraph TD\n  A[\"coregrind/m_main.c/valgrind_main()\"] --> B[\"启动调试信息\"]\n  A --> C[\"启动地址空间管理器\"]\n  A --> D[\"启动动态内存管理器\"]\n  B --> E[\"识别cpu类型\"]\n  C --> E\n  D --> E\n  E --> F[\"识别工具类型\"]\n  F --> G[\"设置默认的 vex 控制参数\"]\n  G --> H[\"初始化工具tl_pre_clo_init()/tool_post_clo_init()\"]:::important\n  H --> J[\"初始化调度器\"]\n  J --> K[\"设置一些堆栈状态，运行\"]\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n##### 工具注册（以memcheck为例）\n\n```mermaid\ngraph TD\n  A[\"memcheck/mc_main.c/mc_pre_clo_init()\"] --> B[\"VG_(basic_tool_funcs)\"]\n  B --> C[\"插桩入口MC_(instrument)\"]:::important\n  A --> D[\"VG_(needs_tool_errors)\"]\n  D --> E[\"报错逻辑入口MC_(eq_Error)\"]\n  A --> F[\"初始化shadow映射init_shadow_memory()\"]\n  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n```c++\n// mermaid --启动调试信息\n// memcheck/mc_main.c\nstatic void mc_pre_clo_init(void)\n{\n   ……\n   // 注册工具，插桩入口\n   VG_(basic_tool_funcs)          (mc_post_clo_init,\n                                   MC_(instrument),\n                                   mc_fini);\n   ……\n   // 报错逻辑入口\n   VG_(needs_tool_errors)         (MC_(eq_Error),\n                                   MC_(before_pp_Error),\n                                   MC_(pp_Error),\n                                   True,/*show TIDs for errors*/\n                                   MC_(update_Error_extra),\n                                   MC_(is_recognised_suppression),\n                                   MC_(read_extra_suppression_info),\n                                   MC_(error_matches_suppression),\n                                   MC_(get_error_name),\n                                   MC_(get_extra_suppression_info),\n                                   MC_(print_extra_suppression_use),\n                                   MC_(update_extra_suppression_use));\n   ……\n   // shadow映射\n   init_shadow_memory();\n   ……\n}\n```\n\n### 实现的不同之处\n\n|              | AddressSanitizer (ASan)                                  | Valgrind                                             |\n| ------------ | -------------------------------------------------------- | ---------------------------------------------------- |\n| 实现方式     | 编译期插桩（基于 Clang/LLVM 插入检查代码）               | 动态二进制插桩（运行时在二进制层面插桩）             |\n| 插桩时机     | 编译时                                                   | 运行时                                               |\n| 插桩方式     | 修改 LLVM IR，插入 shadow memory 检查逻辑                | 使用 JIT 模拟器重写程序指令                          |\n| 内存状态追踪 | 使用 Shadow Memory，通常 1:8 映射                        | 通过完整模拟 CPU 访问并维护虚拟内存状态              |\n| 运行时依赖   | 编译后程序链接 runtime 库（compiler-rt）                 | 不修改原程序，Valgrind 作为宿主启动目标程序          |\n| 性能开销     | 较低（~2x）                                              | 较高（10x-50x）                                      |\n| 可移植性     | 与编译器强绑定（Clang）                                  | 与平台强绑定（对 x86/x86_64 支持好）                 |\n| 检测能力     | 精度高但主要针对 Heap/Stack/Global 的越界/Use-After-Free | 检测更全面，包含内存泄漏、未初始化变量、未定义行为等 |\n| 可扩展性     | 可通过编译器 Pass 扩展                                   | 可通过开发工具插件（如 Helgrind, DRD）扩展           |\n\n## 三、安装与使用方式\n\n### ASan 使用\n\n#### 安装Asan\n\n在 Ubuntu 上，**ASan (AddressSanitizer)** **不需要单独安装**，因为它是 **GCC** 或 **Clang** 编译器自带的功能模块。你只需要确保你的 **GCC** 或 **Clang** 版本支持 ASan（一般 Ubuntu 18.04+ 默认都支持）。\n\n#### 使用Asan\n\n1. 使用要求：编译时加上 `-fsanitize=address -g`（`-fsanitize=address`：启用 AddressSanitizer，`-g`：生成调试符号，方便错误定位到具体源码行号）\n\n   ```bash\n   # eg\n   g++ -fsanitize=address -g your_code.cpp -o your_program\n   # -fno-omit-frame-pointer 让栈追溯信息更加友好\n   ```\n\n2. 编译后直接运行，出现非法内存访问、溢出、use-after-free 等时，ASan 会自动终止程序并输出详细错误栈信息。\n\n   ```bash\n   ./your_program\n   ```\n\n3. 进阶配置：可以通过环境变量控制 ASan 行为：\n\n   - 显示更多详细信息：\n\n     ```bash\n     export ASAN_OPTIONS=verbosity=1\n     ```\n\n   - 打印出泄漏检测（需要加 `-fsanitize=leak`）：\n\n     ```bash\n     export ASAN_OPTIONS=detect_leaks=1\n     ```\n\n     ```bash\n     # eg：\n     export ASAN_OPTIONS=detect_leaks=1:abort_on_error=1\n     ./your_program\n     ```\n\n     | **flag**                      | **含义**                                                     |\n     | ----------------------------- | ------------------------------------------------------------ |\n     | halt_on_error                 | 默认为1，ASan检测到错误后会中止程序设为0后，ASan检测到错误后不会中止程序 |\n     | log_path                      | 设置错误信息的输出路径                                       |\n     | detect_stack_use_after_return | 是否检测use after return错误默认为0，即关闭该检测功能        |\n     | help=1                        | 输出所有支持的参数                                           |\n\n- 编译加上 `-fsanitize=address -g`\n\n  \n\n更多ASAN_OPTIONS可以参考：https://github.com/google/sanitizers/wiki/AddressSanitizerFlags\n\n### Valgrind 使用\n\n#### 安装 Valgrind\n\n```sh\nsudo apt install valgrind \n```\n\n![image-20250426221902277](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426221902305.png)\n\n#### 使用valgrind\n\n1. 使用要求：编译程序时使用调试信息选项 -g（使用编译程序以-g包含调试信息，以便 Memcheck 的错误消息包含准确的行号。-O0如果您可以忍受速度变慢，使用也是一个好主意。 -O1错误消息中的行号可能不准确，但通常情况下，在编译的代码上运行 Memcheck-O1效果很好，而且与直接运行相比，速度提升-O0非常显著。 -O2不建议使用及以上版本，因为 Memcheck 偶尔会报告实际上并不存在未初始化值的错误）。\n2. 使用方法：使用 valgrind 运行程序：valgrind --leak-check=full ./your_program\n3. 常用选项：\n   - --leak-check=full：启用详细的内存泄漏检测。\n   - --track-origins=yes：在内存未初始化时，报告其来源。\n   - --log-file=filename：将 Valgrind 的输出写入文件 filename\n\n## 四、检测能力比较\n\n| 比较项         | ASan                            | Valgrind                          |\n| -------------- | ------------------------------- | --------------------------------- |\n| 检测内存越界   | ✅ 高效准确                      | ✅ 高效准确                        |\n| 检测内存泄漏   | ✅（可选配 LeakSanitizer）       | ✅（默认内置）                     |\n| 检测未初始化读 | ❌（需要另加 MSan）              | ✅                                 |\n| 检测堆栈溢出   | ✅（有限支持）                   | ✅（通过 Memcheck 支持）           |\n| 检测速度       | 🔥 极快（通常 2x-3x 原程序速度） | 🐢 较慢（通常 10x-50x 原程序速度） |\n| 支持大程序     | ✅ 支持大内存程序                | ❌ 容易内存爆掉                    |\n| 平台支持       | Linux、macOS、Windows (部分)    | Linux、macOS（Windows 支持差）    |\n\n## 五、输出示例与解读\n\n### ASan 错误输出示例\n\n#### 验证代码\n\n```c++\nint main(int argc, char **argv) {\n  int *array = new int[100];\n  delete [] array;\n  return array[argc];  // BOOM\n}\n// RUN: clang -O -g -fsanitize=address %t && ./a.out\n```\n\n#### 验证结果\n\n```c++\n=================================================================\n==6254== ERROR: AddressSanitizer: heap-use-after-free on address 0x603e0001fc64 at pc 0x417f6a bp 0x7fff626b3250 sp 0x7fff626b3248\nREAD of size 4 at 0x603e0001fc64 thread T0\n    #0 0x417f69 in main example_UseAfterFree.cc:5\n    #1 0x7fae62b5076c (/lib/x86_64-linux-gnu/libc.so.6+0x2176c)\n    #2 0x417e54 (a.out+0x417e54)\n0x603e0001fc64 is located 4 bytes inside of 400-byte region [0x603e0001fc60,0x603e0001fdf0)\nfreed by thread T0 here:\n    #0 0x40d4d2 in operator delete[](void*) /home/kcc/llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:61\n    #1 0x417f2e in main example_UseAfterFree.cc:4\npreviously allocated by thread T0 here:\n    #0 0x40d312 in operator new[](unsigned long) /home/kcc/llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:46\n    #1 0x417f1e in main example_UseAfterFree.cc:3\nShadow bytes around the buggy address:\n  0x1c07c0003f30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x1c07c0003f40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x1c07c0003f50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x1c07c0003f60: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x1c07c0003f70: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n=>0x1c07c0003f80: fa fa fa fa fa fa fa fa fa fa fa fa[fd]fd fd fd\n  0x1c07c0003f90: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x1c07c0003fa0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd\n  0x1c07c0003fb0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fa fa\n  0x1c07c0003fc0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x1c07c0003fd0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:     fa\n  Heap righ redzone:     fb\n  Freed Heap region:     fd\n  Stack left redzone:    f1\n  Stack mid redzone:     f2\n  Stack right redzone:   f3\n  Stack partial redzone: f4\n  Stack after return:    f5\n  Stack use after scope: f8\n  Global redzone:        f9\n  Global init order:     f6\n  Poisoned by user:      f7\n  ASan internal:         fe\n==6254== ABORTING\n```\n\n#### 结果分析\n\n```sh\n1. 错误类型摘要\n    # ASan 检测到错误类型是 heap-use-after-free，表示访问了已经释放的堆内存。\n    ==6254== ERROR: AddressSanitizer: heap-use-after-free on address 0x603e0001fc64\n\n2. 出错位置\n    # 错误发生在 example_UseAfterFree.cc 文件的第5行 main 函数中。\n    # 出错时正在读取（READ）4字节的数据。\n    READ of size 4 at 0x603e0001fc64 thread T0\n      #0 0x417f69 in main example_UseAfterFree.cc:5\n      #1 0x7fae62b5076c (/lib/x86_64-linux-gnu/libc.so.6+0x2176c)\n      #2 0x417e54 (a.out+0x417e54)\n\n3. 内存分配与释放信息\n    # 这块内存是在 example_UseAfterFree.cc 文件第3行通过 new[] 分配的。\n    previously allocated by thread T0 here:\n      #0 0x40d312 in operator new[](unsigned long)\n      #1 0x417f1e in main example_UseAfterFree.cc:3\n\n    # 这块内存已经在第4行通过 delete[] 被释放。\n    freed by thread T0 here:\n      #0 0x40d4d2 in operator delete[](void*)\n      #1 0x417f2e in main example_UseAfterFree.cc:4\n\n4. Shadow Memory 状态\n    # 出错地址周围的 Shadow Memory 信息如下：\n    Shadow bytes around the buggy address:\n      0x1c07c0003f80: fa fa fa fa fa fa fa fa fa fa fa fa [fd]fd fd fd\n    # 其中 fd 表示 \"Freed Heap Region\"，即已经释放的堆内存。\n    # 说明正在访问一块已经释放的堆区域，因此发生了 heap-use-after-free 错误。\n\n5. Shadow Byte Legend\n    # Shadow Byte 各个标记含义：\n    - 00: 正常可访问内存\n    - fd: 已释放的堆内存（Freed Heap region）\n    - fa: 堆红区（Heap redzone，用于保护越界）\n```\n\n更多例子在：https://github.com/google/sanitizers/wiki/addresssanitizer的introduction部分\n\n### Valgrind 输出示例\n\n#### 验证代码\n\n```c++\n#include <iostream>\nvoid func(){\n    int* p = new int(10); // 只申请不回收，leak\n}\nint main(){\n\n    func();\n    return 0;\n}\n// sh命令\ng++ test.cpp -g\nvalgrind --leak-check=full ./a.out\n```\n\n#### 验证结果\n\n```sh\n[root:~/stutest]# valgrind --leak-check=full ./a.out \n==1536437== Memcheck, a memory error detector\n==1536437== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.\n==1536437== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info\n==1536437== Command: ./a.out\n==1536437== \n==1536437== \n==1536437== HEAP SUMMARY: # 堆摘要\n==1536437==     in use at exit: 4 bytes in 1 blocks\n==1536437==   total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated\n==1536437== \n==1536437== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1\n==1536437==    at 0x48657B8: operator new(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)\n==1536437==    by 0x1088E3: func() (test.cpp:4)\n==1536437==    by 0x108907: main (test.cpp:9)\n==1536437== \n==1536437== LEAK SUMMARY: # 泄露摘要\n==1536437==    definitely lost: 4 bytes in 1 blocks\n==1536437==    indirectly lost: 0 bytes in 0 blocks\n==1536437==      possibly lost: 0 bytes in 0 blocks\n==1536437==    still reachable: 0 bytes in 0 blocks\n==1536437==         suppressed: 0 bytes in 0 blocks\n==1536437== \n==1536437== For lists of detected and suppressed errors, rerun with: -s\n==1536437== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n```\n\n#### 结果分析\n\n```sh\n1. 堆摘要：\n\t# 在程序结束时，有 4 字节的内存仍然在使用，这意味着有一块 4 字节的内存没有被释放。\n    in use at exit: 4 bytes in 1 blocks\n    # 程序总共进行了 2 次内存分配操作（allocs），但是只进行了 1 次内存释放操作（frees），总共分配了 72,708 字节的内存。\n    total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated\n2. 泄漏摘要\n\t# Valgrind 确认有 4 字节内存泄漏，这次泄漏的详细信息如下：\n\t4 bytes in 1 blocks are definitely lost in loss record 1 of 1\n\t# 内存是在调用 operator new 时分配的，这通常表示你使用了 new 操作符分配了内存。\n\tat 0x486578B: operator new(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)\n\t# func() 函数中进行了内存分配，这是导致内存泄漏的地方。\n\tby 0x1088E3: func() (test.cpp:4)\n\t# main 函数调用了 func()，导致了内存泄漏。\n\tby 0x108907: main (test.cpp:9)\n3. 错误摘要\n\t# 总共检测到 1 个内存泄漏错误，且没有任何错误被抑制。\n    ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n```\n\n### 常见内存泄漏的场景\n\n```c++\n#include <iostream>\n#include <cstring>\n\nvoid memoryLeak1() {\n    // 简单的内存泄漏，没有释放分配的内存\n    int* leakyArray = new int[100];\n    // 忘记释放 leakyArray\n}\n\nvoid memoryLeak2() {\n    // 动态分配的内存覆盖了原先分配的内存，导致原内存泄漏\n    char* leakyString = new char[25];\n    strcpy(leakyString, \"Initial allocation\");\n    \n    // 重新分配，原内存未释放\n    leakyString = new char[50];\n    strcpy(leakyString, \"Reallocation causes leak\");\n\n    delete[] leakyString; // 释放第二次分配的内存\n}\n\nvoid memoryLeak3() {\n    // 部分内存泄漏，未释放结构体中的某些成员\n    struct Node {\n        int* value;\n        Node* next;\n    };\n\n    Node* node = new Node;\n    node->value = new int(10);\n    node->next = nullptr;\n\n    delete node; // 只释放了 node，没有释放 node->value\n}\n\nvoid memoryLeak4() {\n    // 使用未初始化的指针\n    int* uninitializedPtr;\n    *uninitializedPtr = 42; // 未定义行为\n}\n\nint main() {\n    memoryLeak1();\n    memoryLeak2();\n    memoryLeak3();\n    memoryLeak4();\n\n    std::cout << \"Done testing memory leaks!\" << std::endl;\n    return 0;\n}\n```\n\n## 六、常见问题与坑\n\n### **ASan 常见问题**\n\n- 与某些库冲突（如 glibc 的 hook）\n- 需要匹配 libc 版本\n- asan版本程序在Linux环境下运行时会额外申请20TB的虚拟内存，会增加大量的虚拟内存使用\n  - 需要确保/proc/sys/vm/overcommit_memory的值不为2\n  - 这也可以作为检验ASan是否工作的标志\n- asan工具不是万能的，必须要跑到有问题的代码才可以暴露出来\n\n### **Valgrind 常见问题**\n\n- 运行特别慢\n- 不支持 AVX-512、SIMD 优化程序\n- 对于一些静态分配或在堆栈上分配的数组的超出范围的读取或写入，Valgrind 可能无法检测到\n- 在检测某些复杂的内存错误场景时，可能会出现误报或漏报的情况\n\n## 七、实战应用场景建议\n\n### 什么时候优先用 ASan？\n\n- 开发阶段，快速找到内存错误\n- 代码量很大的时候用Asan\n\n### 什么时候优先用 Valgrind？\n\n- 找难以发现的泄漏和未初始化读问题，做深入分析\n\n| 场景/目标                             | 适用工具                        | 原因说明                                                    |\n| ------------------------------------- | ------------------------------- | ----------------------------------------------------------- |\n| 1. 内存越界访问检测                   | ✅ ASan & ✅ Valgrind             | 两者均可，但 ASan 检测更快且栈信息更清晰                    |\n| 2. Use-After-Free 检测                | ✅ ASan & ✅ Valgrind             | 都能检测，但 ASan 执行效率更高                              |\n| 3. 内存泄漏检测                       | ✅ Valgrind（Memcheck）          | ASan 对泄漏检测不如 Valgrind 精细（除非搭配 LeakSanitizer） |\n| 4. 未初始化内存使用检测               | ✅ Valgrind                      | ASan 无法检测未初始化使用，Valgrind 的 Undef-Value 检测更强 |\n| 5. 并发线程数据竞争检测               | 🔶 DRD/Helgrind（Valgrind 插件） | ASan 无法检测数据竞争，需用 TSan；Valgrind 插件较弱         |\n| 6. 性能要求较高的场合                 | ✅ ASan                          | Valgrind 开销大，ASan 更适合实战部署前测试                  |\n| 7. 快速集成进 CI/CD                   | ✅ ASan                          | 编译期工具更易于集成测试流程                                |\n| 8. 无法重编译的三方库检测             | ✅ Valgrind                      | ASan 需重新编译，Valgrind 可直接运行已有二进制              |\n| 9. 动态分析研究/教学                  | ✅ Valgrind                      | 更直观、可观测性强、控制粒度高                              |\n| 10. 大型 C++ 项目（如游戏、系统工具） | ✅ ASan                          | 开销小，误报少，更适合持续集成测试                          |\n\n## 八、总结\n\n- 两者优缺点汇总\n- 推荐搭配使用的方法（如开发中用 ASan，发布前用 Valgrind 细扫）\n\n学习资料\n\n- https://valgrind.org/\n- https://hardcore.feishu.cn/docx/doxcnXfsINxeICDFXePBelN3p5f\n\n","slug":"ASAN、valgrind（内存泄露的检测工具）","published":1,"updated":"2025-09-17T11:44:03.061Z","comments":1,"layout":"post","photos":[],"_id":"cmfnx0xvs0001bsvp8vojdnhu","content":"<h1 id=\"ASAN、valgrind（内存泄露的检测工具）\"><a href=\"#ASAN、valgrind（内存泄露的检测工具）\" class=\"headerlink\" title=\"ASAN、valgrind（内存泄露的检测工具）\"></a>ASAN、valgrind（内存泄露的检测工具）</h1><h2 id=\"一、工具概览\"><a href=\"#一、工具概览\" class=\"headerlink\" title=\"一、工具概览\"></a>一、工具概览</h2><h3 id=\"ASan\"><a href=\"#ASan\" class=\"headerlink\" title=\"ASan\"></a>ASan</h3><h4 id=\"什么是-AddressSanitizer？\"><a href=\"#什么是-AddressSanitizer？\" class=\"headerlink\" title=\"什么是 AddressSanitizer？\"></a>什么是 AddressSanitizer？</h4><p><a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizer\">AddressSanitizer</a>（又名 ASan）是一款适用于 C&#x2F;C++ 的内存错误检测器。</p>\n<h4 id=\"主要检测什么问题？\"><a href=\"#主要检测什么问题？\" class=\"headerlink\" title=\"主要检测什么问题？\"></a>主要检测什么问题？</h4><p>ASan可以检测出程序中不合理的内存使用行为，主要包括以下行为：</p>\n<table>\n<thead>\n<tr>\n<th><strong>错误行为</strong></th>\n<th><strong>简介</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>global buffer overflow</td>\n<td>全局内存访问越界</td>\n</tr>\n<tr>\n<td>heap buffer overflow</td>\n<td>堆内存访问越界<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerExampleHeapOutOfBounds\">github.com</a></td>\n</tr>\n<tr>\n<td>initialization order bugs</td>\n<td>全局变量初始化顺序异常全局变量初始化间存在依赖，导致实际运行时因初始化顺序问题导致的初始值异常</td>\n</tr>\n<tr>\n<td>memory leaks</td>\n<td>内存泄漏在程序正常退出时输出报告</td>\n</tr>\n<tr>\n<td>stack buffer overflow</td>\n<td>栈内存访问越界</td>\n</tr>\n<tr>\n<td>use after free</td>\n<td>访问已经释放的内存，在释放内存后仍然尝试访问此内存<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerExampleUseAfterFree\">AddressSanitizerExampleUseAfterFree · google&#x2F;sanitizers Wiki</a></td>\n</tr>\n<tr>\n<td>use after return</td>\n<td>访问生命周期结束的对象在函数退出后尝试访问函数内声明的局部变量</td>\n</tr>\n<tr>\n<td>user after scope</td>\n<td>访问生命周期结束的对象在”{}”包起来的代码块外访问代码块内声明的局部变量</td>\n</tr>\n</tbody></table>\n<h3 id=\"Valgrind\"><a href=\"#Valgrind\" class=\"headerlink\" title=\"Valgrind\"></a>Valgrind</h3><h4 id=\"什么是-Valgrind（重点是-Memcheck）？\"><a href=\"#什么是-Valgrind（重点是-Memcheck）？\" class=\"headerlink\" title=\"什么是 Valgrind（重点是 Memcheck）？\"></a>什么是 Valgrind（重点是 Memcheck）？</h4><p>Valgrind 是一个用于构建动态分析工具的插桩框架。Valgrind 中的一些工具可以自动检测许多内存管理和线程错误，并详细分析您的程序。还可以使用 Valgrind 构建新的工具。</p>\n<p>Valgrind 发行版目前包含七个生产级工具：一个内存错误检测器、两个线程错误检测器、一个缓存和分支预测分析器、一个调用图生成缓存和分支预测分析器，以及两个不同的堆分析器。其中最受欢迎的工具是 Memcheck。它可以检测 C 和 C++ 程序中常见的许多内存相关错误，这些错误可能导致程序崩溃和不可预测的行为。</p>\n<h4 id=\"主要检测什么问题？-1\"><a href=\"#主要检测什么问题？-1\" class=\"headerlink\" title=\"主要检测什么问题？\"></a>主要检测什么问题？</h4><p>检测内存泄露，数组越界等一些程序中常见的错误。特别的，它的 memcheck 工具能够检测内存泄漏、未初始化内存的使用和非法的内存访问。</p>\n<h2 id=\"二、原理机制\"><a href=\"#二、原理机制\" class=\"headerlink\" title=\"二、原理机制\"></a>二、原理机制</h2><h3 id=\"ASan工作机制\"><a href=\"#ASan工作机制\" class=\"headerlink\" title=\"ASan工作机制\"></a>ASan工作机制</h3><p>详细的工作原理官方文档：<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm\">https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm</a></p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>Google ASan工具ASAN，全称 AddressSanitizer，也即地址消毒技术。可以用来检测内存问题，例如<a href=\"https://so.csdn.net/so/search?q=%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA&spm=1001.2101.3001.7020\">缓冲区溢出</a>或对悬空指针的非法访问等。<br>ASan主要是进行<a href=\"https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020\">编译器</a>级别的HOOK与插桩,目前主流Clang，GCC，MSVC都支持，再结合运行时对影子内存的诊断输出，相当于双管齐下，整体效果不错；官方说是2倍左右性能开销，1&#x2F;8的内存到2倍的开销。</p>\n<p>AddressSanitizer主要包括两部分：插桩(Instrumentation)和动态运行库(Run-time library)。插桩主要是针对在llvm编译器级别对访问内存的操作(store，load，alloca等)，将它们进行处理。动态运行库主要提供一些运行时的复杂的功能(比如poison&#x2F;unpoison shadow memory)以及将malloc,free等系统调用函数hook住。</p>\n<h5 id=\"内存操作进行插桩\"><a href=\"#内存操作进行插桩\" class=\"headerlink\" title=\"内存操作进行插桩\"></a>内存操作进行插桩</h5><p>对new,malloc,delete,free,memcpy,其它内存访问等操作进行编译时替换与代码插入，是编译器完成的；加了ASAN相关的编译选项后，代码中的每一次内存访问操作都会被编译器修改为如下方式：</p>\n<p>编译前:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">*address = ...;    <span class=\"hljs-comment\">// or   ... = *address;</span><br></code></pre></td></tr></table></figure>\n\n<p>编译后：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">IsPoisoned</span>(address)) &#123; <span class=\"hljs-comment\">// 判断内存是否中毒</span><br>  <span class=\"hljs-built_in\">ReportError</span>(address, kAccessSize, kIsWrite);<br>&#125;<br>*address = ...;  <span class=\"hljs-comment\">// or: ... = *address;</span><br></code></pre></td></tr></table></figure>\n\n<p>该方式的关键点就在于读写内存前会判断地址是否处于“中毒”状态，还有如何把<code>IsPoisoned</code>实现的非常快，把<code>ReportError</code>实现的非常紧凑，从而避免插入的代码过多。</p>\n<p>eg：</p>\n<p>未插桩的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>&#123;<br>  <span class=\"hljs-type\">char</span> a[<span class=\"hljs-number\">8</span>];<br>  ...<br>  <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>插桩后的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>&#123;<br>  <span class=\"hljs-type\">char</span> redzone1[<span class=\"hljs-number\">32</span>];  <span class=\"hljs-comment\">// 32-byte aligned</span><br>  <span class=\"hljs-type\">char</span> a[<span class=\"hljs-number\">8</span>];          <span class=\"hljs-comment\">// 32-byte aligned</span><br>  <span class=\"hljs-type\">char</span> redzone2[<span class=\"hljs-number\">24</span>]; <br>  <span class=\"hljs-type\">char</span> redzone3[<span class=\"hljs-number\">32</span>];  <span class=\"hljs-comment\">// 32-byte aligned</span><br>  <span class=\"hljs-type\">int</span>  *shadow_base = <span class=\"hljs-built_in\">MemToShadow</span>(redzone1);<br>  shadow_base[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0xffffffff</span>;  <span class=\"hljs-comment\">// poison redzone1</span><br>  shadow_base[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0xffffff00</span>;  <span class=\"hljs-comment\">// poison redzone2, unpoison &#x27;a&#x27;</span><br>  shadow_base[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0xffffffff</span>;  <span class=\"hljs-comment\">// poison redzone3</span><br>  ...<br>  shadow_base[<span class=\"hljs-number\">0</span>] = shadow_base[<span class=\"hljs-number\">1</span>] = shadow_base[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// unpoison all</span><br>  <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"内存映射与诊断\"><a href=\"#内存映射与诊断\" class=\"headerlink\" title=\"内存映射与诊断\"></a>内存映射与诊断</h5><p>按照一定的算法对原始内存进行一分影子内存的拷贝生成，目前不是1：1的拷贝，而是巧妙的按1&#x2F;8大小进行处理，并进行一定的下毒与标记，减少内存的浪费。正常访问内存前，先对影子内存进行检查访问，如果发现数据不对，就进行诊断报错处理。</p>\n<p>运行时库（libasan.so）malloc&#x2F;free函数进行了替换，在malloc函数中额外的分配了Redzone区域的内存，将与Redzone区域对应的影子内存加锁，主要的内存区域对应的影子内存不加锁。redzone 被标记为中毒状态，free函数将所有分配的内存区域加锁，并放到了隔离区域的队列中(保证在一定的时间内不会再被malloc函数分配)，并被标记为中毒状态。</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250514220252808.png\" alt=\"mapping图片\"></p>\n<h5 id=\"防护缓冲区溢出的基本步骤\"><a href=\"#防护缓冲区溢出的基本步骤\" class=\"headerlink\" title=\"防护缓冲区溢出的基本步骤\"></a>防护缓冲区溢出的基本步骤</h5><p>中毒状态：内存对应的 shadow 区标记该内存不能访问的状态</p>\n<pre><code class=\" mermaid\">flowchart TD\n    A[创建 redzone&lt;br&gt;在全局变量、堆、栈前后插入&lt;br&gt;并标记为中毒状态] --&gt; B[建立影子内存区&lt;br&gt;8 字节内存对应 1 字节影子]\n    B --&gt; C[访问 redzone（如读写）&lt;br&gt;对应影子内存为中毒状态&lt;br&gt;触发报错]\n    C --&gt; D[报错信息：进程号、错误类型、&lt;br&gt;源文件名、行号、函数调用关系、&lt;br&gt;影子内存状态（出错部分中括号标注）]\n</code></pre>\n\n\n\n<h5 id=\"内存泄漏检测原理\"><a href=\"#内存泄漏检测原理\" class=\"headerlink\" title=\"内存泄漏检测原理\"></a>内存泄漏检测原理</h5><pre><code class=\" mermaid\">flowchart TD\n    A[&quot;ASAN 接管内存申请接口&lt;br&gt;(用户使用的内存全部由 ASAN 管理)&quot;] --&gt; B[&quot;进程退出时触发 ASAN 内存泄漏检测&lt;br&gt;(可通过复位、重启等方式触发)&quot;]\n    B --&gt; C[遍历所有未释放堆内存]\n    C --&gt; D&#123;该内存是否仍被引用？&#125;\n    D -- 是 --&gt; F[跳过，未泄漏]\n    D -- 否 --&gt; E[认定为内存泄漏&lt;br&gt;输出内存大小与申请调用栈]\nclassDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n</code></pre>\n\n<h4 id=\"源码路径\"><a href=\"#源码路径\" class=\"headerlink\" title=\"源码路径\"></a>源码路径</h4><table>\n<thead>\n<tr>\n<th>路径</th>\n<th>文件&#x2F;模块</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>asan_rtl.cpp</code></td>\n<td>运行时库入口（RunTime Library）</td>\n<td>初始化 ASan、设置 hook、启动检测等</td>\n</tr>\n<tr>\n<td><code>asan_interceptors.cpp</code></td>\n<td>标准函数拦截器</td>\n<td>重写 <code>memcpy</code>、<code>malloc</code>、<code>free</code> 等函数</td>\n</tr>\n<tr>\n<td><code>asan_report.cpp</code></td>\n<td>报告错误栈信息</td>\n<td>打印报错信息、栈追踪、源码位置等</td>\n</tr>\n<tr>\n<td><code>asan_mapping.h</code></td>\n<td>Shadow memory 映射逻辑</td>\n<td>1:8 映射关系，关键 shadow 计算</td>\n</tr>\n<tr>\n<td><code>asan_allocator.cpp</code></td>\n<td>自定义内存分配器</td>\n<td>包含红区、对齐等安全逻辑</td>\n</tr>\n<tr>\n<td><code>asan_poisoning.cpp</code></td>\n<td>中毒&#x2F;恢复接口</td>\n<td>调用 poison&#x2F;unpoison 改变内存状态</td>\n</tr>\n<tr>\n<td><code>asan_thread.cpp</code></td>\n<td>线程管理</td>\n<td>TLS、线程栈信息维护等</td>\n</tr>\n<tr>\n<td><code>llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp</code></td>\n<td>插桩入口</td>\n<td>插入对 <code>shadow memory</code> 的访问检查代码</td>\n</tr>\n</tbody></table>\n<h4 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h4><p>运行时库入口：</p>\n<pre><code class=\" mermaid\">graph TD\n  A[&quot;compiler-rt/lib/asan/asan_rtl.cpp/__asan_init()&quot;] --&gt; B[&quot;asan_activation.cpp/AsanActivate()激活Asan&quot;]\n  A --&gt; C[&quot;AsanInitFromRtl()&quot;]\n  C --&gt; D[&quot;AsanInitInternal()&quot;]\n  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n</code></pre>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">AsanInitInternal</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    ……<br>    <span class=\"hljs-comment\">// 设置内存毒化和分配上下文大小</span><br>    <span class=\"hljs-built_in\">SetCanPoisonMemory</span>(<span class=\"hljs-built_in\">flags</span>()-&gt;poison_heap);<br>  \t<span class=\"hljs-built_in\">SetMallocContextSize</span>(<span class=\"hljs-built_in\">common_flags</span>()-&gt;malloc_context_size);<br>    ……<br>    <span class=\"hljs-comment\">// 初始化拦截器</span><br>    <span class=\"hljs-built_in\">InitializeAsanInterceptors</span>();<br>    ……<br>    <span class=\"hljs-comment\">// 初始化影子内存</span><br>    <span class=\"hljs-built_in\">InitializeShadowMemory</span>();<br>    ……<br>    <span class=\"hljs-comment\">// 初始化分配器</span><br>    AllocatorOptions allocator_options;<br>  \tallocator_options.<span class=\"hljs-built_in\">SetFrom</span>(<span class=\"hljs-built_in\">flags</span>(), <span class=\"hljs-built_in\">common_flags</span>());<br>    <span class=\"hljs-built_in\">InitializeAllocator</span>(allocator_options);<br>    ……<br>    <span class=\"hljs-comment\">// 创建主线程，初始化反编辑器</span><br>    AsanThread *main_thread = <span class=\"hljs-built_in\">CreateMainThread</span>();<br>  \t<span class=\"hljs-built_in\">CHECK_EQ</span>(<span class=\"hljs-number\">0</span>, main_thread-&gt;<span class=\"hljs-built_in\">tid</span>());<br>    force_interface_symbols();  <span class=\"hljs-comment\">// no-op.</span><br>    <span class=\"hljs-built_in\">SanitizerInitializeUnwinder</span>();<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>asan_mapping.h</code> 查看 shadow memory 的映射计算公式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ASAN_SHADOW_SCALE 3</span><br>……<br><span class=\"hljs-meta\">#    <span class=\"hljs-keyword\">define</span> MEM_TO_SHADOW(mem) \\</span><br><span class=\"hljs-meta\">      (((mem) &gt;&gt; ASAN_SHADOW_SCALE) + (ASAN_SHADOW_OFFSET))</span><br><span class=\"hljs-meta\">#    <span class=\"hljs-keyword\">define</span> SHADOW_TO_MEM(mem) \\</span><br><span class=\"hljs-meta\">      (((mem) - (ASAN_SHADOW_OFFSET)) &lt;&lt; (ASAN_SHADOW_SCALE))</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Valgrind工作机制\"><a href=\"#Valgrind工作机制\" class=\"headerlink\" title=\"Valgrind工作机制\"></a>Valgrind工作机制</h3><h4 id=\"工作原理-1\"><a href=\"#工作原理-1\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。最直观的表达就是：<code>Valgrind内核 + 工具插件 = Valgrind工具</code>。在Valgrind框架下编写一个二进制程序动态分析工具比从零开始简很多，因为Valgrind内核为新工具的编写提供了许多通用的工具集，比如错误记录、动态插桩等。</p>\n<p>当Valgrind工具程序启动时：</p>\n<ol>\n<li>将需要分析的程序加载与工具程序同一个进程空间中；</li>\n<li>使用<code>JIT（just-in-time）</code>的动态二进制重编译技术，将代码分成一个个小的代码块实施重编译；</li>\n<li>在重编译过程中，<strong>Valgrind内核会将相应代码块的机器码转化成中间表示</strong>，插件会在中间代码中进行相应分析代码的<strong>插桩</strong>，最后通过内核把中间表示转换成原本的机器码，在目标机器上执行；<strong>（源机器码 –&gt; 插桩 –&gt; 目标机器码）</strong></li>\n<li>Valgrind内核大部分时间花在上述机器码和中间表示的相互翻译执行中，<strong>而原程序的所有机器码并没有执行，执行的都是插桩后的代码</strong></li>\n</ol>\n<p>所有的Valgrind工具都是使用<strong>静态链接</strong>的可执行文件，里面包含了Valgrind内核和工具插件。虽然这样会导致每个工具程序中都需要包含一份Valgrind内核，内核大概2.5MB左右，稍微浪费一些磁盘空间，但是静态链接可以使整个可执行文件加载到非标准的启动地址，方便把待分析程序加载进同一个进程空间中，然后使用Valgrind重编译技术将待分析程序机器码重编译到别的地址执行。</p>\n<h5 id=\"核心框架\"><a href=\"#核心框架\" class=\"headerlink\" title=\"核心框架\"></a>核心框架</h5><p>Valgrind的体系结构如下图所示：</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509144807842.png\" alt=\"img\"></p>\n<h5 id=\"工具启动\"><a href=\"#工具启动\" class=\"headerlink\" title=\"工具启动\"></a>工具启动</h5><pre><code class=\" mermaid\">graph TD\n    A[命令行运行 valgrind --tool=&amp;lt;tool&amp;gt;] --&gt; B[valgrind 程序根据 tool 参数调用 execv]\n    B --&gt; C[加载对应的 Valgrind 工具插件]\n    C --&gt; D[Valgrind 内核初始化子系统&lt;br&gt;（地址空间管理器、内存分配器等）]\n    D --&gt; E[映射目标程序的 .text/.data 段&lt;br&gt;配置堆栈等]\n    E --&gt; F[初始化命令行参数&lt;br&gt;并加载工具插件]\n    F --&gt; G[加载更多子系统：&lt;br&gt;翻译表、信号处理、调度器、调试信息等]\n    G --&gt; H[准备完毕，开始执行目标程序第一条指令&lt;br&gt;进行 JIT 重编译（插桩）并运行]\n</code></pre>\n\n<h5 id=\"中间表示（VEX）\"><a href=\"#中间表示（VEX）\" class=\"headerlink\" title=\"中间表示（VEX）\"></a>中间表示（VEX）</h5><p>在Valgrind的重编译的过程中，使用的中间表示是一种平台无关的语言——VEX，通过屏蔽硬件平台的差异性，节省了大量针对不同平台的插桩代码。</p>\n<ul>\n<li><p>Statement（结构体<code>IRStmt</code>）表示有副作用的操作，如写寄存器、写内存、临时变量赋值等。其中，Statement由Expression组成。</p>\n</li>\n<li><p>Expression (结构体<code>IRExpr</code>) 表示没有副作用的操作，如读内存、做算术运算等，这些操作可以包含子表达式和表达式树。</p>\n</li>\n<li><p>在Valgrind中，代码被分解成多个小的代码块，每个代码块里包含VEX的Statement列表。每个代码块的结构体是<code>IRSB</code>，<code>IRSB</code>是单入口多出口的，代码如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">typedef</span><br>   <span class=\"hljs-keyword\">struct</span> &#123;<br>      IRTypeEnv* tyenv; <span class=\"hljs-comment\">// 表明IRSB中每个临时变量的类型</span><br>      IRStmt**   stmts; <span class=\"hljs-comment\">// VEX语句列表</span><br>      Int        stmts_size; <span class=\"hljs-comment\">// Statements总长度</span><br>      Int        stmts_used; <span class=\"hljs-comment\">// 实际上使用的Statements的数目</span><br>      IRExpr*    next; <span class=\"hljs-comment\">// 下一跳的位置</span><br>      IRJumpKind jumpkind; <span class=\"hljs-comment\">// 最后代码块结束jump的类型</span><br>      Int        offsIP; <span class=\"hljs-comment\">// IP寄存器的偏移</span><br>   &#125;<br>   IRSB;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>Valgrind根据一定规则将代码划分为很多小代码块后，会进行以下八个阶段，将插件的分析代码进行插桩并优化：</p>\n<pre><code class=\" mermaid\">graph TD\n    A[反汇编：机器码] --&gt; B[树状中间表示]\n    B --&gt; C[扁平中间表示]\n    C --&gt; D[带桩的扁平中间表示]:::important\n    D --&gt; E[优化的扁平中间表示]\n    E --&gt; F[汇编：带桩的树状中间表示]:::important\n    F --&gt; G[目标汇编代码]\n    G --&gt; H[寄存器优化的目标汇编代码]\n    H --&gt; I[机器码]\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n</code></pre>\n</li>\n<li><p>JIT执行：</p>\n<pre><code class=\" mermaid\">flowchart TD\n    A[插桩后的机器码生成] --&gt; B[保存到固定大小的哈希表&lt;br&gt;（线性探测，80%阈值）]:::important\n    B --&gt; C&#123;哈希表是否达到80%容量？&#125;\n    C -- 是 --&gt; D[FIFO策略&lt;br&gt;丢弃1/8最旧的代码块]\n    C -- 否 --&gt; E[继续执行]\n    E --&gt; F[代码块执行完毕]\n    D --&gt; F\n    F --&gt; G[进入dispatcher（汇编实现）]\n    G --&gt; H&#123;dispatcher快速缓存命中？&#125;\n    H -- 是 --&gt; I[切换到下一个代码块（快速跳转）]\n    H -- 否 --&gt; J[进入scheduler（C实现）]\n    J --&gt; K&#123;哈希表中存在目标代码块？&#125;\n    K -- 是 --&gt; L[更新dispatcher缓存&lt;br&gt;并跳转]\n    K -- 否 --&gt; M[重新插桩编译&lt;br&gt;加入哈希表并更新dispatcher缓存]\n    M --&gt; L\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n</code></pre></li>\n</ul>\n<h5 id=\"Memcheck-检测原理\"><a href=\"#Memcheck-检测原理\" class=\"headerlink\" title=\"Memcheck 检测原理\"></a>Memcheck 检测原理</h5><p><strong>Memcheck</strong>检测内存问题的原理如下图所示：</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509150159067.jpeg\" alt=\"内存检查原理\"></p>\n<p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表。</p>\n<ul>\n<li>Valid-Value 表：对于进程的整个地址空间中的每一个字节(byte)，都有与之对应的 8 个 bits；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li>\n<li>Valid-Address 表：对于进程整个地址空间中的每一个字节(byte)，还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li>\n</ul>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509171919962.png\" alt=\"memcheck影子内存\"></p>\n<p><strong>检测原理</strong>：</p>\n<ul>\n<li>当要读写内存中某个字节时，首先检查这个字节对应的 A bit。如果该A bit显示该位置是无效位置，memcheck 则报告读写错误。</li>\n<li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 memcheck 会检查对应的V bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</li>\n</ul>\n<h5 id=\"Valgrind回调Memcheck\"><a href=\"#Valgrind回调Memcheck\" class=\"headerlink\" title=\"Valgrind回调Memcheck\"></a>Valgrind回调Memcheck</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mc_pre_clo_init</span><span class=\"hljs-params\">( <span class=\"hljs-type\">void</span> )</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mc_post_clo_init</span> <span class=\"hljs-params\">( <span class=\"hljs-type\">void</span> )</span></span>;<br><span class=\"hljs-function\">IRSB* <span class=\"hljs-title\">MC_</span><span class=\"hljs-params\">(instrument)</span> <span class=\"hljs-params\">( VgCallbackClosure* closure,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                        IRSB* sb_in,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                        <span class=\"hljs-type\">const</span> VexGuestLayout* layout,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                        <span class=\"hljs-type\">const</span> VexGuestExtents* vge,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                        <span class=\"hljs-type\">const</span> VexArchInfo* archinfo_host,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                        IRType gWordTy, IRType hWordTy )</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mc_fini</span> <span class=\"hljs-params\">( Int exitcode )</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>上述四个接口，由Valgrind在不同阶段调用。其中，<code>mc_pre_clo_init</code> 和 <code>mc_post_clo_init</code>用于初始化memcheck插件，<code>MC_(instrument)</code> 是在scheduler需要translate的插桩阶段会调用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">   <span class=\"hljs-built_in\">VG_</span>(track_new_mem_startup)     ( mc_new_mem_startup );<br>   <span class=\"hljs-built_in\">VG_</span>(track_new_mem_mmap)        ( mc_new_mem_mmap );<br>   <span class=\"hljs-built_in\">VG_</span>(track_change_mem_mprotect) ( mc_new_mem_mprotect );<br>   <span class=\"hljs-built_in\">VG_</span>(track_copy_mem_remap)      ( <span class=\"hljs-built_in\">MC_</span>(copy_address_range_state) );<br>   <span class=\"hljs-built_in\">VG_</span>(track_die_mem_stack_signal)( <span class=\"hljs-built_in\">MC_</span>(make_mem_noaccess) );<br>   <span class=\"hljs-built_in\">VG_</span>(track_die_mem_brk)         ( <span class=\"hljs-built_in\">MC_</span>(make_mem_noaccess) );<br>   <span class=\"hljs-built_in\">VG_</span>(track_die_mem_munmap)      ( <span class=\"hljs-built_in\">MC_</span>(make_mem_noaccess) );<br>...<br>   <span class=\"hljs-built_in\">VG_</span>(track_die_mem_stack)       ( mc_die_mem_stack     );<br>   <span class=\"hljs-built_in\">VG_</span>(track_ban_mem_stack)       ( <span class=\"hljs-built_in\">MC_</span>(make_mem_noaccess) );<br>   <span class=\"hljs-built_in\">VG_</span>(track_pre_mem_read)        ( check_mem_is_defined );<br>   <span class=\"hljs-built_in\">VG_</span>(track_pre_mem_read_asciiz) ( check_mem_is_defined_asciiz );<br>   <span class=\"hljs-built_in\">VG_</span>(track_pre_mem_write)       ( check_mem_is_addressable );<br>   <span class=\"hljs-built_in\">VG_</span>(track_post_mem_write)      ( mc_post_mem_write );<br>   <span class=\"hljs-built_in\">VG_</span>(track_post_reg_write)                  ( mc_post_reg_write );<br>   <span class=\"hljs-built_in\">VG_</span>(track_post_reg_write_clientcall_return)( mc_post_reg_write_clientcall );<br></code></pre></td></tr></table></figure>\n\n<p>上述这些 <code>VG_(track_*)</code> 函数是用于向Valgrind内核注册相应的事件监控，这些事件难以通过插桩来拦截的，如堆块的分配、堆栈指针的修改、信号处理等。当注册的事件发生时，Valgrind内核会调用Memcheck注册的函数。</p>\n<h4 id=\"工具包\"><a href=\"#工具包\" class=\"headerlink\" title=\"工具包\"></a>工具包</h4><h5 id=\"Memcheck※\"><a href=\"#Memcheck※\" class=\"headerlink\" title=\"Memcheck※\"></a>Memcheck※</h5><p>Memcheck检测内存管理问题，主要针对C和C++程序。当一个程序在Memcheck的监督下运行时，所有对内存的读取和写入都会被检查，并拦截对malloc&#x2F;new&#x2F;free&#x2F;delete的调用。因此，Memcheck可以检测您的程序是否：</p>\n<ul>\n<li>访问不应该访问的内存（尚未分配的区域、已释放的区域、超过堆块末尾的区域、堆栈中不可访问的区域）。</li>\n<li>以危险的方式使用未初始化的值。</li>\n<li>内存泄漏。</li>\n<li>对堆块执行错误的释放（双重释放、不匹配的释放）。</li>\n<li>将重叠的源内存块和目标内存块传递给memcpy()和相关函数。</li>\n</ul>\n<p>Memcheck会在这些错误发生时立即报告，给出发生错误的源行号，以及为到达该行而调用的函数的堆栈跟踪。Memcheck在字节级别跟踪可寻址性，在位级别跟踪值的初始化。因此，它可以检测单个未初始化位的使用，并且不会报告位字段操作中的虚假错误。Memcheck运行的程序比正常速度慢10-30倍。</p>\n<h5 id=\"Cachegrind\"><a href=\"#Cachegrind\" class=\"headerlink\" title=\"Cachegrind\"></a>Cachegrind</h5><p>Cachegrind是一个缓存探查器。它对CPU中的I1、D1和L2缓存执行详细的模拟，因此可以准确地确定代码中缓存未命中的来源。它通过每个函数、每个模块和整个程序摘要来识别每行源代码的缓存未命中、内存引用和执行的指令的数量。它适用于用任何语言编写的程序。Cachegrind运行的程序比正常速度慢20-100倍。</p>\n<h5 id=\"Callgrind\"><a href=\"#Callgrind\" class=\"headerlink\" title=\"Callgrind\"></a>Callgrind</h5><p>Josef Weidendorfer的Callgrind是对Cachegrind的扩展。它提供了Cachegrind所做的所有信息，以及关于调用图的额外信息。它在3.2.0版本中被集成到Valgrind的主版本中。单独提供的是一个令人惊叹的可视化工具<a href=\"https://kcachegrind.sourceforge.net/html/Home.html\">KCachegrind</a>，它可以更好地概述Callgrind收集的数据；它还可以用于可视化Cachegrind的输出。</p>\n<h5 id=\"Massif\"><a href=\"#Massif\" class=\"headerlink\" title=\"Massif\"></a>Massif</h5><p>Massif是一个堆探查器。它通过获取程序堆的定期快照来执行详细的堆评测。它生成一个图表，显示堆使用情况随时间的变化，包括程序中哪些部分负责最多内存分配的信息。该图由一个文本或HTML文件补充，该文件包括更多信息，用于确定在哪里分配了最多的内存。Massif运行程序的速度比正常速度慢20倍。</p>\n<h5 id=\"Helgrind\"><a href=\"#Helgrind\" class=\"headerlink\" title=\"Helgrind\"></a>Helgrind</h5><p>Helgrind是一个线程调试器，用于在多线程程序中查找数据竞赛。它查找由多个（POSIX p-）线程访问的内存位置，但找不到一致使用的（pthread_mutex_）锁。这样的位置指示线程之间缺少同步，并且可能导致难以找到与定时相关的问题。它对任何使用pthreads的程序都很有用。这是一个有点实验性的工具，所以这里特别欢迎您的反馈。</p>\n<h5 id=\"DRD\"><a href=\"#DRD\" class=\"headerlink\" title=\"DRD\"></a>DRD</h5><p>DRD是一种用于检测多线程C和C++程序中错误的工具。该工具适用于任何使用POSIX线程原语或使用在POSIX线程基元之上构建的线程概念的程序。虽然Helgrind可以检测到违反锁定顺序的情况，但对于大多数程序来说，DRD执行其分析所需的内存较少。</p>\n<h5 id=\"Lackey，Nulgrind\"><a href=\"#Lackey，Nulgrind\" class=\"headerlink\" title=\"Lackey，Nulgrind\"></a>Lackey，Nulgrind</h5><p>Lackey和Nulgrind也包括在Valgrind分布中。它们做的不多，只是为了测试和演示。</p>\n<h5 id=\"DHAT\"><a href=\"#DHAT\" class=\"headerlink\" title=\"DHAT\"></a>DHAT</h5><p>DHAT是一个用于检查程序如何使用堆分配的工具。它跟踪分配的块，并检查每次内存访问，以找到要访问的块（如果有的话）。它还附带了一个GUI，以便于探索配置文件结果</p>\n<h4 id=\"源码路径-1\"><a href=\"#源码路径-1\" class=\"headerlink\" title=\"源码路径\"></a>源码路径</h4><table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>入口源码</th>\n<th>阅读重点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1️⃣ 启动流程</td>\n<td><code>coregrind/m_main.c</code> 中的 <code>main()</code> 函数</td>\n<td>Valgrind 启动逻辑、注册工具、加载用户程序</td>\n</tr>\n<tr>\n<td>2️⃣ 工具注册</td>\n<td><code>memcheck/mc_main.c</code> 中的 <code>mc_pre_clo_init()</code></td>\n<td>Memcheck 是如何作为插件注册并接管分析任务的</td>\n</tr>\n<tr>\n<td>3️⃣ 插桩入口</td>\n<td><code>memcheck/mc_translate.c</code> 中的 <code>MC_(instrument)</code></td>\n<td>如何在 VEX IR 上插入 shadow memory 逻辑来检测读写</td>\n</tr>\n<tr>\n<td>4️⃣ shadow memory 实现</td>\n<td><code>memcheck/mc_machine.c</code>、<code>mc_memory.c</code></td>\n<td>如何为用户空间内存建立 shadow 映射<br>如何检查是否初始化、是否重叠写入等</td>\n</tr>\n<tr>\n<td>5️⃣ 报错逻辑</td>\n<td><code>memcheck/mc_errors.c</code></td>\n<td>各类内存错误的触发条件、错误消息打印函数</td>\n</tr>\n<tr>\n<td>6️⃣ VEX IR 转换（了解即可）</td>\n<td><code>VEX/pub/libvex.h</code>、<code>coregrind/m_translate.c</code></td>\n<td>了解如何将指令翻译成 IR 并应用插件逻辑</td>\n</tr>\n</tbody></table>\n<h4 id=\"源码分析-1\"><a href=\"#源码分析-1\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h4><h5 id=\"启动流程\"><a href=\"#启动流程\" class=\"headerlink\" title=\"启动流程\"></a>启动流程</h5><pre><code class=\" mermaid\">graph TD\n  A[&quot;coregrind/m_main.c/valgrind_main()&quot;] --&gt; B[&quot;启动调试信息&quot;]\n  A --&gt; C[&quot;启动地址空间管理器&quot;]\n  A --&gt; D[&quot;启动动态内存管理器&quot;]\n  B --&gt; E[&quot;识别cpu类型&quot;]\n  C --&gt; E\n  D --&gt; E\n  E --&gt; F[&quot;识别工具类型&quot;]\n  F --&gt; G[&quot;设置默认的 vex 控制参数&quot;]\n  G --&gt; H[&quot;初始化工具tl_pre_clo_init()/tool_post_clo_init()&quot;]:::important\n  H --&gt; J[&quot;初始化调度器&quot;]\n  J --&gt; K[&quot;设置一些堆栈状态，运行&quot;]\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n</code></pre>\n\n<h5 id=\"工具注册（以memcheck为例）\"><a href=\"#工具注册（以memcheck为例）\" class=\"headerlink\" title=\"工具注册（以memcheck为例）\"></a>工具注册（以memcheck为例）</h5><pre><code class=\" mermaid\">graph TD\n  A[&quot;memcheck/mc_main.c/mc_pre_clo_init()&quot;] --&gt; B[&quot;VG_(basic_tool_funcs)&quot;]\n  B --&gt; C[&quot;插桩入口MC_(instrument)&quot;]:::important\n  A --&gt; D[&quot;VG_(needs_tool_errors)&quot;]\n  D --&gt; E[&quot;报错逻辑入口MC_(eq_Error)&quot;]\n  A --&gt; F[&quot;初始化shadow映射init_shadow_memory()&quot;]\n  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n</code></pre>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// mermaid --启动调试信息</span><br><span class=\"hljs-comment\">// memcheck/mc_main.c</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mc_pre_clo_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>   ……<br>   <span class=\"hljs-comment\">// 注册工具，插桩入口</span><br>   <span class=\"hljs-built_in\">VG_</span>(basic_tool_funcs)          (mc_post_clo_init,<br>                                   <span class=\"hljs-built_in\">MC_</span>(instrument),<br>                                   mc_fini);<br>   ……<br>   <span class=\"hljs-comment\">// 报错逻辑入口</span><br>   <span class=\"hljs-built_in\">VG_</span>(needs_tool_errors)         (<span class=\"hljs-built_in\">MC_</span>(eq_Error),<br>                                   <span class=\"hljs-built_in\">MC_</span>(before_pp_Error),<br>                                   <span class=\"hljs-built_in\">MC_</span>(pp_Error),<br>                                   True,<span class=\"hljs-comment\">/*show TIDs for errors*/</span><br>                                   <span class=\"hljs-built_in\">MC_</span>(update_Error_extra),<br>                                   <span class=\"hljs-built_in\">MC_</span>(is_recognised_suppression),<br>                                   <span class=\"hljs-built_in\">MC_</span>(read_extra_suppression_info),<br>                                   <span class=\"hljs-built_in\">MC_</span>(error_matches_suppression),<br>                                   <span class=\"hljs-built_in\">MC_</span>(get_error_name),<br>                                   <span class=\"hljs-built_in\">MC_</span>(get_extra_suppression_info),<br>                                   <span class=\"hljs-built_in\">MC_</span>(print_extra_suppression_use),<br>                                   <span class=\"hljs-built_in\">MC_</span>(update_extra_suppression_use));<br>   ……<br>   <span class=\"hljs-comment\">// shadow映射</span><br>   <span class=\"hljs-built_in\">init_shadow_memory</span>();<br>   ……<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"实现的不同之处\"><a href=\"#实现的不同之处\" class=\"headerlink\" title=\"实现的不同之处\"></a>实现的不同之处</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>AddressSanitizer (ASan)</th>\n<th>Valgrind</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>实现方式</td>\n<td>编译期插桩（基于 Clang&#x2F;LLVM 插入检查代码）</td>\n<td>动态二进制插桩（运行时在二进制层面插桩）</td>\n</tr>\n<tr>\n<td>插桩时机</td>\n<td>编译时</td>\n<td>运行时</td>\n</tr>\n<tr>\n<td>插桩方式</td>\n<td>修改 LLVM IR，插入 shadow memory 检查逻辑</td>\n<td>使用 JIT 模拟器重写程序指令</td>\n</tr>\n<tr>\n<td>内存状态追踪</td>\n<td>使用 Shadow Memory，通常 1:8 映射</td>\n<td>通过完整模拟 CPU 访问并维护虚拟内存状态</td>\n</tr>\n<tr>\n<td>运行时依赖</td>\n<td>编译后程序链接 runtime 库（compiler-rt）</td>\n<td>不修改原程序，Valgrind 作为宿主启动目标程序</td>\n</tr>\n<tr>\n<td>性能开销</td>\n<td>较低（~2x）</td>\n<td>较高（10x-50x）</td>\n</tr>\n<tr>\n<td>可移植性</td>\n<td>与编译器强绑定（Clang）</td>\n<td>与平台强绑定（对 x86&#x2F;x86_64 支持好）</td>\n</tr>\n<tr>\n<td>检测能力</td>\n<td>精度高但主要针对 Heap&#x2F;Stack&#x2F;Global 的越界&#x2F;Use-After-Free</td>\n<td>检测更全面，包含内存泄漏、未初始化变量、未定义行为等</td>\n</tr>\n<tr>\n<td>可扩展性</td>\n<td>可通过编译器 Pass 扩展</td>\n<td>可通过开发工具插件（如 Helgrind, DRD）扩展</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、安装与使用方式\"><a href=\"#三、安装与使用方式\" class=\"headerlink\" title=\"三、安装与使用方式\"></a>三、安装与使用方式</h2><h3 id=\"ASan-使用\"><a href=\"#ASan-使用\" class=\"headerlink\" title=\"ASan 使用\"></a>ASan 使用</h3><h4 id=\"安装Asan\"><a href=\"#安装Asan\" class=\"headerlink\" title=\"安装Asan\"></a>安装Asan</h4><p>在 Ubuntu 上，<strong>ASan (AddressSanitizer)</strong> <strong>不需要单独安装</strong>，因为它是 <strong>GCC</strong> 或 <strong>Clang</strong> 编译器自带的功能模块。你只需要确保你的 <strong>GCC</strong> 或 <strong>Clang</strong> 版本支持 ASan（一般 Ubuntu 18.04+ 默认都支持）。</p>\n<h4 id=\"使用Asan\"><a href=\"#使用Asan\" class=\"headerlink\" title=\"使用Asan\"></a>使用Asan</h4><ol>\n<li><p>使用要求：编译时加上 <code>-fsanitize=address -g</code>（<code>-fsanitize=address</code>：启用 AddressSanitizer，<code>-g</code>：生成调试符号，方便错误定位到具体源码行号）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># eg</span><br>g++ -fsanitize=address -g your_code.cpp -o your_program<br><span class=\"hljs-comment\"># -fno-omit-frame-pointer 让栈追溯信息更加友好</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>编译后直接运行，出现非法内存访问、溢出、use-after-free 等时，ASan 会自动终止程序并输出详细错误栈信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">./your_program<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>进阶配置：可以通过环境变量控制 ASan 行为：</p>\n<ul>\n<li><p>显示更多详细信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> ASAN_OPTIONS=verbosity=1<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>打印出泄漏检测（需要加 <code>-fsanitize=leak</code>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> ASAN_OPTIONS=detect_leaks=1<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># eg：</span><br><span class=\"hljs-built_in\">export</span> ASAN_OPTIONS=detect_leaks=1:abort_on_error=1<br>./your_program<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>flag</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>halt_on_error</td>\n<td>默认为1，ASan检测到错误后会中止程序设为0后，ASan检测到错误后不会中止程序</td>\n</tr>\n<tr>\n<td>log_path</td>\n<td>设置错误信息的输出路径</td>\n</tr>\n<tr>\n<td>detect_stack_use_after_return</td>\n<td>是否检测use after return错误默认为0，即关闭该检测功能</td>\n</tr>\n<tr>\n<td>help&#x3D;1</td>\n<td>输出所有支持的参数</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>编译加上 <code>-fsanitize=address -g</code></li>\n</ul>\n<p>更多ASAN_OPTIONS可以参考：<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerFlags\">https://github.com/google/sanitizers/wiki/AddressSanitizerFlags</a></p>\n<h3 id=\"Valgrind-使用\"><a href=\"#Valgrind-使用\" class=\"headerlink\" title=\"Valgrind 使用\"></a>Valgrind 使用</h3><h4 id=\"安装-Valgrind\"><a href=\"#安装-Valgrind\" class=\"headerlink\" title=\"安装 Valgrind\"></a>安装 Valgrind</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">sudo</span> apt install valgrind <br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426221902305.png\" alt=\"image-20250426221902277\"></p>\n<h4 id=\"使用valgrind\"><a href=\"#使用valgrind\" class=\"headerlink\" title=\"使用valgrind\"></a>使用valgrind</h4><ol>\n<li>使用要求：编译程序时使用调试信息选项 -g（使用编译程序以-g包含调试信息，以便 Memcheck 的错误消息包含准确的行号。-O0如果您可以忍受速度变慢，使用也是一个好主意。 -O1错误消息中的行号可能不准确，但通常情况下，在编译的代码上运行 Memcheck-O1效果很好，而且与直接运行相比，速度提升-O0非常显著。 -O2不建议使用及以上版本，因为 Memcheck 偶尔会报告实际上并不存在未初始化值的错误）。</li>\n<li>使用方法：使用 valgrind 运行程序：valgrind –leak-check&#x3D;full .&#x2F;your_program</li>\n<li>常用选项：<ul>\n<li>–leak-check&#x3D;full：启用详细的内存泄漏检测。</li>\n<li>–track-origins&#x3D;yes：在内存未初始化时，报告其来源。</li>\n<li>–log-file&#x3D;filename：将 Valgrind 的输出写入文件 filename</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四、检测能力比较\"><a href=\"#四、检测能力比较\" class=\"headerlink\" title=\"四、检测能力比较\"></a>四、检测能力比较</h2><table>\n<thead>\n<tr>\n<th>比较项</th>\n<th>ASan</th>\n<th>Valgrind</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>检测内存越界</td>\n<td>✅ 高效准确</td>\n<td>✅ 高效准确</td>\n</tr>\n<tr>\n<td>检测内存泄漏</td>\n<td>✅（可选配 LeakSanitizer）</td>\n<td>✅（默认内置）</td>\n</tr>\n<tr>\n<td>检测未初始化读</td>\n<td>❌（需要另加 MSan）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>检测堆栈溢出</td>\n<td>✅（有限支持）</td>\n<td>✅（通过 Memcheck 支持）</td>\n</tr>\n<tr>\n<td>检测速度</td>\n<td>🔥 极快（通常 2x-3x 原程序速度）</td>\n<td>🐢 较慢（通常 10x-50x 原程序速度）</td>\n</tr>\n<tr>\n<td>支持大程序</td>\n<td>✅ 支持大内存程序</td>\n<td>❌ 容易内存爆掉</td>\n</tr>\n<tr>\n<td>平台支持</td>\n<td>Linux、macOS、Windows (部分)</td>\n<td>Linux、macOS（Windows 支持差）</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、输出示例与解读\"><a href=\"#五、输出示例与解读\" class=\"headerlink\" title=\"五、输出示例与解读\"></a>五、输出示例与解读</h2><h3 id=\"ASan-错误输出示例\"><a href=\"#ASan-错误输出示例\" class=\"headerlink\" title=\"ASan 错误输出示例\"></a>ASan 错误输出示例</h3><h4 id=\"验证代码\"><a href=\"#验证代码\" class=\"headerlink\" title=\"验证代码\"></a>验证代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> </span>&#123;<br>  <span class=\"hljs-type\">int</span> *array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[<span class=\"hljs-number\">100</span>];<br>  <span class=\"hljs-keyword\">delete</span> [] array;<br>  <span class=\"hljs-keyword\">return</span> array[argc];  <span class=\"hljs-comment\">// BOOM</span><br>&#125;<br><span class=\"hljs-comment\">// RUN: clang -O -g -fsanitize=address %t &amp;&amp; ./a.out</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"验证结果\"><a href=\"#验证结果\" class=\"headerlink\" title=\"验证结果\"></a>验证结果</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">=================================================================<br>==<span class=\"hljs-number\">6254</span>== ERROR: AddressSanitizer: heap-use-after-free on address <span class=\"hljs-number\">0x603e0001fc64</span> at pc <span class=\"hljs-number\">0x417f6a</span> bp <span class=\"hljs-number\">0x7fff626b3250</span> sp <span class=\"hljs-number\">0x7fff626b3248</span><br>READ of size <span class=\"hljs-number\">4</span> at <span class=\"hljs-number\">0x603e0001fc64</span> thread T0<br>    #<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0x417f69</span> in main example_UseAfterFree.cc:<span class=\"hljs-number\">5</span><br>    #<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0x7fae62b5076c</span> (/lib/x86_64-linux-gnu/libc.so<span class=\"hljs-number\">.6</span><span class=\"hljs-number\">+0x2176c</span>)<br>    #<span class=\"hljs-number\">2</span> <span class=\"hljs-number\">0x417e54</span> (a.out<span class=\"hljs-number\">+0x417e54</span>)<br><span class=\"hljs-number\">0x603e0001fc64</span> is located <span class=\"hljs-number\">4</span> bytes inside of <span class=\"hljs-number\">400</span>-byte region [<span class=\"hljs-number\">0x603e0001fc60</span>,<span class=\"hljs-number\">0x603e0001fdf0</span>)<br>freed by thread T0 here:<br>    #<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0x40d4d2</span> in <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">delete</span>[](<span class=\"hljs-type\">void</span>*) /home/kcc/llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:<span class=\"hljs-number\">61</span><br>    #<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0x417f2e</span> in main example_UseAfterFree.cc:<span class=\"hljs-number\">4</span><br>previously allocated by thread T0 here:<br>    #<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0x40d312</span> in <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">new</span>[](<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span>) /home/kcc/llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:<span class=\"hljs-number\">46</span><br>    #<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0x417f1e</span> in main example_UseAfterFree.cc:<span class=\"hljs-number\">3</span><br>Shadow bytes around the buggy address:<br>  <span class=\"hljs-number\">0x1c07c0003f30</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class=\"hljs-number\">0x1c07c0003f40</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class=\"hljs-number\">0x1c07c0003f50</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class=\"hljs-number\">0x1c07c0003f60</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class=\"hljs-number\">0x1c07c0003f70</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>=&gt;<span class=\"hljs-number\">0x1c07c0003f80</span>: fa fa fa fa fa fa fa fa fa fa fa fa[fd]fd fd fd<br>  <span class=\"hljs-number\">0x1c07c0003f90</span>: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd<br>  <span class=\"hljs-number\">0x1c07c0003fa0</span>: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd<br>  <span class=\"hljs-number\">0x1c07c0003fb0</span>: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fa fa<br>  <span class=\"hljs-number\">0x1c07c0003fc0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class=\"hljs-number\">0x1c07c0003fd0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>Shadow byte <span class=\"hljs-built_in\">legend</span> (one shadow byte represents <span class=\"hljs-number\">8</span> application bytes):<br>  Addressable:           <span class=\"hljs-number\">00</span><br>  Partially addressable: <span class=\"hljs-number\">01</span> <span class=\"hljs-number\">02</span> <span class=\"hljs-number\">03</span> <span class=\"hljs-number\">04</span> <span class=\"hljs-number\">05</span> <span class=\"hljs-number\">06</span> <span class=\"hljs-number\">07</span> <br>  Heap left redzone:     fa<br>  Heap righ redzone:     fb<br>  Freed Heap region:     fd<br>  Stack left redzone:    f1<br>  Stack mid redzone:     f2<br>  Stack right redzone:   f3<br>  Stack partial redzone: f4<br>  Stack after <span class=\"hljs-keyword\">return</span>:    f5<br>  Stack use after scope: f8<br>  Global redzone:        f9<br>  Global init order:     f6<br>  Poisoned by user:      f7<br>  ASan internal:         fe<br>==<span class=\"hljs-number\">6254</span>== ABORTING<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">1. 错误类型摘要<br>    <span class=\"hljs-comment\"># ASan 检测到错误类型是 heap-use-after-free，表示访问了已经释放的堆内存。</span><br>    ==6254== ERROR: AddressSanitizer: heap-use-after-free on address 0x603e0001fc64<br><br>2. 出错位置<br>    <span class=\"hljs-comment\"># 错误发生在 example_UseAfterFree.cc 文件的第5行 main 函数中。</span><br>    <span class=\"hljs-comment\"># 出错时正在读取（READ）4字节的数据。</span><br>    READ of size 4 at 0x603e0001fc64 thread T0<br>      <span class=\"hljs-comment\">#0 0x417f69 in main example_UseAfterFree.cc:5</span><br>      <span class=\"hljs-comment\">#1 0x7fae62b5076c (/lib/x86_64-linux-gnu/libc.so.6+0x2176c)</span><br>      <span class=\"hljs-comment\">#2 0x417e54 (a.out+0x417e54)</span><br><br>3. 内存分配与释放信息<br>    <span class=\"hljs-comment\"># 这块内存是在 example_UseAfterFree.cc 文件第3行通过 new[] 分配的。</span><br>    previously allocated by thread T0 here:<br>      <span class=\"hljs-comment\">#0 0x40d312 in operator new[](unsigned long)</span><br>      <span class=\"hljs-comment\">#1 0x417f1e in main example_UseAfterFree.cc:3</span><br><br>    <span class=\"hljs-comment\"># 这块内存已经在第4行通过 delete[] 被释放。</span><br>    freed by thread T0 here:<br>      <span class=\"hljs-comment\">#0 0x40d4d2 in operator delete[](void*)</span><br>      <span class=\"hljs-comment\">#1 0x417f2e in main example_UseAfterFree.cc:4</span><br><br>4. Shadow Memory 状态<br>    <span class=\"hljs-comment\"># 出错地址周围的 Shadow Memory 信息如下：</span><br>    Shadow bytes around the buggy address:<br>      0x1c07c0003f80: fa fa fa fa fa fa fa fa fa fa fa fa [fd]fd fd fd<br>    <span class=\"hljs-comment\"># 其中 fd 表示 &quot;Freed Heap Region&quot;，即已经释放的堆内存。</span><br>    <span class=\"hljs-comment\"># 说明正在访问一块已经释放的堆区域，因此发生了 heap-use-after-free 错误。</span><br><br>5. Shadow Byte Legend<br>    <span class=\"hljs-comment\"># Shadow Byte 各个标记含义：</span><br>    - 00: 正常可访问内存<br>    - fd: 已释放的堆内存（Freed Heap region）<br>    - fa: 堆红区（Heap redzone，用于保护越界）<br></code></pre></td></tr></table></figure>\n\n<p>更多例子在：<a href=\"https://github.com/google/sanitizers/wiki/addresssanitizer%E7%9A%84introduction%E9%83%A8%E5%88%86\">https://github.com/google/sanitizers/wiki/addresssanitizer的introduction部分</a></p>\n<h3 id=\"Valgrind-输出示例\"><a href=\"#Valgrind-输出示例\" class=\"headerlink\" title=\"Valgrind 输出示例\"></a>Valgrind 输出示例</h3><h4 id=\"验证代码-1\"><a href=\"#验证代码-1\" class=\"headerlink\" title=\"验证代码\"></a>验证代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-type\">int</span>* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 只申请不回收，leak</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br><br>    <span class=\"hljs-built_in\">func</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">// sh命令</span><br>g++ test.cpp -g<br>valgrind --leak-check=full ./a.out<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"验证结果-1\"><a href=\"#验证结果-1\" class=\"headerlink\" title=\"验证结果\"></a>验证结果</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">[root:~/stutest]# valgrind --leak-check=full ./a.out <br>==1536437== Memcheck, a memory error detector<br>==1536437== Copyright (C) 2002-2017, and GNU GPL<span class=\"hljs-string\">&#x27;d, by Julian Seward et al.</span><br><span class=\"hljs-string\">==1536437== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info</span><br><span class=\"hljs-string\">==1536437== Command: ./a.out</span><br><span class=\"hljs-string\">==1536437== </span><br><span class=\"hljs-string\">==1536437== </span><br><span class=\"hljs-string\">==1536437== HEAP SUMMARY: # 堆摘要</span><br><span class=\"hljs-string\">==1536437==     in use at exit: 4 bytes in 1 blocks</span><br><span class=\"hljs-string\">==1536437==   total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated</span><br><span class=\"hljs-string\">==1536437== </span><br><span class=\"hljs-string\">==1536437== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class=\"hljs-string\">==1536437==    at 0x48657B8: operator new(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)</span><br><span class=\"hljs-string\">==1536437==    by 0x1088E3: func() (test.cpp:4)</span><br><span class=\"hljs-string\">==1536437==    by 0x108907: main (test.cpp:9)</span><br><span class=\"hljs-string\">==1536437== </span><br><span class=\"hljs-string\">==1536437== LEAK SUMMARY: # 泄露摘要</span><br><span class=\"hljs-string\">==1536437==    definitely lost: 4 bytes in 1 blocks</span><br><span class=\"hljs-string\">==1536437==    indirectly lost: 0 bytes in 0 blocks</span><br><span class=\"hljs-string\">==1536437==      possibly lost: 0 bytes in 0 blocks</span><br><span class=\"hljs-string\">==1536437==    still reachable: 0 bytes in 0 blocks</span><br><span class=\"hljs-string\">==1536437==         suppressed: 0 bytes in 0 blocks</span><br><span class=\"hljs-string\">==1536437== </span><br><span class=\"hljs-string\">==1536437== For lists of detected and suppressed errors, rerun with: -s</span><br><span class=\"hljs-string\">==1536437== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"结果分析-1\"><a href=\"#结果分析-1\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">1. 堆摘要：<br>\t<span class=\"hljs-comment\"># 在程序结束时，有 4 字节的内存仍然在使用，这意味着有一块 4 字节的内存没有被释放。</span><br>    <span class=\"hljs-keyword\">in</span> use at <span class=\"hljs-built_in\">exit</span>: 4 bytes <span class=\"hljs-keyword\">in</span> 1 blocks<br>    <span class=\"hljs-comment\"># 程序总共进行了 2 次内存分配操作（allocs），但是只进行了 1 次内存释放操作（frees），总共分配了 72,708 字节的内存。</span><br>    total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated<br>2. 泄漏摘要<br>\t<span class=\"hljs-comment\"># Valgrind 确认有 4 字节内存泄漏，这次泄漏的详细信息如下：</span><br>\t4 bytes <span class=\"hljs-keyword\">in</span> 1 blocks are definitely lost <span class=\"hljs-keyword\">in</span> loss record 1 of 1<br>\t<span class=\"hljs-comment\"># 内存是在调用 operator new 时分配的，这通常表示你使用了 new 操作符分配了内存。</span><br>\tat 0x486578B: operator new(unsigned long) (<span class=\"hljs-keyword\">in</span> /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)<br>\t<span class=\"hljs-comment\"># func() 函数中进行了内存分配，这是导致内存泄漏的地方。</span><br>\tby 0x1088E3: func() (test.cpp:4)<br>\t<span class=\"hljs-comment\"># main 函数调用了 func()，导致了内存泄漏。</span><br>\tby 0x108907: main (test.cpp:9)<br>3. 错误摘要<br>\t<span class=\"hljs-comment\"># 总共检测到 1 个内存泄漏错误，且没有任何错误被抑制。</span><br>    ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"常见内存泄漏的场景\"><a href=\"#常见内存泄漏的场景\" class=\"headerlink\" title=\"常见内存泄漏的场景\"></a>常见内存泄漏的场景</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">memoryLeak1</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 简单的内存泄漏，没有释放分配的内存</span><br>    <span class=\"hljs-type\">int</span>* leakyArray = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[<span class=\"hljs-number\">100</span>];<br>    <span class=\"hljs-comment\">// 忘记释放 leakyArray</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">memoryLeak2</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 动态分配的内存覆盖了原先分配的内存，导致原内存泄漏</span><br>    <span class=\"hljs-type\">char</span>* leakyString = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-number\">25</span>];<br>    <span class=\"hljs-built_in\">strcpy</span>(leakyString, <span class=\"hljs-string\">&quot;Initial allocation&quot;</span>);<br>    <br>    <span class=\"hljs-comment\">// 重新分配，原内存未释放</span><br>    leakyString = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-number\">50</span>];<br>    <span class=\"hljs-built_in\">strcpy</span>(leakyString, <span class=\"hljs-string\">&quot;Reallocation causes leak&quot;</span>);<br><br>    <span class=\"hljs-keyword\">delete</span>[] leakyString; <span class=\"hljs-comment\">// 释放第二次分配的内存</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">memoryLeak3</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 部分内存泄漏，未释放结构体中的某些成员</span><br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>        <span class=\"hljs-type\">int</span>* value;<br>        Node* next;<br>    &#125;;<br><br>    Node* node = <span class=\"hljs-keyword\">new</span> Node;<br>    node-&gt;value = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">10</span>);<br>    node-&gt;next = <span class=\"hljs-literal\">nullptr</span>;<br><br>    <span class=\"hljs-keyword\">delete</span> node; <span class=\"hljs-comment\">// 只释放了 node，没有释放 node-&gt;value</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">memoryLeak4</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 使用未初始化的指针</span><br>    <span class=\"hljs-type\">int</span>* uninitializedPtr;<br>    *uninitializedPtr = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// 未定义行为</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-built_in\">memoryLeak1</span>();<br>    <span class=\"hljs-built_in\">memoryLeak2</span>();<br>    <span class=\"hljs-built_in\">memoryLeak3</span>();<br>    <span class=\"hljs-built_in\">memoryLeak4</span>();<br><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Done testing memory leaks!&quot;</span> &lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、常见问题与坑\"><a href=\"#六、常见问题与坑\" class=\"headerlink\" title=\"六、常见问题与坑\"></a>六、常见问题与坑</h2><h3 id=\"ASan-常见问题\"><a href=\"#ASan-常见问题\" class=\"headerlink\" title=\"ASan 常见问题\"></a><strong>ASan 常见问题</strong></h3><ul>\n<li>与某些库冲突（如 glibc 的 hook）</li>\n<li>需要匹配 libc 版本</li>\n<li>asan版本程序在Linux环境下运行时会额外申请20TB的虚拟内存，会增加大量的虚拟内存使用<ul>\n<li>需要确保&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;overcommit_memory的值不为2</li>\n<li>这也可以作为检验ASan是否工作的标志</li>\n</ul>\n</li>\n<li>asan工具不是万能的，必须要跑到有问题的代码才可以暴露出来</li>\n</ul>\n<h3 id=\"Valgrind-常见问题\"><a href=\"#Valgrind-常见问题\" class=\"headerlink\" title=\"Valgrind 常见问题\"></a><strong>Valgrind 常见问题</strong></h3><ul>\n<li>运行特别慢</li>\n<li>不支持 AVX-512、SIMD 优化程序</li>\n<li>对于一些静态分配或在堆栈上分配的数组的超出范围的读取或写入，Valgrind 可能无法检测到</li>\n<li>在检测某些复杂的内存错误场景时，可能会出现误报或漏报的情况</li>\n</ul>\n<h2 id=\"七、实战应用场景建议\"><a href=\"#七、实战应用场景建议\" class=\"headerlink\" title=\"七、实战应用场景建议\"></a>七、实战应用场景建议</h2><h3 id=\"什么时候优先用-ASan？\"><a href=\"#什么时候优先用-ASan？\" class=\"headerlink\" title=\"什么时候优先用 ASan？\"></a>什么时候优先用 ASan？</h3><ul>\n<li>开发阶段，快速找到内存错误</li>\n<li>代码量很大的时候用Asan</li>\n</ul>\n<h3 id=\"什么时候优先用-Valgrind？\"><a href=\"#什么时候优先用-Valgrind？\" class=\"headerlink\" title=\"什么时候优先用 Valgrind？\"></a>什么时候优先用 Valgrind？</h3><ul>\n<li>找难以发现的泄漏和未初始化读问题，做深入分析</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>场景&#x2F;目标</th>\n<th>适用工具</th>\n<th>原因说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. 内存越界访问检测</td>\n<td>✅ ASan &amp; ✅ Valgrind</td>\n<td>两者均可，但 ASan 检测更快且栈信息更清晰</td>\n</tr>\n<tr>\n<td>2. Use-After-Free 检测</td>\n<td>✅ ASan &amp; ✅ Valgrind</td>\n<td>都能检测，但 ASan 执行效率更高</td>\n</tr>\n<tr>\n<td>3. 内存泄漏检测</td>\n<td>✅ Valgrind（Memcheck）</td>\n<td>ASan 对泄漏检测不如 Valgrind 精细（除非搭配 LeakSanitizer）</td>\n</tr>\n<tr>\n<td>4. 未初始化内存使用检测</td>\n<td>✅ Valgrind</td>\n<td>ASan 无法检测未初始化使用，Valgrind 的 Undef-Value 检测更强</td>\n</tr>\n<tr>\n<td>5. 并发线程数据竞争检测</td>\n<td>🔶 DRD&#x2F;Helgrind（Valgrind 插件）</td>\n<td>ASan 无法检测数据竞争，需用 TSan；Valgrind 插件较弱</td>\n</tr>\n<tr>\n<td>6. 性能要求较高的场合</td>\n<td>✅ ASan</td>\n<td>Valgrind 开销大，ASan 更适合实战部署前测试</td>\n</tr>\n<tr>\n<td>7. 快速集成进 CI&#x2F;CD</td>\n<td>✅ ASan</td>\n<td>编译期工具更易于集成测试流程</td>\n</tr>\n<tr>\n<td>8. 无法重编译的三方库检测</td>\n<td>✅ Valgrind</td>\n<td>ASan 需重新编译，Valgrind 可直接运行已有二进制</td>\n</tr>\n<tr>\n<td>9. 动态分析研究&#x2F;教学</td>\n<td>✅ Valgrind</td>\n<td>更直观、可观测性强、控制粒度高</td>\n</tr>\n<tr>\n<td>10. 大型 C++ 项目（如游戏、系统工具）</td>\n<td>✅ ASan</td>\n<td>开销小，误报少，更适合持续集成测试</td>\n</tr>\n</tbody></table>\n<h2 id=\"八、总结\"><a href=\"#八、总结\" class=\"headerlink\" title=\"八、总结\"></a>八、总结</h2><ul>\n<li>两者优缺点汇总</li>\n<li>推荐搭配使用的方法（如开发中用 ASan，发布前用 Valgrind 细扫）</li>\n</ul>\n<p>学习资料</p>\n<ul>\n<li><a href=\"https://valgrind.org/\">https://valgrind.org/</a></li>\n<li><a href=\"https://hardcore.feishu.cn/docx/doxcnXfsINxeICDFXePBelN3p5f\">https://hardcore.feishu.cn/docx/doxcnXfsINxeICDFXePBelN3p5f</a></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"ASAN、valgrind（内存泄露的检测工具）\"><a href=\"#ASAN、valgrind（内存泄露的检测工具）\" class=\"headerlink\" title=\"ASAN、valgrind（内存泄露的检测工具）\"></a>ASAN、valgrind（内存泄露的检测工具）</h1><h2 id=\"一、工具概览\"><a href=\"#一、工具概览\" class=\"headerlink\" title=\"一、工具概览\"></a>一、工具概览</h2><h3 id=\"ASan\"><a href=\"#ASan\" class=\"headerlink\" title=\"ASan\"></a>ASan</h3><h4 id=\"什么是-AddressSanitizer？\"><a href=\"#什么是-AddressSanitizer？\" class=\"headerlink\" title=\"什么是 AddressSanitizer？\"></a>什么是 AddressSanitizer？</h4><p><a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizer\">AddressSanitizer</a>（又名 ASan）是一款适用于 C&#x2F;C++ 的内存错误检测器。</p>\n<h4 id=\"主要检测什么问题？\"><a href=\"#主要检测什么问题？\" class=\"headerlink\" title=\"主要检测什么问题？\"></a>主要检测什么问题？</h4><p>ASan可以检测出程序中不合理的内存使用行为，主要包括以下行为：</p>\n<table>\n<thead>\n<tr>\n<th><strong>错误行为</strong></th>\n<th><strong>简介</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>global buffer overflow</td>\n<td>全局内存访问越界</td>\n</tr>\n<tr>\n<td>heap buffer overflow</td>\n<td>堆内存访问越界<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerExampleHeapOutOfBounds\">github.com</a></td>\n</tr>\n<tr>\n<td>initialization order bugs</td>\n<td>全局变量初始化顺序异常全局变量初始化间存在依赖，导致实际运行时因初始化顺序问题导致的初始值异常</td>\n</tr>\n<tr>\n<td>memory leaks</td>\n<td>内存泄漏在程序正常退出时输出报告</td>\n</tr>\n<tr>\n<td>stack buffer overflow</td>\n<td>栈内存访问越界</td>\n</tr>\n<tr>\n<td>use after free</td>\n<td>访问已经释放的内存，在释放内存后仍然尝试访问此内存<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerExampleUseAfterFree\">AddressSanitizerExampleUseAfterFree · google&#x2F;sanitizers Wiki</a></td>\n</tr>\n<tr>\n<td>use after return</td>\n<td>访问生命周期结束的对象在函数退出后尝试访问函数内声明的局部变量</td>\n</tr>\n<tr>\n<td>user after scope</td>\n<td>访问生命周期结束的对象在”{}”包起来的代码块外访问代码块内声明的局部变量</td>\n</tr>\n</tbody></table>\n<h3 id=\"Valgrind\"><a href=\"#Valgrind\" class=\"headerlink\" title=\"Valgrind\"></a>Valgrind</h3><h4 id=\"什么是-Valgrind（重点是-Memcheck）？\"><a href=\"#什么是-Valgrind（重点是-Memcheck）？\" class=\"headerlink\" title=\"什么是 Valgrind（重点是 Memcheck）？\"></a>什么是 Valgrind（重点是 Memcheck）？</h4><p>Valgrind 是一个用于构建动态分析工具的插桩框架。Valgrind 中的一些工具可以自动检测许多内存管理和线程错误，并详细分析您的程序。还可以使用 Valgrind 构建新的工具。</p>\n<p>Valgrind 发行版目前包含七个生产级工具：一个内存错误检测器、两个线程错误检测器、一个缓存和分支预测分析器、一个调用图生成缓存和分支预测分析器，以及两个不同的堆分析器。其中最受欢迎的工具是 Memcheck。它可以检测 C 和 C++ 程序中常见的许多内存相关错误，这些错误可能导致程序崩溃和不可预测的行为。</p>\n<h4 id=\"主要检测什么问题？-1\"><a href=\"#主要检测什么问题？-1\" class=\"headerlink\" title=\"主要检测什么问题？\"></a>主要检测什么问题？</h4><p>检测内存泄露，数组越界等一些程序中常见的错误。特别的，它的 memcheck 工具能够检测内存泄漏、未初始化内存的使用和非法的内存访问。</p>\n<h2 id=\"二、原理机制\"><a href=\"#二、原理机制\" class=\"headerlink\" title=\"二、原理机制\"></a>二、原理机制</h2><h3 id=\"ASan工作机制\"><a href=\"#ASan工作机制\" class=\"headerlink\" title=\"ASan工作机制\"></a>ASan工作机制</h3><p>详细的工作原理官方文档：<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm\">https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm</a></p>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>Google ASan工具ASAN，全称 AddressSanitizer，也即地址消毒技术。可以用来检测内存问题，例如<a href=\"https://so.csdn.net/so/search?q=%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA&spm=1001.2101.3001.7020\">缓冲区溢出</a>或对悬空指针的非法访问等。<br>ASan主要是进行<a href=\"https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020\">编译器</a>级别的HOOK与插桩,目前主流Clang，GCC，MSVC都支持，再结合运行时对影子内存的诊断输出，相当于双管齐下，整体效果不错；官方说是2倍左右性能开销，1&#x2F;8的内存到2倍的开销。</p>\n<p>AddressSanitizer主要包括两部分：插桩(Instrumentation)和动态运行库(Run-time library)。插桩主要是针对在llvm编译器级别对访问内存的操作(store，load，alloca等)，将它们进行处理。动态运行库主要提供一些运行时的复杂的功能(比如poison&#x2F;unpoison shadow memory)以及将malloc,free等系统调用函数hook住。</p>\n<h5 id=\"内存操作进行插桩\"><a href=\"#内存操作进行插桩\" class=\"headerlink\" title=\"内存操作进行插桩\"></a>内存操作进行插桩</h5><p>对new,malloc,delete,free,memcpy,其它内存访问等操作进行编译时替换与代码插入，是编译器完成的；加了ASAN相关的编译选项后，代码中的每一次内存访问操作都会被编译器修改为如下方式：</p>\n<p>编译前:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">*address = ...;    <span class=\"hljs-comment\">// or   ... = *address;</span><br></code></pre></td></tr></table></figure>\n\n<p>编译后：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">IsPoisoned</span>(address)) &#123; <span class=\"hljs-comment\">// 判断内存是否中毒</span><br>  <span class=\"hljs-built_in\">ReportError</span>(address, kAccessSize, kIsWrite);<br>&#125;<br>*address = ...;  <span class=\"hljs-comment\">// or: ... = *address;</span><br></code></pre></td></tr></table></figure>\n\n<p>该方式的关键点就在于读写内存前会判断地址是否处于“中毒”状态，还有如何把<code>IsPoisoned</code>实现的非常快，把<code>ReportError</code>实现的非常紧凑，从而避免插入的代码过多。</p>\n<p>eg：</p>\n<p>未插桩的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>&#123;<br>  <span class=\"hljs-type\">char</span> a[<span class=\"hljs-number\">8</span>];<br>  ...<br>  <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>插桩后的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>&#123;<br>  <span class=\"hljs-type\">char</span> redzone1[<span class=\"hljs-number\">32</span>];  <span class=\"hljs-comment\">// 32-byte aligned</span><br>  <span class=\"hljs-type\">char</span> a[<span class=\"hljs-number\">8</span>];          <span class=\"hljs-comment\">// 32-byte aligned</span><br>  <span class=\"hljs-type\">char</span> redzone2[<span class=\"hljs-number\">24</span>]; <br>  <span class=\"hljs-type\">char</span> redzone3[<span class=\"hljs-number\">32</span>];  <span class=\"hljs-comment\">// 32-byte aligned</span><br>  <span class=\"hljs-type\">int</span>  *shadow_base = <span class=\"hljs-built_in\">MemToShadow</span>(redzone1);<br>  shadow_base[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0xffffffff</span>;  <span class=\"hljs-comment\">// poison redzone1</span><br>  shadow_base[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0xffffff00</span>;  <span class=\"hljs-comment\">// poison redzone2, unpoison &#x27;a&#x27;</span><br>  shadow_base[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0xffffffff</span>;  <span class=\"hljs-comment\">// poison redzone3</span><br>  ...<br>  shadow_base[<span class=\"hljs-number\">0</span>] = shadow_base[<span class=\"hljs-number\">1</span>] = shadow_base[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// unpoison all</span><br>  <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"内存映射与诊断\"><a href=\"#内存映射与诊断\" class=\"headerlink\" title=\"内存映射与诊断\"></a>内存映射与诊断</h5><p>按照一定的算法对原始内存进行一分影子内存的拷贝生成，目前不是1：1的拷贝，而是巧妙的按1&#x2F;8大小进行处理，并进行一定的下毒与标记，减少内存的浪费。正常访问内存前，先对影子内存进行检查访问，如果发现数据不对，就进行诊断报错处理。</p>\n<p>运行时库（libasan.so）malloc&#x2F;free函数进行了替换，在malloc函数中额外的分配了Redzone区域的内存，将与Redzone区域对应的影子内存加锁，主要的内存区域对应的影子内存不加锁。redzone 被标记为中毒状态，free函数将所有分配的内存区域加锁，并放到了隔离区域的队列中(保证在一定的时间内不会再被malloc函数分配)，并被标记为中毒状态。</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250514220252808.png\" alt=\"mapping图片\"></p>\n<h5 id=\"防护缓冲区溢出的基本步骤\"><a href=\"#防护缓冲区溢出的基本步骤\" class=\"headerlink\" title=\"防护缓冲区溢出的基本步骤\"></a>防护缓冲区溢出的基本步骤</h5><p>中毒状态：内存对应的 shadow 区标记该内存不能访问的状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">flowchart TD<br>    A[创建 redzone&lt;br&gt;在全局变量、堆、栈前后插入&lt;br&gt;并标记为中毒状态] --&gt; B[建立影子内存区&lt;br&gt;8 字节内存对应 1 字节影子]<br>    B --&gt; C[访问 redzone（如读写）&lt;br&gt;对应影子内存为中毒状态&lt;br&gt;触发报错]<br>    C --&gt; D[报错信息：进程号、错误类型、&lt;br&gt;源文件名、行号、函数调用关系、&lt;br&gt;影子内存状态（出错部分中括号标注）]<br></code></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"内存泄漏检测原理\"><a href=\"#内存泄漏检测原理\" class=\"headerlink\" title=\"内存泄漏检测原理\"></a>内存泄漏检测原理</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">flowchart TD<br>    A[&quot;ASAN 接管内存申请接口&lt;br&gt;(用户使用的内存全部由 ASAN 管理)&quot;] --&gt; B[&quot;进程退出时触发 ASAN 内存泄漏检测&lt;br&gt;(可通过复位、重启等方式触发)&quot;]<br>    B --&gt; C[遍历所有未释放堆内存]<br>    C --&gt; D&#123;该内存是否仍被引用？&#125;<br>    D -- 是 --&gt; F[跳过，未泄漏]<br>    D -- 否 --&gt; E[认定为内存泄漏&lt;br&gt;输出内存大小与申请调用栈]<br>classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"源码路径\"><a href=\"#源码路径\" class=\"headerlink\" title=\"源码路径\"></a>源码路径</h4><table>\n<thead>\n<tr>\n<th>路径</th>\n<th>文件&#x2F;模块</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>asan_rtl.cpp</code></td>\n<td>运行时库入口（RunTime Library）</td>\n<td>初始化 ASan、设置 hook、启动检测等</td>\n</tr>\n<tr>\n<td><code>asan_interceptors.cpp</code></td>\n<td>标准函数拦截器</td>\n<td>重写 <code>memcpy</code>、<code>malloc</code>、<code>free</code> 等函数</td>\n</tr>\n<tr>\n<td><code>asan_report.cpp</code></td>\n<td>报告错误栈信息</td>\n<td>打印报错信息、栈追踪、源码位置等</td>\n</tr>\n<tr>\n<td><code>asan_mapping.h</code></td>\n<td>Shadow memory 映射逻辑</td>\n<td>1:8 映射关系，关键 shadow 计算</td>\n</tr>\n<tr>\n<td><code>asan_allocator.cpp</code></td>\n<td>自定义内存分配器</td>\n<td>包含红区、对齐等安全逻辑</td>\n</tr>\n<tr>\n<td><code>asan_poisoning.cpp</code></td>\n<td>中毒&#x2F;恢复接口</td>\n<td>调用 poison&#x2F;unpoison 改变内存状态</td>\n</tr>\n<tr>\n<td><code>asan_thread.cpp</code></td>\n<td>线程管理</td>\n<td>TLS、线程栈信息维护等</td>\n</tr>\n<tr>\n<td><code>llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp</code></td>\n<td>插桩入口</td>\n<td>插入对 <code>shadow memory</code> 的访问检查代码</td>\n</tr>\n</tbody></table>\n<h4 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h4><p>运行时库入口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TD<br>  A[&quot;compiler-rt/lib/asan/asan_rtl.cpp/__asan_init()&quot;] --&gt; B[&quot;asan_activation.cpp/AsanActivate()激活Asan&quot;]<br>  A --&gt; C[&quot;AsanInitFromRtl()&quot;]<br>  C --&gt; D[&quot;AsanInitInternal()&quot;]<br>  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">AsanInitInternal</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    ……<br>    <span class=\"hljs-comment\">// 设置内存毒化和分配上下文大小</span><br>    <span class=\"hljs-built_in\">SetCanPoisonMemory</span>(<span class=\"hljs-built_in\">flags</span>()-&gt;poison_heap);<br>  \t<span class=\"hljs-built_in\">SetMallocContextSize</span>(<span class=\"hljs-built_in\">common_flags</span>()-&gt;malloc_context_size);<br>    ……<br>    <span class=\"hljs-comment\">// 初始化拦截器</span><br>    <span class=\"hljs-built_in\">InitializeAsanInterceptors</span>();<br>    ……<br>    <span class=\"hljs-comment\">// 初始化影子内存</span><br>    <span class=\"hljs-built_in\">InitializeShadowMemory</span>();<br>    ……<br>    <span class=\"hljs-comment\">// 初始化分配器</span><br>    AllocatorOptions allocator_options;<br>  \tallocator_options.<span class=\"hljs-built_in\">SetFrom</span>(<span class=\"hljs-built_in\">flags</span>(), <span class=\"hljs-built_in\">common_flags</span>());<br>    <span class=\"hljs-built_in\">InitializeAllocator</span>(allocator_options);<br>    ……<br>    <span class=\"hljs-comment\">// 创建主线程，初始化反编辑器</span><br>    AsanThread *main_thread = <span class=\"hljs-built_in\">CreateMainThread</span>();<br>  \t<span class=\"hljs-built_in\">CHECK_EQ</span>(<span class=\"hljs-number\">0</span>, main_thread-&gt;<span class=\"hljs-built_in\">tid</span>());<br>    force_interface_symbols();  <span class=\"hljs-comment\">// no-op.</span><br>    <span class=\"hljs-built_in\">SanitizerInitializeUnwinder</span>();<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>asan_mapping.h</code> 查看 shadow memory 的映射计算公式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> ASAN_SHADOW_SCALE 3</span><br>……<br><span class=\"hljs-meta\">#    <span class=\"hljs-keyword\">define</span> MEM_TO_SHADOW(mem) \\</span><br><span class=\"hljs-meta\">      (((mem) &gt;&gt; ASAN_SHADOW_SCALE) + (ASAN_SHADOW_OFFSET))</span><br><span class=\"hljs-meta\">#    <span class=\"hljs-keyword\">define</span> SHADOW_TO_MEM(mem) \\</span><br><span class=\"hljs-meta\">      (((mem) - (ASAN_SHADOW_OFFSET)) &lt;&lt; (ASAN_SHADOW_SCALE))</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Valgrind工作机制\"><a href=\"#Valgrind工作机制\" class=\"headerlink\" title=\"Valgrind工作机制\"></a>Valgrind工作机制</h3><h4 id=\"工作原理-1\"><a href=\"#工作原理-1\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><p>Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。最直观的表达就是：<code>Valgrind内核 + 工具插件 = Valgrind工具</code>。在Valgrind框架下编写一个二进制程序动态分析工具比从零开始简很多，因为Valgrind内核为新工具的编写提供了许多通用的工具集，比如错误记录、动态插桩等。</p>\n<p>当Valgrind工具程序启动时：</p>\n<ol>\n<li>将需要分析的程序加载与工具程序同一个进程空间中；</li>\n<li>使用<code>JIT（just-in-time）</code>的动态二进制重编译技术，将代码分成一个个小的代码块实施重编译；</li>\n<li>在重编译过程中，<strong>Valgrind内核会将相应代码块的机器码转化成中间表示</strong>，插件会在中间代码中进行相应分析代码的<strong>插桩</strong>，最后通过内核把中间表示转换成原本的机器码，在目标机器上执行；<strong>（源机器码 –&gt; 插桩 –&gt; 目标机器码）</strong></li>\n<li>Valgrind内核大部分时间花在上述机器码和中间表示的相互翻译执行中，<strong>而原程序的所有机器码并没有执行，执行的都是插桩后的代码</strong></li>\n</ol>\n<p>所有的Valgrind工具都是使用<strong>静态链接</strong>的可执行文件，里面包含了Valgrind内核和工具插件。虽然这样会导致每个工具程序中都需要包含一份Valgrind内核，内核大概2.5MB左右，稍微浪费一些磁盘空间，但是静态链接可以使整个可执行文件加载到非标准的启动地址，方便把待分析程序加载进同一个进程空间中，然后使用Valgrind重编译技术将待分析程序机器码重编译到别的地址执行。</p>\n<h5 id=\"核心框架\"><a href=\"#核心框架\" class=\"headerlink\" title=\"核心框架\"></a>核心框架</h5><p>Valgrind的体系结构如下图所示：</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509144807842.png\" alt=\"img\"></p>\n<h5 id=\"工具启动\"><a href=\"#工具启动\" class=\"headerlink\" title=\"工具启动\"></a>工具启动</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TD<br>    A[命令行运行 valgrind --tool=&amp;lt;tool&amp;gt;] --&gt; B[valgrind 程序根据 tool 参数调用 execv]<br>    B --&gt; C[加载对应的 Valgrind 工具插件]<br>    C --&gt; D[Valgrind 内核初始化子系统&lt;br&gt;（地址空间管理器、内存分配器等）]<br>    D --&gt; E[映射目标程序的 .text/.data 段&lt;br&gt;配置堆栈等]<br>    E --&gt; F[初始化命令行参数&lt;br&gt;并加载工具插件]<br>    F --&gt; G[加载更多子系统：&lt;br&gt;翻译表、信号处理、调度器、调试信息等]<br>    G --&gt; H[准备完毕，开始执行目标程序第一条指令&lt;br&gt;进行 JIT 重编译（插桩）并运行]<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"中间表示（VEX）\"><a href=\"#中间表示（VEX）\" class=\"headerlink\" title=\"中间表示（VEX）\"></a>中间表示（VEX）</h5><p>在Valgrind的重编译的过程中，使用的中间表示是一种平台无关的语言——VEX，通过屏蔽硬件平台的差异性，节省了大量针对不同平台的插桩代码。</p>\n<ul>\n<li><p>Statement（结构体<code>IRStmt</code>）表示有副作用的操作，如写寄存器、写内存、临时变量赋值等。其中，Statement由Expression组成。</p>\n</li>\n<li><p>Expression (结构体<code>IRExpr</code>) 表示没有副作用的操作，如读内存、做算术运算等，这些操作可以包含子表达式和表达式树。</p>\n</li>\n<li><p>在Valgrind中，代码被分解成多个小的代码块，每个代码块里包含VEX的Statement列表。每个代码块的结构体是<code>IRSB</code>，<code>IRSB</code>是单入口多出口的，代码如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">typedef</span><br>   <span class=\"hljs-keyword\">struct</span> &#123;<br>      IRTypeEnv* tyenv; <span class=\"hljs-comment\">// 表明IRSB中每个临时变量的类型</span><br>      IRStmt**   stmts; <span class=\"hljs-comment\">// VEX语句列表</span><br>      Int        stmts_size; <span class=\"hljs-comment\">// Statements总长度</span><br>      Int        stmts_used; <span class=\"hljs-comment\">// 实际上使用的Statements的数目</span><br>      IRExpr*    next; <span class=\"hljs-comment\">// 下一跳的位置</span><br>      IRJumpKind jumpkind; <span class=\"hljs-comment\">// 最后代码块结束jump的类型</span><br>      Int        offsIP; <span class=\"hljs-comment\">// IP寄存器的偏移</span><br>   &#125;<br>   IRSB;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>Valgrind根据一定规则将代码划分为很多小代码块后，会进行以下八个阶段，将插件的分析代码进行插桩并优化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TD<br>    A[反汇编：机器码] --&gt; B[树状中间表示]<br>    B --&gt; C[扁平中间表示]<br>    C --&gt; D[带桩的扁平中间表示]:::important<br>    D --&gt; E[优化的扁平中间表示]<br>    E --&gt; F[汇编：带桩的树状中间表示]:::important<br>    F --&gt; G[目标汇编代码]<br>    G --&gt; H[寄存器优化的目标汇编代码]<br>    H --&gt; I[机器码]<br> classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>JIT执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">flowchart TD<br>    A[插桩后的机器码生成] --&gt; B[保存到固定大小的哈希表&lt;br&gt;（线性探测，80%阈值）]:::important<br>    B --&gt; C&#123;哈希表是否达到80%容量？&#125;<br>    C -- 是 --&gt; D[FIFO策略&lt;br&gt;丢弃1/8最旧的代码块]<br>    C -- 否 --&gt; E[继续执行]<br>    E --&gt; F[代码块执行完毕]<br>    D --&gt; F<br>    F --&gt; G[进入dispatcher（汇编实现）]<br>    G --&gt; H&#123;dispatcher快速缓存命中？&#125;<br>    H -- 是 --&gt; I[切换到下一个代码块（快速跳转）]<br>    H -- 否 --&gt; J[进入scheduler（C实现）]<br>    J --&gt; K&#123;哈希表中存在目标代码块？&#125;<br>    K -- 是 --&gt; L[更新dispatcher缓存&lt;br&gt;并跳转]<br>    K -- 否 --&gt; M[重新插桩编译&lt;br&gt;加入哈希表并更新dispatcher缓存]<br>    M --&gt; L<br> classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h5 id=\"Memcheck-检测原理\"><a href=\"#Memcheck-检测原理\" class=\"headerlink\" title=\"Memcheck 检测原理\"></a>Memcheck 检测原理</h5><p><strong>Memcheck</strong>检测内存问题的原理如下图所示：</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509150159067.jpeg\" alt=\"内存检查原理\"></p>\n<p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表。</p>\n<ul>\n<li>Valid-Value 表：对于进程的整个地址空间中的每一个字节(byte)，都有与之对应的 8 个 bits；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li>\n<li>Valid-Address 表：对于进程整个地址空间中的每一个字节(byte)，还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li>\n</ul>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250509171919962.png\" alt=\"memcheck影子内存\"></p>\n<p><strong>检测原理</strong>：</p>\n<ul>\n<li>当要读写内存中某个字节时，首先检查这个字节对应的 A bit。如果该A bit显示该位置是无效位置，memcheck 则报告读写错误。</li>\n<li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 memcheck 会检查对应的V bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</li>\n</ul>\n<h5 id=\"Valgrind回调Memcheck\"><a href=\"#Valgrind回调Memcheck\" class=\"headerlink\" title=\"Valgrind回调Memcheck\"></a>Valgrind回调Memcheck</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mc_pre_clo_init</span><span class=\"hljs-params\">( <span class=\"hljs-type\">void</span> )</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mc_post_clo_init</span> <span class=\"hljs-params\">( <span class=\"hljs-type\">void</span> )</span></span>;<br><span class=\"hljs-function\">IRSB* <span class=\"hljs-title\">MC_</span><span class=\"hljs-params\">(instrument)</span> <span class=\"hljs-params\">( VgCallbackClosure* closure,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                        IRSB* sb_in,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                        <span class=\"hljs-type\">const</span> VexGuestLayout* layout,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                        <span class=\"hljs-type\">const</span> VexGuestExtents* vge,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                        <span class=\"hljs-type\">const</span> VexArchInfo* archinfo_host,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                        IRType gWordTy, IRType hWordTy )</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mc_fini</span> <span class=\"hljs-params\">( Int exitcode )</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>上述四个接口，由Valgrind在不同阶段调用。其中，<code>mc_pre_clo_init</code> 和 <code>mc_post_clo_init</code>用于初始化memcheck插件，<code>MC_(instrument)</code> 是在scheduler需要translate的插桩阶段会调用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">   <span class=\"hljs-built_in\">VG_</span>(track_new_mem_startup)     ( mc_new_mem_startup );<br>   <span class=\"hljs-built_in\">VG_</span>(track_new_mem_mmap)        ( mc_new_mem_mmap );<br>   <span class=\"hljs-built_in\">VG_</span>(track_change_mem_mprotect) ( mc_new_mem_mprotect );<br>   <span class=\"hljs-built_in\">VG_</span>(track_copy_mem_remap)      ( <span class=\"hljs-built_in\">MC_</span>(copy_address_range_state) );<br>   <span class=\"hljs-built_in\">VG_</span>(track_die_mem_stack_signal)( <span class=\"hljs-built_in\">MC_</span>(make_mem_noaccess) );<br>   <span class=\"hljs-built_in\">VG_</span>(track_die_mem_brk)         ( <span class=\"hljs-built_in\">MC_</span>(make_mem_noaccess) );<br>   <span class=\"hljs-built_in\">VG_</span>(track_die_mem_munmap)      ( <span class=\"hljs-built_in\">MC_</span>(make_mem_noaccess) );<br>...<br>   <span class=\"hljs-built_in\">VG_</span>(track_die_mem_stack)       ( mc_die_mem_stack     );<br>   <span class=\"hljs-built_in\">VG_</span>(track_ban_mem_stack)       ( <span class=\"hljs-built_in\">MC_</span>(make_mem_noaccess) );<br>   <span class=\"hljs-built_in\">VG_</span>(track_pre_mem_read)        ( check_mem_is_defined );<br>   <span class=\"hljs-built_in\">VG_</span>(track_pre_mem_read_asciiz) ( check_mem_is_defined_asciiz );<br>   <span class=\"hljs-built_in\">VG_</span>(track_pre_mem_write)       ( check_mem_is_addressable );<br>   <span class=\"hljs-built_in\">VG_</span>(track_post_mem_write)      ( mc_post_mem_write );<br>   <span class=\"hljs-built_in\">VG_</span>(track_post_reg_write)                  ( mc_post_reg_write );<br>   <span class=\"hljs-built_in\">VG_</span>(track_post_reg_write_clientcall_return)( mc_post_reg_write_clientcall );<br></code></pre></td></tr></table></figure>\n\n<p>上述这些 <code>VG_(track_*)</code> 函数是用于向Valgrind内核注册相应的事件监控，这些事件难以通过插桩来拦截的，如堆块的分配、堆栈指针的修改、信号处理等。当注册的事件发生时，Valgrind内核会调用Memcheck注册的函数。</p>\n<h4 id=\"工具包\"><a href=\"#工具包\" class=\"headerlink\" title=\"工具包\"></a>工具包</h4><h5 id=\"Memcheck※\"><a href=\"#Memcheck※\" class=\"headerlink\" title=\"Memcheck※\"></a>Memcheck※</h5><p>Memcheck检测内存管理问题，主要针对C和C++程序。当一个程序在Memcheck的监督下运行时，所有对内存的读取和写入都会被检查，并拦截对malloc&#x2F;new&#x2F;free&#x2F;delete的调用。因此，Memcheck可以检测您的程序是否：</p>\n<ul>\n<li>访问不应该访问的内存（尚未分配的区域、已释放的区域、超过堆块末尾的区域、堆栈中不可访问的区域）。</li>\n<li>以危险的方式使用未初始化的值。</li>\n<li>内存泄漏。</li>\n<li>对堆块执行错误的释放（双重释放、不匹配的释放）。</li>\n<li>将重叠的源内存块和目标内存块传递给memcpy()和相关函数。</li>\n</ul>\n<p>Memcheck会在这些错误发生时立即报告，给出发生错误的源行号，以及为到达该行而调用的函数的堆栈跟踪。Memcheck在字节级别跟踪可寻址性，在位级别跟踪值的初始化。因此，它可以检测单个未初始化位的使用，并且不会报告位字段操作中的虚假错误。Memcheck运行的程序比正常速度慢10-30倍。</p>\n<h5 id=\"Cachegrind\"><a href=\"#Cachegrind\" class=\"headerlink\" title=\"Cachegrind\"></a>Cachegrind</h5><p>Cachegrind是一个缓存探查器。它对CPU中的I1、D1和L2缓存执行详细的模拟，因此可以准确地确定代码中缓存未命中的来源。它通过每个函数、每个模块和整个程序摘要来识别每行源代码的缓存未命中、内存引用和执行的指令的数量。它适用于用任何语言编写的程序。Cachegrind运行的程序比正常速度慢20-100倍。</p>\n<h5 id=\"Callgrind\"><a href=\"#Callgrind\" class=\"headerlink\" title=\"Callgrind\"></a>Callgrind</h5><p>Josef Weidendorfer的Callgrind是对Cachegrind的扩展。它提供了Cachegrind所做的所有信息，以及关于调用图的额外信息。它在3.2.0版本中被集成到Valgrind的主版本中。单独提供的是一个令人惊叹的可视化工具<a href=\"https://kcachegrind.sourceforge.net/html/Home.html\">KCachegrind</a>，它可以更好地概述Callgrind收集的数据；它还可以用于可视化Cachegrind的输出。</p>\n<h5 id=\"Massif\"><a href=\"#Massif\" class=\"headerlink\" title=\"Massif\"></a>Massif</h5><p>Massif是一个堆探查器。它通过获取程序堆的定期快照来执行详细的堆评测。它生成一个图表，显示堆使用情况随时间的变化，包括程序中哪些部分负责最多内存分配的信息。该图由一个文本或HTML文件补充，该文件包括更多信息，用于确定在哪里分配了最多的内存。Massif运行程序的速度比正常速度慢20倍。</p>\n<h5 id=\"Helgrind\"><a href=\"#Helgrind\" class=\"headerlink\" title=\"Helgrind\"></a>Helgrind</h5><p>Helgrind是一个线程调试器，用于在多线程程序中查找数据竞赛。它查找由多个（POSIX p-）线程访问的内存位置，但找不到一致使用的（pthread_mutex_）锁。这样的位置指示线程之间缺少同步，并且可能导致难以找到与定时相关的问题。它对任何使用pthreads的程序都很有用。这是一个有点实验性的工具，所以这里特别欢迎您的反馈。</p>\n<h5 id=\"DRD\"><a href=\"#DRD\" class=\"headerlink\" title=\"DRD\"></a>DRD</h5><p>DRD是一种用于检测多线程C和C++程序中错误的工具。该工具适用于任何使用POSIX线程原语或使用在POSIX线程基元之上构建的线程概念的程序。虽然Helgrind可以检测到违反锁定顺序的情况，但对于大多数程序来说，DRD执行其分析所需的内存较少。</p>\n<h5 id=\"Lackey，Nulgrind\"><a href=\"#Lackey，Nulgrind\" class=\"headerlink\" title=\"Lackey，Nulgrind\"></a>Lackey，Nulgrind</h5><p>Lackey和Nulgrind也包括在Valgrind分布中。它们做的不多，只是为了测试和演示。</p>\n<h5 id=\"DHAT\"><a href=\"#DHAT\" class=\"headerlink\" title=\"DHAT\"></a>DHAT</h5><p>DHAT是一个用于检查程序如何使用堆分配的工具。它跟踪分配的块，并检查每次内存访问，以找到要访问的块（如果有的话）。它还附带了一个GUI，以便于探索配置文件结果</p>\n<h4 id=\"源码路径-1\"><a href=\"#源码路径-1\" class=\"headerlink\" title=\"源码路径\"></a>源码路径</h4><table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>入口源码</th>\n<th>阅读重点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1️⃣ 启动流程</td>\n<td><code>coregrind/m_main.c</code> 中的 <code>main()</code> 函数</td>\n<td>Valgrind 启动逻辑、注册工具、加载用户程序</td>\n</tr>\n<tr>\n<td>2️⃣ 工具注册</td>\n<td><code>memcheck/mc_main.c</code> 中的 <code>mc_pre_clo_init()</code></td>\n<td>Memcheck 是如何作为插件注册并接管分析任务的</td>\n</tr>\n<tr>\n<td>3️⃣ 插桩入口</td>\n<td><code>memcheck/mc_translate.c</code> 中的 <code>MC_(instrument)</code></td>\n<td>如何在 VEX IR 上插入 shadow memory 逻辑来检测读写</td>\n</tr>\n<tr>\n<td>4️⃣ shadow memory 实现</td>\n<td><code>memcheck/mc_machine.c</code>、<code>mc_memory.c</code></td>\n<td>如何为用户空间内存建立 shadow 映射<br>如何检查是否初始化、是否重叠写入等</td>\n</tr>\n<tr>\n<td>5️⃣ 报错逻辑</td>\n<td><code>memcheck/mc_errors.c</code></td>\n<td>各类内存错误的触发条件、错误消息打印函数</td>\n</tr>\n<tr>\n<td>6️⃣ VEX IR 转换（了解即可）</td>\n<td><code>VEX/pub/libvex.h</code>、<code>coregrind/m_translate.c</code></td>\n<td>了解如何将指令翻译成 IR 并应用插件逻辑</td>\n</tr>\n</tbody></table>\n<h4 id=\"源码分析-1\"><a href=\"#源码分析-1\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h4><h5 id=\"启动流程\"><a href=\"#启动流程\" class=\"headerlink\" title=\"启动流程\"></a>启动流程</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TD<br>  A[&quot;coregrind/m_main.c/valgrind_main()&quot;] --&gt; B[&quot;启动调试信息&quot;]<br>  A --&gt; C[&quot;启动地址空间管理器&quot;]<br>  A --&gt; D[&quot;启动动态内存管理器&quot;]<br>  B --&gt; E[&quot;识别cpu类型&quot;]<br>  C --&gt; E<br>  D --&gt; E<br>  E --&gt; F[&quot;识别工具类型&quot;]<br>  F --&gt; G[&quot;设置默认的 vex 控制参数&quot;]<br>  G --&gt; H[&quot;初始化工具tl_pre_clo_init()/tool_post_clo_init()&quot;]:::important<br>  H --&gt; J[&quot;初始化调度器&quot;]<br>  J --&gt; K[&quot;设置一些堆栈状态，运行&quot;]<br> classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"工具注册（以memcheck为例）\"><a href=\"#工具注册（以memcheck为例）\" class=\"headerlink\" title=\"工具注册（以memcheck为例）\"></a>工具注册（以memcheck为例）</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TD<br>  A[&quot;memcheck/mc_main.c/mc_pre_clo_init()&quot;] --&gt; B[&quot;VG_(basic_tool_funcs)&quot;]<br>  B --&gt; C[&quot;插桩入口MC_(instrument)&quot;]:::important<br>  A --&gt; D[&quot;VG_(needs_tool_errors)&quot;]<br>  D --&gt; E[&quot;报错逻辑入口MC_(eq_Error)&quot;]<br>  A --&gt; F[&quot;初始化shadow映射init_shadow_memory()&quot;]<br>  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// mermaid --启动调试信息</span><br><span class=\"hljs-comment\">// memcheck/mc_main.c</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mc_pre_clo_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>   ……<br>   <span class=\"hljs-comment\">// 注册工具，插桩入口</span><br>   <span class=\"hljs-built_in\">VG_</span>(basic_tool_funcs)          (mc_post_clo_init,<br>                                   <span class=\"hljs-built_in\">MC_</span>(instrument),<br>                                   mc_fini);<br>   ……<br>   <span class=\"hljs-comment\">// 报错逻辑入口</span><br>   <span class=\"hljs-built_in\">VG_</span>(needs_tool_errors)         (<span class=\"hljs-built_in\">MC_</span>(eq_Error),<br>                                   <span class=\"hljs-built_in\">MC_</span>(before_pp_Error),<br>                                   <span class=\"hljs-built_in\">MC_</span>(pp_Error),<br>                                   True,<span class=\"hljs-comment\">/*show TIDs for errors*/</span><br>                                   <span class=\"hljs-built_in\">MC_</span>(update_Error_extra),<br>                                   <span class=\"hljs-built_in\">MC_</span>(is_recognised_suppression),<br>                                   <span class=\"hljs-built_in\">MC_</span>(read_extra_suppression_info),<br>                                   <span class=\"hljs-built_in\">MC_</span>(error_matches_suppression),<br>                                   <span class=\"hljs-built_in\">MC_</span>(get_error_name),<br>                                   <span class=\"hljs-built_in\">MC_</span>(get_extra_suppression_info),<br>                                   <span class=\"hljs-built_in\">MC_</span>(print_extra_suppression_use),<br>                                   <span class=\"hljs-built_in\">MC_</span>(update_extra_suppression_use));<br>   ……<br>   <span class=\"hljs-comment\">// shadow映射</span><br>   <span class=\"hljs-built_in\">init_shadow_memory</span>();<br>   ……<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"实现的不同之处\"><a href=\"#实现的不同之处\" class=\"headerlink\" title=\"实现的不同之处\"></a>实现的不同之处</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>AddressSanitizer (ASan)</th>\n<th>Valgrind</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>实现方式</td>\n<td>编译期插桩（基于 Clang&#x2F;LLVM 插入检查代码）</td>\n<td>动态二进制插桩（运行时在二进制层面插桩）</td>\n</tr>\n<tr>\n<td>插桩时机</td>\n<td>编译时</td>\n<td>运行时</td>\n</tr>\n<tr>\n<td>插桩方式</td>\n<td>修改 LLVM IR，插入 shadow memory 检查逻辑</td>\n<td>使用 JIT 模拟器重写程序指令</td>\n</tr>\n<tr>\n<td>内存状态追踪</td>\n<td>使用 Shadow Memory，通常 1:8 映射</td>\n<td>通过完整模拟 CPU 访问并维护虚拟内存状态</td>\n</tr>\n<tr>\n<td>运行时依赖</td>\n<td>编译后程序链接 runtime 库（compiler-rt）</td>\n<td>不修改原程序，Valgrind 作为宿主启动目标程序</td>\n</tr>\n<tr>\n<td>性能开销</td>\n<td>较低（~2x）</td>\n<td>较高（10x-50x）</td>\n</tr>\n<tr>\n<td>可移植性</td>\n<td>与编译器强绑定（Clang）</td>\n<td>与平台强绑定（对 x86&#x2F;x86_64 支持好）</td>\n</tr>\n<tr>\n<td>检测能力</td>\n<td>精度高但主要针对 Heap&#x2F;Stack&#x2F;Global 的越界&#x2F;Use-After-Free</td>\n<td>检测更全面，包含内存泄漏、未初始化变量、未定义行为等</td>\n</tr>\n<tr>\n<td>可扩展性</td>\n<td>可通过编译器 Pass 扩展</td>\n<td>可通过开发工具插件（如 Helgrind, DRD）扩展</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、安装与使用方式\"><a href=\"#三、安装与使用方式\" class=\"headerlink\" title=\"三、安装与使用方式\"></a>三、安装与使用方式</h2><h3 id=\"ASan-使用\"><a href=\"#ASan-使用\" class=\"headerlink\" title=\"ASan 使用\"></a>ASan 使用</h3><h4 id=\"安装Asan\"><a href=\"#安装Asan\" class=\"headerlink\" title=\"安装Asan\"></a>安装Asan</h4><p>在 Ubuntu 上，<strong>ASan (AddressSanitizer)</strong> <strong>不需要单独安装</strong>，因为它是 <strong>GCC</strong> 或 <strong>Clang</strong> 编译器自带的功能模块。你只需要确保你的 <strong>GCC</strong> 或 <strong>Clang</strong> 版本支持 ASan（一般 Ubuntu 18.04+ 默认都支持）。</p>\n<h4 id=\"使用Asan\"><a href=\"#使用Asan\" class=\"headerlink\" title=\"使用Asan\"></a>使用Asan</h4><ol>\n<li><p>使用要求：编译时加上 <code>-fsanitize=address -g</code>（<code>-fsanitize=address</code>：启用 AddressSanitizer，<code>-g</code>：生成调试符号，方便错误定位到具体源码行号）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># eg</span><br>g++ -fsanitize=address -g your_code.cpp -o your_program<br><span class=\"hljs-comment\"># -fno-omit-frame-pointer 让栈追溯信息更加友好</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>编译后直接运行，出现非法内存访问、溢出、use-after-free 等时，ASan 会自动终止程序并输出详细错误栈信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">./your_program<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>进阶配置：可以通过环境变量控制 ASan 行为：</p>\n<ul>\n<li><p>显示更多详细信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> ASAN_OPTIONS=verbosity=1<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>打印出泄漏检测（需要加 <code>-fsanitize=leak</code>）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> ASAN_OPTIONS=detect_leaks=1<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># eg：</span><br><span class=\"hljs-built_in\">export</span> ASAN_OPTIONS=detect_leaks=1:abort_on_error=1<br>./your_program<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>flag</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>halt_on_error</td>\n<td>默认为1，ASan检测到错误后会中止程序设为0后，ASan检测到错误后不会中止程序</td>\n</tr>\n<tr>\n<td>log_path</td>\n<td>设置错误信息的输出路径</td>\n</tr>\n<tr>\n<td>detect_stack_use_after_return</td>\n<td>是否检测use after return错误默认为0，即关闭该检测功能</td>\n</tr>\n<tr>\n<td>help&#x3D;1</td>\n<td>输出所有支持的参数</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>编译加上 <code>-fsanitize=address -g</code></li>\n</ul>\n<p>更多ASAN_OPTIONS可以参考：<a href=\"https://github.com/google/sanitizers/wiki/AddressSanitizerFlags\">https://github.com/google/sanitizers/wiki/AddressSanitizerFlags</a></p>\n<h3 id=\"Valgrind-使用\"><a href=\"#Valgrind-使用\" class=\"headerlink\" title=\"Valgrind 使用\"></a>Valgrind 使用</h3><h4 id=\"安装-Valgrind\"><a href=\"#安装-Valgrind\" class=\"headerlink\" title=\"安装 Valgrind\"></a>安装 Valgrind</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">sudo</span> apt install valgrind <br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426221902305.png\" alt=\"image-20250426221902277\"></p>\n<h4 id=\"使用valgrind\"><a href=\"#使用valgrind\" class=\"headerlink\" title=\"使用valgrind\"></a>使用valgrind</h4><ol>\n<li>使用要求：编译程序时使用调试信息选项 -g（使用编译程序以-g包含调试信息，以便 Memcheck 的错误消息包含准确的行号。-O0如果您可以忍受速度变慢，使用也是一个好主意。 -O1错误消息中的行号可能不准确，但通常情况下，在编译的代码上运行 Memcheck-O1效果很好，而且与直接运行相比，速度提升-O0非常显著。 -O2不建议使用及以上版本，因为 Memcheck 偶尔会报告实际上并不存在未初始化值的错误）。</li>\n<li>使用方法：使用 valgrind 运行程序：valgrind –leak-check&#x3D;full .&#x2F;your_program</li>\n<li>常用选项：<ul>\n<li>–leak-check&#x3D;full：启用详细的内存泄漏检测。</li>\n<li>–track-origins&#x3D;yes：在内存未初始化时，报告其来源。</li>\n<li>–log-file&#x3D;filename：将 Valgrind 的输出写入文件 filename</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四、检测能力比较\"><a href=\"#四、检测能力比较\" class=\"headerlink\" title=\"四、检测能力比较\"></a>四、检测能力比较</h2><table>\n<thead>\n<tr>\n<th>比较项</th>\n<th>ASan</th>\n<th>Valgrind</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>检测内存越界</td>\n<td>✅ 高效准确</td>\n<td>✅ 高效准确</td>\n</tr>\n<tr>\n<td>检测内存泄漏</td>\n<td>✅（可选配 LeakSanitizer）</td>\n<td>✅（默认内置）</td>\n</tr>\n<tr>\n<td>检测未初始化读</td>\n<td>❌（需要另加 MSan）</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>检测堆栈溢出</td>\n<td>✅（有限支持）</td>\n<td>✅（通过 Memcheck 支持）</td>\n</tr>\n<tr>\n<td>检测速度</td>\n<td>🔥 极快（通常 2x-3x 原程序速度）</td>\n<td>🐢 较慢（通常 10x-50x 原程序速度）</td>\n</tr>\n<tr>\n<td>支持大程序</td>\n<td>✅ 支持大内存程序</td>\n<td>❌ 容易内存爆掉</td>\n</tr>\n<tr>\n<td>平台支持</td>\n<td>Linux、macOS、Windows (部分)</td>\n<td>Linux、macOS（Windows 支持差）</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、输出示例与解读\"><a href=\"#五、输出示例与解读\" class=\"headerlink\" title=\"五、输出示例与解读\"></a>五、输出示例与解读</h2><h3 id=\"ASan-错误输出示例\"><a href=\"#ASan-错误输出示例\" class=\"headerlink\" title=\"ASan 错误输出示例\"></a>ASan 错误输出示例</h3><h4 id=\"验证代码\"><a href=\"#验证代码\" class=\"headerlink\" title=\"验证代码\"></a>验证代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> </span>&#123;<br>  <span class=\"hljs-type\">int</span> *array = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[<span class=\"hljs-number\">100</span>];<br>  <span class=\"hljs-keyword\">delete</span> [] array;<br>  <span class=\"hljs-keyword\">return</span> array[argc];  <span class=\"hljs-comment\">// BOOM</span><br>&#125;<br><span class=\"hljs-comment\">// RUN: clang -O -g -fsanitize=address %t &amp;&amp; ./a.out</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"验证结果\"><a href=\"#验证结果\" class=\"headerlink\" title=\"验证结果\"></a>验证结果</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">=================================================================<br>==<span class=\"hljs-number\">6254</span>== ERROR: AddressSanitizer: heap-use-after-free on address <span class=\"hljs-number\">0x603e0001fc64</span> at pc <span class=\"hljs-number\">0x417f6a</span> bp <span class=\"hljs-number\">0x7fff626b3250</span> sp <span class=\"hljs-number\">0x7fff626b3248</span><br>READ of size <span class=\"hljs-number\">4</span> at <span class=\"hljs-number\">0x603e0001fc64</span> thread T0<br>    #<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0x417f69</span> in main example_UseAfterFree.cc:<span class=\"hljs-number\">5</span><br>    #<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0x7fae62b5076c</span> (/lib/x86_64-linux-gnu/libc.so<span class=\"hljs-number\">.6</span><span class=\"hljs-number\">+0x2176c</span>)<br>    #<span class=\"hljs-number\">2</span> <span class=\"hljs-number\">0x417e54</span> (a.out<span class=\"hljs-number\">+0x417e54</span>)<br><span class=\"hljs-number\">0x603e0001fc64</span> is located <span class=\"hljs-number\">4</span> bytes inside of <span class=\"hljs-number\">400</span>-byte region [<span class=\"hljs-number\">0x603e0001fc60</span>,<span class=\"hljs-number\">0x603e0001fdf0</span>)<br>freed by thread T0 here:<br>    #<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0x40d4d2</span> in <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">delete</span>[](<span class=\"hljs-type\">void</span>*) /home/kcc/llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:<span class=\"hljs-number\">61</span><br>    #<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0x417f2e</span> in main example_UseAfterFree.cc:<span class=\"hljs-number\">4</span><br>previously allocated by thread T0 here:<br>    #<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0x40d312</span> in <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">new</span>[](<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span>) /home/kcc/llvm/projects/compiler-rt/lib/asan/asan_new_delete.cc:<span class=\"hljs-number\">46</span><br>    #<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0x417f1e</span> in main example_UseAfterFree.cc:<span class=\"hljs-number\">3</span><br>Shadow bytes around the buggy address:<br>  <span class=\"hljs-number\">0x1c07c0003f30</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class=\"hljs-number\">0x1c07c0003f40</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class=\"hljs-number\">0x1c07c0003f50</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class=\"hljs-number\">0x1c07c0003f60</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class=\"hljs-number\">0x1c07c0003f70</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>=&gt;<span class=\"hljs-number\">0x1c07c0003f80</span>: fa fa fa fa fa fa fa fa fa fa fa fa[fd]fd fd fd<br>  <span class=\"hljs-number\">0x1c07c0003f90</span>: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd<br>  <span class=\"hljs-number\">0x1c07c0003fa0</span>: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd<br>  <span class=\"hljs-number\">0x1c07c0003fb0</span>: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fa fa<br>  <span class=\"hljs-number\">0x1c07c0003fc0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>  <span class=\"hljs-number\">0x1c07c0003fd0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa<br>Shadow byte <span class=\"hljs-built_in\">legend</span> (one shadow byte represents <span class=\"hljs-number\">8</span> application bytes):<br>  Addressable:           <span class=\"hljs-number\">00</span><br>  Partially addressable: <span class=\"hljs-number\">01</span> <span class=\"hljs-number\">02</span> <span class=\"hljs-number\">03</span> <span class=\"hljs-number\">04</span> <span class=\"hljs-number\">05</span> <span class=\"hljs-number\">06</span> <span class=\"hljs-number\">07</span> <br>  Heap left redzone:     fa<br>  Heap righ redzone:     fb<br>  Freed Heap region:     fd<br>  Stack left redzone:    f1<br>  Stack mid redzone:     f2<br>  Stack right redzone:   f3<br>  Stack partial redzone: f4<br>  Stack after <span class=\"hljs-keyword\">return</span>:    f5<br>  Stack use after scope: f8<br>  Global redzone:        f9<br>  Global init order:     f6<br>  Poisoned by user:      f7<br>  ASan internal:         fe<br>==<span class=\"hljs-number\">6254</span>== ABORTING<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">1. 错误类型摘要<br>    <span class=\"hljs-comment\"># ASan 检测到错误类型是 heap-use-after-free，表示访问了已经释放的堆内存。</span><br>    ==6254== ERROR: AddressSanitizer: heap-use-after-free on address 0x603e0001fc64<br><br>2. 出错位置<br>    <span class=\"hljs-comment\"># 错误发生在 example_UseAfterFree.cc 文件的第5行 main 函数中。</span><br>    <span class=\"hljs-comment\"># 出错时正在读取（READ）4字节的数据。</span><br>    READ of size 4 at 0x603e0001fc64 thread T0<br>      <span class=\"hljs-comment\">#0 0x417f69 in main example_UseAfterFree.cc:5</span><br>      <span class=\"hljs-comment\">#1 0x7fae62b5076c (/lib/x86_64-linux-gnu/libc.so.6+0x2176c)</span><br>      <span class=\"hljs-comment\">#2 0x417e54 (a.out+0x417e54)</span><br><br>3. 内存分配与释放信息<br>    <span class=\"hljs-comment\"># 这块内存是在 example_UseAfterFree.cc 文件第3行通过 new[] 分配的。</span><br>    previously allocated by thread T0 here:<br>      <span class=\"hljs-comment\">#0 0x40d312 in operator new[](unsigned long)</span><br>      <span class=\"hljs-comment\">#1 0x417f1e in main example_UseAfterFree.cc:3</span><br><br>    <span class=\"hljs-comment\"># 这块内存已经在第4行通过 delete[] 被释放。</span><br>    freed by thread T0 here:<br>      <span class=\"hljs-comment\">#0 0x40d4d2 in operator delete[](void*)</span><br>      <span class=\"hljs-comment\">#1 0x417f2e in main example_UseAfterFree.cc:4</span><br><br>4. Shadow Memory 状态<br>    <span class=\"hljs-comment\"># 出错地址周围的 Shadow Memory 信息如下：</span><br>    Shadow bytes around the buggy address:<br>      0x1c07c0003f80: fa fa fa fa fa fa fa fa fa fa fa fa [fd]fd fd fd<br>    <span class=\"hljs-comment\"># 其中 fd 表示 &quot;Freed Heap Region&quot;，即已经释放的堆内存。</span><br>    <span class=\"hljs-comment\"># 说明正在访问一块已经释放的堆区域，因此发生了 heap-use-after-free 错误。</span><br><br>5. Shadow Byte Legend<br>    <span class=\"hljs-comment\"># Shadow Byte 各个标记含义：</span><br>    - 00: 正常可访问内存<br>    - fd: 已释放的堆内存（Freed Heap region）<br>    - fa: 堆红区（Heap redzone，用于保护越界）<br></code></pre></td></tr></table></figure>\n\n<p>更多例子在：<a href=\"https://github.com/google/sanitizers/wiki/addresssanitizer%E7%9A%84introduction%E9%83%A8%E5%88%86\">https://github.com/google/sanitizers/wiki/addresssanitizer的introduction部分</a></p>\n<h3 id=\"Valgrind-输出示例\"><a href=\"#Valgrind-输出示例\" class=\"headerlink\" title=\"Valgrind 输出示例\"></a>Valgrind 输出示例</h3><h4 id=\"验证代码-1\"><a href=\"#验证代码-1\" class=\"headerlink\" title=\"验证代码\"></a>验证代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-type\">int</span>* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 只申请不回收，leak</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br><br>    <span class=\"hljs-built_in\">func</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">// sh命令</span><br>g++ test.cpp -g<br>valgrind --leak-check=full ./a.out<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"验证结果-1\"><a href=\"#验证结果-1\" class=\"headerlink\" title=\"验证结果\"></a>验证结果</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">[root:~/stutest]# valgrind --leak-check=full ./a.out <br>==1536437== Memcheck, a memory error detector<br>==1536437== Copyright (C) 2002-2017, and GNU GPL<span class=\"hljs-string\">&#x27;d, by Julian Seward et al.</span><br><span class=\"hljs-string\">==1536437== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info</span><br><span class=\"hljs-string\">==1536437== Command: ./a.out</span><br><span class=\"hljs-string\">==1536437== </span><br><span class=\"hljs-string\">==1536437== </span><br><span class=\"hljs-string\">==1536437== HEAP SUMMARY: # 堆摘要</span><br><span class=\"hljs-string\">==1536437==     in use at exit: 4 bytes in 1 blocks</span><br><span class=\"hljs-string\">==1536437==   total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated</span><br><span class=\"hljs-string\">==1536437== </span><br><span class=\"hljs-string\">==1536437== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class=\"hljs-string\">==1536437==    at 0x48657B8: operator new(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)</span><br><span class=\"hljs-string\">==1536437==    by 0x1088E3: func() (test.cpp:4)</span><br><span class=\"hljs-string\">==1536437==    by 0x108907: main (test.cpp:9)</span><br><span class=\"hljs-string\">==1536437== </span><br><span class=\"hljs-string\">==1536437== LEAK SUMMARY: # 泄露摘要</span><br><span class=\"hljs-string\">==1536437==    definitely lost: 4 bytes in 1 blocks</span><br><span class=\"hljs-string\">==1536437==    indirectly lost: 0 bytes in 0 blocks</span><br><span class=\"hljs-string\">==1536437==      possibly lost: 0 bytes in 0 blocks</span><br><span class=\"hljs-string\">==1536437==    still reachable: 0 bytes in 0 blocks</span><br><span class=\"hljs-string\">==1536437==         suppressed: 0 bytes in 0 blocks</span><br><span class=\"hljs-string\">==1536437== </span><br><span class=\"hljs-string\">==1536437== For lists of detected and suppressed errors, rerun with: -s</span><br><span class=\"hljs-string\">==1536437== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"结果分析-1\"><a href=\"#结果分析-1\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">1. 堆摘要：<br>\t<span class=\"hljs-comment\"># 在程序结束时，有 4 字节的内存仍然在使用，这意味着有一块 4 字节的内存没有被释放。</span><br>    <span class=\"hljs-keyword\">in</span> use at <span class=\"hljs-built_in\">exit</span>: 4 bytes <span class=\"hljs-keyword\">in</span> 1 blocks<br>    <span class=\"hljs-comment\"># 程序总共进行了 2 次内存分配操作（allocs），但是只进行了 1 次内存释放操作（frees），总共分配了 72,708 字节的内存。</span><br>    total heap usage: 2 allocs, 1 frees, 72,708 bytes allocated<br>2. 泄漏摘要<br>\t<span class=\"hljs-comment\"># Valgrind 确认有 4 字节内存泄漏，这次泄漏的详细信息如下：</span><br>\t4 bytes <span class=\"hljs-keyword\">in</span> 1 blocks are definitely lost <span class=\"hljs-keyword\">in</span> loss record 1 of 1<br>\t<span class=\"hljs-comment\"># 内存是在调用 operator new 时分配的，这通常表示你使用了 new 操作符分配了内存。</span><br>\tat 0x486578B: operator new(unsigned long) (<span class=\"hljs-keyword\">in</span> /usr/libexec/valgrind/vgpreload_memcheck-arm64-linux.so)<br>\t<span class=\"hljs-comment\"># func() 函数中进行了内存分配，这是导致内存泄漏的地方。</span><br>\tby 0x1088E3: func() (test.cpp:4)<br>\t<span class=\"hljs-comment\"># main 函数调用了 func()，导致了内存泄漏。</span><br>\tby 0x108907: main (test.cpp:9)<br>3. 错误摘要<br>\t<span class=\"hljs-comment\"># 总共检测到 1 个内存泄漏错误，且没有任何错误被抑制。</span><br>    ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"常见内存泄漏的场景\"><a href=\"#常见内存泄漏的场景\" class=\"headerlink\" title=\"常见内存泄漏的场景\"></a>常见内存泄漏的场景</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">memoryLeak1</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 简单的内存泄漏，没有释放分配的内存</span><br>    <span class=\"hljs-type\">int</span>* leakyArray = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[<span class=\"hljs-number\">100</span>];<br>    <span class=\"hljs-comment\">// 忘记释放 leakyArray</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">memoryLeak2</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 动态分配的内存覆盖了原先分配的内存，导致原内存泄漏</span><br>    <span class=\"hljs-type\">char</span>* leakyString = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-number\">25</span>];<br>    <span class=\"hljs-built_in\">strcpy</span>(leakyString, <span class=\"hljs-string\">&quot;Initial allocation&quot;</span>);<br>    <br>    <span class=\"hljs-comment\">// 重新分配，原内存未释放</span><br>    leakyString = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">char</span>[<span class=\"hljs-number\">50</span>];<br>    <span class=\"hljs-built_in\">strcpy</span>(leakyString, <span class=\"hljs-string\">&quot;Reallocation causes leak&quot;</span>);<br><br>    <span class=\"hljs-keyword\">delete</span>[] leakyString; <span class=\"hljs-comment\">// 释放第二次分配的内存</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">memoryLeak3</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 部分内存泄漏，未释放结构体中的某些成员</span><br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>        <span class=\"hljs-type\">int</span>* value;<br>        Node* next;<br>    &#125;;<br><br>    Node* node = <span class=\"hljs-keyword\">new</span> Node;<br>    node-&gt;value = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">10</span>);<br>    node-&gt;next = <span class=\"hljs-literal\">nullptr</span>;<br><br>    <span class=\"hljs-keyword\">delete</span> node; <span class=\"hljs-comment\">// 只释放了 node，没有释放 node-&gt;value</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">memoryLeak4</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 使用未初始化的指针</span><br>    <span class=\"hljs-type\">int</span>* uninitializedPtr;<br>    *uninitializedPtr = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// 未定义行为</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-built_in\">memoryLeak1</span>();<br>    <span class=\"hljs-built_in\">memoryLeak2</span>();<br>    <span class=\"hljs-built_in\">memoryLeak3</span>();<br>    <span class=\"hljs-built_in\">memoryLeak4</span>();<br><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Done testing memory leaks!&quot;</span> &lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、常见问题与坑\"><a href=\"#六、常见问题与坑\" class=\"headerlink\" title=\"六、常见问题与坑\"></a>六、常见问题与坑</h2><h3 id=\"ASan-常见问题\"><a href=\"#ASan-常见问题\" class=\"headerlink\" title=\"ASan 常见问题\"></a><strong>ASan 常见问题</strong></h3><ul>\n<li>与某些库冲突（如 glibc 的 hook）</li>\n<li>需要匹配 libc 版本</li>\n<li>asan版本程序在Linux环境下运行时会额外申请20TB的虚拟内存，会增加大量的虚拟内存使用<ul>\n<li>需要确保&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;overcommit_memory的值不为2</li>\n<li>这也可以作为检验ASan是否工作的标志</li>\n</ul>\n</li>\n<li>asan工具不是万能的，必须要跑到有问题的代码才可以暴露出来</li>\n</ul>\n<h3 id=\"Valgrind-常见问题\"><a href=\"#Valgrind-常见问题\" class=\"headerlink\" title=\"Valgrind 常见问题\"></a><strong>Valgrind 常见问题</strong></h3><ul>\n<li>运行特别慢</li>\n<li>不支持 AVX-512、SIMD 优化程序</li>\n<li>对于一些静态分配或在堆栈上分配的数组的超出范围的读取或写入，Valgrind 可能无法检测到</li>\n<li>在检测某些复杂的内存错误场景时，可能会出现误报或漏报的情况</li>\n</ul>\n<h2 id=\"七、实战应用场景建议\"><a href=\"#七、实战应用场景建议\" class=\"headerlink\" title=\"七、实战应用场景建议\"></a>七、实战应用场景建议</h2><h3 id=\"什么时候优先用-ASan？\"><a href=\"#什么时候优先用-ASan？\" class=\"headerlink\" title=\"什么时候优先用 ASan？\"></a>什么时候优先用 ASan？</h3><ul>\n<li>开发阶段，快速找到内存错误</li>\n<li>代码量很大的时候用Asan</li>\n</ul>\n<h3 id=\"什么时候优先用-Valgrind？\"><a href=\"#什么时候优先用-Valgrind？\" class=\"headerlink\" title=\"什么时候优先用 Valgrind？\"></a>什么时候优先用 Valgrind？</h3><ul>\n<li>找难以发现的泄漏和未初始化读问题，做深入分析</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>场景&#x2F;目标</th>\n<th>适用工具</th>\n<th>原因说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1. 内存越界访问检测</td>\n<td>✅ ASan &amp; ✅ Valgrind</td>\n<td>两者均可，但 ASan 检测更快且栈信息更清晰</td>\n</tr>\n<tr>\n<td>2. Use-After-Free 检测</td>\n<td>✅ ASan &amp; ✅ Valgrind</td>\n<td>都能检测，但 ASan 执行效率更高</td>\n</tr>\n<tr>\n<td>3. 内存泄漏检测</td>\n<td>✅ Valgrind（Memcheck）</td>\n<td>ASan 对泄漏检测不如 Valgrind 精细（除非搭配 LeakSanitizer）</td>\n</tr>\n<tr>\n<td>4. 未初始化内存使用检测</td>\n<td>✅ Valgrind</td>\n<td>ASan 无法检测未初始化使用，Valgrind 的 Undef-Value 检测更强</td>\n</tr>\n<tr>\n<td>5. 并发线程数据竞争检测</td>\n<td>🔶 DRD&#x2F;Helgrind（Valgrind 插件）</td>\n<td>ASan 无法检测数据竞争，需用 TSan；Valgrind 插件较弱</td>\n</tr>\n<tr>\n<td>6. 性能要求较高的场合</td>\n<td>✅ ASan</td>\n<td>Valgrind 开销大，ASan 更适合实战部署前测试</td>\n</tr>\n<tr>\n<td>7. 快速集成进 CI&#x2F;CD</td>\n<td>✅ ASan</td>\n<td>编译期工具更易于集成测试流程</td>\n</tr>\n<tr>\n<td>8. 无法重编译的三方库检测</td>\n<td>✅ Valgrind</td>\n<td>ASan 需重新编译，Valgrind 可直接运行已有二进制</td>\n</tr>\n<tr>\n<td>9. 动态分析研究&#x2F;教学</td>\n<td>✅ Valgrind</td>\n<td>更直观、可观测性强、控制粒度高</td>\n</tr>\n<tr>\n<td>10. 大型 C++ 项目（如游戏、系统工具）</td>\n<td>✅ ASan</td>\n<td>开销小，误报少，更适合持续集成测试</td>\n</tr>\n</tbody></table>\n<h2 id=\"八、总结\"><a href=\"#八、总结\" class=\"headerlink\" title=\"八、总结\"></a>八、总结</h2><ul>\n<li>两者优缺点汇总</li>\n<li>推荐搭配使用的方法（如开发中用 ASan，发布前用 Valgrind 细扫）</li>\n</ul>\n<p>学习资料</p>\n<ul>\n<li><a href=\"https://valgrind.org/\">https://valgrind.org/</a></li>\n<li><a href=\"https://hardcore.feishu.cn/docx/doxcnXfsINxeICDFXePBelN3p5f\">https://hardcore.feishu.cn/docx/doxcnXfsINxeICDFXePBelN3p5f</a></li>\n</ul>\n"},{"title":"gperftools（Google 提供的开源性能优化工具集）","date":"2025-09-17T12:00:00.000Z","_content":"# gperftools（Google 提供的开源性能优化工具集）\n\n## 一、工具概览\n\n### 什么是 gperftools？\n\n- gperftools 是 Google 提供的开源性能优化工具集，主要用于性能分析和内存管理。\n- 包括 `tcmalloc`（高效的内存分配器）和 `cpu profiler`（CPU 性能分析器）。\n\n### 主要功能\n\n- **tcmalloc**：优化的内存分配器，替代标准的 `malloc`。\n- **cpu profiler**：通过性能采样记录 **CPU 使用情况**，生成火焰图（flame graph）。\n- **heap profiler**：分析程序的堆内存使用，检测内存泄漏和过度使用。\n\n## 二、安装与配置\n\n### **安装方式**\n\n- 使用 `apt`（Ubuntu）：\n\n  ```bash\n  sudo apt-get install google-perftools libgoogle-perftools-dev\n  ```\n\n- 使用 `brew`（macOS）：\n\n  ```bash\n  brew install gperftools\n  ```\n\n- 编译源码：\n\n  ```bash\n  git clone https://github.com/gperftools/gperftools.git\n  cd gperftools\n  ./configure\n  make\n  sudo make install\n  ```\n\n### **配置环境**\n\n- 环境变量设置：\n\n  ```bash\n  export LD_PRELOAD=/usr/local/lib/libtcmalloc.so\n  ```\n\n## 三、常用工具与命令\n\n### 1. tcmalloc（内存分配器）\n\n- 作用：提高内存分配与释放效率，减少内存碎片。\n- 使用：\n  - 在应用中通过设置 `LD_PRELOAD` 来加载 `libtcmalloc`。\n  - 用 `gperftools` 编译的程序会自动使用 `tcmalloc`，无须修改代码。\n\n### 2. CPU Profiler（CPU 性能分析）\n\n#### 启用\n\n- 编译时使用 `-lprofiler` 链接 profiler 库。\n\n  ```bash\n  # LD_PRELOAD 设置加载libprofiler.so\n  # CPUPROFILE 设置采样文件\n  # CPUPROFILE_FREQUENCY 设置采样频率，默认100\n  # 强行结束不能获得采样文件 CPUPROFILESIGNAL设置采样开关信号，关闭采样只需要killall -12 perftest\n  LD_PRELOAD=/usr/local/lib/libprofiler.so CPUPROFILE=data.prof CPUPROFILE_FREQUENCY=555 CPUPROFILESIGNAL=12 ./perftest --benchmark_min_time=10000x \n  ```\n\n- 在代码中启动/停止 profiling：\n\n  ```c++\n  // 精确控制代码采样的区域\n  #include <gperftools/profiler.h>\n  ProfilerStart(\"data.prof\");\n  // 你的代码\n  ProfilerStop();\n  ```\n\n#### 分析\n\n- 使用 `pprof` 或`google-pprof`工具解析生成的 `data.prof` 文件：\n\n  ```bash\n  pprof --text ./your_program data.prof\n  ```\n\n  ![image-20250429163444432](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429163444540.png)\n\n  ```bash\n  # 每一列含义分析，以红框为例\n  # 函数中的样本数\t函数中样本百分比\t当前打印的样本百分比\t函数以及其调用函数中的样本数量\t函数以及其调用子函数中的样本百分比\t函数名\n  ```\n\n- 还可以加入`--stackes`选项打印调用栈\n\n  ```bash\n  pprof --text --stacks ./your_program data.prof\n  ```\n\n  ![image-20250429164022498](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429164022560.png)\n\n- 发现这样不够直观，可以用`--svg`生成调用图更加直观\n\n  ```bash\n  pprof --svg ./your_program ./data.prof > svgout.svg\n  ```\n\n  ![image-20250429164315976](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429164316052.png)\n\n  ```bash\n  # 结果分析\n  # 第一行类名\n  # 第二行函数名\n  # 本函数执行执行的时间（直接执行的时间）\n  # 本函数调用函数执行的时间（调用其他函数的时间）\n  ```\n\n- 可以生成火焰图：\n\n  ```bash\n  pprof --flame ./your_program data.prof\n  ```\n\n### 3. Heap Profiler（堆内存分析）\n\n- 启用：\n\n  - 编译时使用 `-lprofiler`。\n\n  - 运行时启用 heap profiler：\n\n    ```cpp\n    #include <gperftools/heap-profiler.h>\n    HeapProfilerStart(\"heap_profile\");\n    ```\n\n- 分析：\n\n  - 查看生成的 `heap_profile` 文件，定位内存泄漏、内存过度分配等问题。\n\n### 4. Leak Detector（内存泄漏检测）\n\n- 自动检测：当启用 `tcmalloc` 时，`gperftools` 自动跟踪内存分配，报告泄漏。\n\n- 例子：\n\n  ```bash\n  export HEAPPROFILE=heap_profile\n  ./your_program\n  ```\n\n### 5. 常用命令总结\n\n```bash\n# 第一个是用源码编译的，第二个是用apt下载的\npprof --help\ngoogle-pprof --help\n```\n\n| **Options**               | **功能 (NAME)**                          |\n| ------------------------- | ---------------------------------------- |\n| `--cum`                   | 按累计数据排序                           |\n| `--base=<base>`           | 在显示前从配置文件中减去 `<base>`        |\n| **Reporting Granularity** | **报告粒度**                             |\n| `--addresses`             | 按地址级别报告                           |\n| `--lines`                 | 按源代码行级别报告                       |\n| `--functions`             | 按函数级别报告（默认）                   |\n| `--files`                 | 按源代码文件级别报告                     |\n| **Output Type**           | **输出类型**                             |\n| `--text`                  | 生成文本报告（默认）                     |\n| `--gv`                    | 生成 Postscript 并显示                   |\n| `--list=<regexp>`         | 生成匹配常规表达式的源代码列表           |\n| `--disasm=<regexp>`       | 生成匹配常规表达式的指令反汇编代码       |\n| `--dot`                   | 生成 DOT 格式的文件并输出到标准输出      |\n| `--ps`                    | 生成 Postscript 格式文件输出到标准输出   |\n| `--pdf`                   | 生成 PDF 格式文件输出到标准输出          |\n| `--gif`                   | 生成 GIF 格式文件输出到标准输出          |\n| **Heap-Profile Options**  | **堆分析选项**                           |\n| `--inuse_space`           | 显示当前使用的内存（以MB为单位，默认）   |\n| `--inuse_objects`         | 显示当前使用的对象数量                   |\n| `--alloc_space`           | 显示已分配的内存（以MB为单位）           |\n| `--alloc_objects`         | 显示已分配的对象数量                     |\n| `--show_bytes`            | 显示内存使用量（以字节为单位）           |\n| `--drop_negative`         | 忽略负值差异                             |\n| **Call-graph Options**    | **调用图选项**                           |\n| `--nodecount=<n>`         | 显示最多 `<n>` 个节点（默认80）          |\n| `--nodefraction=<f>`      | 隐藏占总数小于 `<f>` 的节点（默认0.005） |\n| `--edgefraction=<f>`      | 隐藏占总数小于 `<f>` 的边（默认0.001）   |\n| `--focus=<regexp>`        | 只聚焦匹配 `<regexp>` 的节点             |\n| `--ignore=<regexp>`       | 忽略匹配 `<regexp>` 的节点               |\n| `--scale=<n>`             | 设置 GV 渲染的缩放比例（默认0）          |\n\n## 四、工具集成与调优\n\n### **集成与调试**\n\n- 配合 **perf** 或 **Valgrind** 使用，进行内存、CPU 性能多角度分析。\n- 与 **gdb** 配合，调试性能问题和内存泄漏。\n\n### **性能优化**\n\n- 优化内存使用，减少内存分配开销。\n- 通过 `CPU profiler` 定位 CPU 瓶颈函数，优化代码热点。\n- 使用 `Heap Profiler` 分析程序内存消耗，减少不必要的内存分配。\n\n## 五、工作原理与源码分析\n\n### tcmalloc\n\n#### 介绍\n\ntcmalloc是google开发的一个专门为高并发场景优化的内存分配器，全称为”thread cache malloc”。按照[官网](http://goog-perftools.sourceforge.net/doc/tcmalloc.html)的介绍，tcmalloc相比于glibc2.3的malloc(底层实现为ptmalloc2)主要有以下优点：\n\n1. 快速：一台2.8GHz的P4机器上，执行一次malloc及free大约需要300纳秒;而tcmalloc的版本同样的操作大约只需要50纳秒。\n2. 空间占用小：相比ptmalloc2，tcmalloc对小对象占用空间进行了优化。例如：分配N个8字节对象只需要占用8N*1.01字节的空间。即，只需要多使用1%的空间。而ptmalloc2中每个对象都需要使用一个4字节的头信息，最后占用的字节可能达到8N*8。\n3. 不容易出现内存暴涨\n\n#### 替换原理\n\nglibc中的memory-allocation方法均被为声明为[弱符号](https://en.wikipedia.org/wiki/Weak_symbol)，只需要在tcmalloc中将其重新定义即可。 具体的重新定义代码在src/libc_override*.h中(不同平台实现不同)，下面是Linux平台下部分memory-allocation函数的重新定义实现：\n\n```c++\nvoid* operator new(size_t size)                  { return tc_new(size);       }\nvoid operator delete(void* p) __THROW            { tc_delete(p);              }\nvoid* operator new[](size_t size)                { return tc_newarray(size);  }\nvoid operator delete[](void* p) __THROW          { tc_deletearray(p);         }\nextern \"C\" {\n  void* malloc(size_t s) __THROW                 { return tc_malloc(s);       }\n  void  free(void* p) __THROW                    { tc_free(p);                }\n  void* realloc(void* p, size_t s) __THROW       { return tc_realloc(p, s);   }\n  void* calloc(size_t n, size_t s) __THROW       { return tc_calloc(n, s);    }\n  void  cfree(void* p) __THROW                   { tc_cfree(p);               }\n}  // extern \"C\"\n```\n\n#### 整体结构\n\n![结构图](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518171450479.png)\n\n上图展示了tcmalloc的整体结构, tcmalloc主要由三个组件组成：ThreadCache、CentralFreeList及PageHeap。 其中：\n\n- ThreadCache: 线程缓存，它是一个TSL(线程本地存储)对象，尺寸小于256K的小内存申请均由ThreadCache进行分配；通过ThreadCache分配过程中不需要任何锁，可以极大的提高分配速度\n- PageHeap: 中央堆分配器，被所有线程共享(分配时需要全局锁定)，负责与操作系统的直接交互(申请及释放内存)，并且大尺寸的内存申请直接通过PageHeap进行分配\n- CentralFreeList：作为PageHeap与ThreadCache的中间人，负责\n  1. 将PageHeap中的内存切分为小块，在恰当时机分配给ThreadCache。\n  2. 获取从ThreadCache中回收的内存并在恰当的时机将部分内存归还给PageHeap\n\n#### 核心思想：Segregated Free List(离散式空闲列表)\n\n![结构图](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518171727566.png)\n\n##### 小内存分配：ThreadCache\n\ntcmalloc实现中，每个thread独立维护了各自的离散式空闲列表，它的核心结构如下：\n\n```c++\nclass FreeList {\nprivate:\n void*    list_;\n uint32_t length_;\n uint32_t lowater_;\n uint32_t max_length_;\n};\n\nclass ThreadCache {\nprivate:\n     FreeList      list_[kNumClasses];    \n};\n```\n\n```mermaid\nflowchart TD\n    A[请求分配小内存] --> B[通过 SizeMap 获取 size class 和 object size]\n    B --> C{ThreadCache 中的 free list 是否为空？}\n    C -- 是 --> D[从 free list 中取出第一个 object 返回]\n    C -- 否 --> E[从 CentralFreeList 获取若干 object]\n    E --> F[取出一个 object 返回，剩下的放入 ThreadCache]\n    E --> G{CentralFreeList 是否也不够？}\n    G -- 是 --> H[CentralFreeList 向 PageHeap 申请一串页面（Span）]\n    H --> I[切割页面为多个 object]\n    I --> J[将部分 object 转移给 ThreadCache]\n    J --> F\n    G -- 否 --> F\n```\n\n##### 大内存分配：PageHeap\n\nPageHeap的职能之一是向操作系统申请内存，与大多数现代分配器一样，tcmalloc使用基于页的分配方式，即每次至少像系统申请1页空间。tcmalloc中定义的页大小为8K个字节(多数linux系统中一页大小为4K字节，也就是说tcmalloc中的一页对应linux中两页)。 虽然PageHeap是按页申请内存，但是它管理内存的基本单位为Span(跨度)，Span对象代表了表示连续的页面。 如下图所示，分别有a，b，c，d四个Span；a占据了2个页面，b占据了1个页面，c占据了4个页面，d占据了3个页面。\n\n![结构图](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518172159207.png)\n\n下面是Span的定义\n\n```c++\nstruct Span {\n  PageID        start;          // Span描述的内存的起始地址\n  Length        length;         // Span页面数量\n  Span*         next;           // Span由双向链表组成，PageHeap和CentralFreeList中都用的到\n  Span*         prev;           //\n  void*         objects;        // Span会在CentralFreeList中拆分成由object组成的free list\n  unsigned int  refcount : 16;  // Span的object被引用次数，当refcount=0时，表示此Span没有被使用\n  unsigned int  sizeclass : 8;  // Span属于的size class\n  unsigned int  location : 2;   // Span在的位置IN_USE？normal？returned？\n  unsigned int  sample : 1;     // Sampled object?\n  // What freelist the span is on: IN_USE if on none, or normal or returned\n  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };\n};\n```\n\n来看下PageHeap的主要结构及示意图：\n\n```c++\nPageMap pagemap_; // page id 到 Span的映射\n\nstruct SpanList {\n   Span        normal;\n   Span        returned;\n};\n\nSpanList large_;\n\nSpanList free_[kMaxPages]; // kMaxPages = 128\n```\n\n![结构图](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518172237981.png)\n\n##### 中间人：CentralFreeList\n\ntcmalloc为每个size class设置设置了一个CentralFreeList(中央自由列表)，ThreadCache之间共享这些CentralFreeList\n\n```c++\n static CentralFreeListPadded central_cache_[kNumClasses];\n  class CentralFreeList {\n  private:\n      SpinLock lock_;\n      size_t size_class_;\n      Span empty_;       \n      Span nonempty_;\n  };\n```\n\n作为中间人，CentralFreeList的功能之一就是从PageHeap中取出部分Span并按照预定大小(SizeMap中定义)将其拆分成大小固定的object供ThreadCache共享；\n\n```mermaid\nflowchart TD\n  A[从 PageHeap 获取 Span] --> B[RegisterSizeClass<br/>设置location和sizeclass]\n  B --> C[Span 切分为 objects<br/>挂到 Span::objects 链表]\n  C --> D[挂到 CentralFreeList::nonempty_]\n\n  E[ThreadCache 请求 object] --> F[从 nonempty_ Span 取 object]\n  F --> G[refcount += 1]\n\n  F -->|Span 空| H[从 nonempty_ 移除<br/>挂到 empty_]\n\n  I[ThreadCache 归还 object] --> J[添加 object 到 Span::objects]\n  J --> K[refcount -= 1]\n\n  K -->|refcount == 0| L[\"从链表移除<br/>PageHeap::Delete(Span)\"]\n  K -->|Span 在 empty_| M[挂回 nonempty_]\n```\n\n\n\n```mermaid\nsequenceDiagram\n  participant CentralFreeList\n  participant PageHeap\n  participant Span\n  participant ThreadCache\n\n  Note over CentralFreeList: 从 PageHeap 获取 Span\n  CentralFreeList->>PageHeap: Request Span\n  PageHeap-->>CentralFreeList: Return Span\n  CentralFreeList->>Span: RegisterSizeClass (location=IN_USE, sizeclass=X)\n  CentralFreeList->>Span: Split Span into objects (free list)\n  CentralFreeList->>CentralFreeList: Add Span to nonempty_ list\n\n  Note over ThreadCache: 从 CentralFreeList 分配 object\n  ThreadCache->>CentralFreeList: Request object\n  CentralFreeList->>Span: Get object from free list\n  Span->>Span: refcount++\n\n  alt No object left in Span\n    CentralFreeList->>CentralFreeList: Move Span to empty_ list\n  end\n\n  Note over ThreadCache: 归还 object 给 CentralFreeList\n  ThreadCache->>CentralFreeList: Return object\n  CentralFreeList->>Span: Add object back to free list\n  Span->>Span: refcount--\n\n  alt refcount == 0\n    CentralFreeList->>CentralFreeList: Remove Span from list\n    CentralFreeList->>PageHeap: Delete(Span)\n  else Span in empty_\n    CentralFreeList->>CentralFreeList: Move Span to nonempty_ list\n  end\n```\n\n### cpu profiler\n\n#### 介绍\n\n这是最初由 Google 开发的 CPU 分析器。使用方法分为三个部分：将库链接到应用程序、运行代码以及分析输出。\n\n#### 工作流程\n\n```mermaid\nflowchart TD\n    Start([程序开始运行])\n    InitProfiler[初始化 Profiler<br>（ProfilerStart）]\n    SetupSignal[设置定时器<br>定期触发 SIGPROF 信号]\n    InstallHandler[安装 SIGPROF 的信号处理器<br>（ProfilerSignalHandler）]\n    Wait[程序继续运行，等待采样时刻]\n    OnSignal[定时器触发 SIGPROF 信号]\n    GetPC[信号处理器中获取当前函数调用地址<br>使用 backtrace 等方法]\n    RecordSample[记录当前调用栈<br>写入 profile 数据结构]\n    WriteToFile[周期性写入 profile 数据文件]\n    StopProfiler[ProfilerStop 停止分析，关闭文件]\n    End([程序结束运行])\n\n    Start --> InitProfiler --> SetupSignal --> InstallHandler --> Wait\n    Wait --> OnSignal --> GetPC --> RecordSample --> Wait\n    RecordSample --> WriteToFile --> Wait\n    Wait --> StopProfiler --> End\n  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n#### 关键源码\n\n```c++\n// 启动 CPU Profiler，采样逻辑主入口\nextern “C” PERFTOOLS_DLL_DECL int ProfilerStart(const char* fname) {\n    return CpuProfiler::instance_.Start(fname, NULL);\n}\nbool CpuProfiler::Start(const char* fname, const ProfilerOptions* options) {\n    collector_.Start(fname, collector_options);\n    // Setup handler for SIGPROF interrupts\n    EnableHandler();\n    return true;\n}\n// 初始化数据收集需要的数据结构\nbool ProfileData::Start(const char* fname, const ProfileData::Options& options) {\n \n    // Open output file and initialize various data structures\n    int fd =open(fname, O_CREAT | O_WRONLY | O_TRUNC, 0666);\n    start_time_ = time(NULL);\n    fname_ = strdup(fname);\n \n    // Reset counters\n    num_evicted_ = 0;\n    count_ = 0;\n    evictions_ = 0;\n    total_bytes_ = 0;\n \n    hash_ = new Bucket[kBuckets];\n    evict_ = new Slot[kBufferLength];\n    memset(hash_, 0, sizeof(hash_[0]) * kBuckets);\n \n    // Record special entries\n    evict_[num_evicted_++] = 0; // count for header\n    evict_[num_evicted_++] = 3; // depth for header\n    evict_[num_evicted_++] = 0; // Version number\n    CHECK_NE(0, options.frequency());\n    int period =1000000/ options.frequency();\n    evict_[num_evicted_++] = period; // Period (microseconds)\n    evict_[num_evicted_++] = 0; // Padding\n    out_ = fd;\n    return true;\n}\n\n// 把prof_handler这个函数注册到了某个地方\nvoid CpuProfiler::EnableHandler() {\n    prof_handler_token_ = ProfileHandlerRegisterCallback(prof_handler, this);\n}\nProfileHandlerToken* ProfileHandlerRegisterCallback(\n    ProfileHandlerCallback callback, void* callback_arg) {\n    return ProfileHandler::Instance()->RegisterCallback(callback, callback_arg);\n}\n// 根据环境变量CPUPROFILE_REALTIME的配置，来决定让SIGPROF还是SIGALRM信号来触发SignalHandler信号处理函数，并根据环境变量CPUPROFILE_FREQUENCY的配置来设置自己的一个频率变量 frequency_\nProfileHandler::ProfileHandler() {\n \n    timer_type_ = (getenv(“CPUPROFILE_REALTIME”) ? ITIMER_REAL : ITIMER_PROF);\n    signal_number_ = (timer_type_ == ITIMER_PROF ? SIGPROF : SIGALRM);\n \n    // Get frequency of interrupts (if specified)\n    char junk;\n    constchar* fr =getenv(“CPUPROFILE_FREQUENCY”);\n \n    if (fr != NULL && (sscanf(fr, \"%u%c\", &frequency_, &junk) == 1) && (frequency_ > 0)) {\n        // Limit to kMaxFrequency\n        frequency_ = (frequency_ > kMaxFrequency) ? kMaxFrequency : frequency_;\n    } else {\n        frequency_ = kDefaultFrequency;\n    }\n \n    // Install the signal handler.\n    structsigaction sa;\n    sa.sa_sigaction = SignalHandler;\n    sa.sa_flags = SA_RESTART | SA_SIGINFO;\n    sigemptyset(&sa.sa_mask);\n    sigaction(signal_number_, &sa, NULL);\n}\n// 加入第一个callback的时候调用StartTimer（）函数来启动定时器，然后调用EnableHander函数来开启回调\nProfileHandlerToken* ProfileHandler::RegisterCallback(ProfileHandlerCallback callback, void* callback_arg) {\n \n    ProfileHandlerToken* token = new ProfileHandlerToken(callback, callback_arg);\n    SpinLockHolder cl(&control_lock_);\n    DisableHandler();\n    {\n        SpinLockHolder sl(&signal_lock_);\n        callbacks_.push_back(token);\n    }\n \n    // Start the timer if timer is shared and this is a first callback.\n    if ((callback_count_ == 0) && (timer_sharing_ == TIMERS_SHARED)) {\n        StartTimer();\n    }\n    ++callback_count_;\n    EnableHandler();\n    return token;\n}\n// \nvoid ProfileHandler::StartTimer() {\n    struct itimerval timer;\n    timer.it_interval.tv_sec = 0;\n    timer.it_interval.tv_usec = 1000000 / frequency_;\n    timer.it_value = timer.it_interval;\n    setitimer(timer_type_, &timer, 0);\n}\n//\nvoid ProfileHandler::EnableHandler() {\n    struct sigaction sa;\n    sa.sa_sigaction = SignalHandler;\n    sa.sa_flags = SA_RESTART | SA_SIGINFO;\n    sigemptyset(&sa.sa_mask);\n    const int signal_number = (timer_type_ == ITIMER_PROF ? SIGPROF : SIGALRM);\n    RAW_CHECK(sigaction(signal_number, &sa, NULL) == 0, \"sigprof (enable)\");\n}\n```\n\n\n\n### heap profiler\n\n#### 介绍\n\nHeap Profiling 通常指对应用程序的堆分配进行收集或采样，来向我们报告程序的内存使用情况，以便分析内存占用原因或定位内存泄漏根源。\n\n#### 工作流程\n\n**Heap Profile 的 stack trace + statistics 数据模型与 CPU Proflie 是一致的**。\n\n```mermaid\nflowchart TD\n    A[\"HeapProfilerStart()\"] --> B[初始化采样参数与文件输出路径]\n    B --> C[注册 malloc/free hook]\n    C --> D[用户程序 malloc]\n    D --> E{是否触发采样?}:::important\n\n    E -- 否 --> F[正常 malloc]\n    E -- 是 --> G[记录采样信息]\n    \n    G --> H[获取调用栈 stacktrace]\n    H --> I[记录 size + stacktrace 到 ProfileTable]\n    I --> J[继续 malloc 执行]\n    \n    J --> K[用户程序运行中多次采样]\n\n    K --> L[\"HeapProfilerDump() 或 Stop()\"]\n    L --> M[导出 .heap 文件]\n    M --> N[使用 pprof 工具进行分析]\nclassDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n\n\n#### 关键源码\n\n```c++\n// 启动入口\nextern \"C\" void HeapProfilerStart(const char* prefix) {\n  (void)tcmalloc::GetProgramInvocationName();\n  SpinLockHolder l(&heap_lock);\n  if (is_on) return;\n  is_on = true;\n  RAW_VLOG(0, \"Starting tracking the heap\");\n    \n  MallocExtension::Initialize();\n  heap_profiler_memory = LowLevelAlloc::NewArena();\n  heap_profile = new(ProfilerMalloc(sizeof(HeapProfileTable)))\n      HeapProfileTable(ProfilerMalloc, ProfilerFree);\n\n  last_dump_alloc = 0;\n  last_dump_free = 0;\n  high_water_mark = 0;\n  last_dump_time = 0;\n    \n  // Now set the hooks that capture new/delete and malloc/free.\n  RAW_CHECK(MallocHook::AddNewHook(&NewHook), \"\");\n  RAW_CHECK(MallocHook::AddDeleteHook(&DeleteHook), \"\");\n  ……\n}\n// tcmalloc 在 malloc() 和 operator new 中增加了一些采样逻辑，当根据条件触发采样 hook 时，会执行以下函数\n// Record an allocation in the profile.\nstatic void RecordAlloc(const void* ptr, size_t bytes, int skip_count) {\n  // Take the stack trace outside the critical section.\nvoid* stack[HeapProfileTable::kMaxStackDepth];\n  int depth = HeapProfileTable::GetCallerStackTrace(skip_count + 1, stack);\n  SpinLockHolder l(&heap_lock);\n  if (is_on) {\n    heap_profile->RecordAlloc(ptr, bytes, depth, stack);\n    MaybeDumpProfileLocked();\n  }\n}\nvoid HeapProfileTable::RecordAlloc(\n    const void* ptr, size_t bytes, int stack_depth,\n    const void* const call_stack[]) {\n  Bucket* b = GetBucket(stack_depth, call_stack);\n  b->allocs++;\n  b->alloc_size += bytes;\n  total_.allocs++;\n  total_.alloc_size += bytes;\n  AllocValue v;\n  v.set_bucket(b);  // also did set_live(false); set_ignore(false)\n  v.bytes = bytes;\n  address_map_->Insert(ptr, v);\n}\n// 在 free() 或 operator delete 中同样需要增加一些逻辑来记录内存释放情况\n// Record a deallocation in the profile.\nstatic void RecordFree(const void* ptr) {\n  SpinLockHolder l(&heap_lock);\n  if (is_on) {\n    heap_profile->RecordFree(ptr);\n    MaybeDumpProfileLocked();\n  }\n}\nvoid HeapProfileTable::RecordFree(const void* ptr) {\n  AllocValue v;\n  if (address_map_->FindAndRemove(ptr, &v)) {\n    Bucket* b = v.bucket();\n    b->frees++;\n    b->free_size += v.bytes;\n    total_.frees++;\n    total_.free_size += v.bytes;\n  }\n}\n// 调用 GetCallerStackTrace() 获取调用栈。\nextern \"C\" int MallocHook_GetCallerStackTrace(void** result, int max_depth,\n                                              int skip_count) {\n#if defined(NO_TCMALLOC_SAMPLES)\n  return 0;\n#else\n  if (max_depth < 1) {\n    return 0;\n  }\n  int retval = tcmalloc::GrabBacktrace(result, max_depth, skip_count);\n  // prevent tail-call above\n  *(void* volatile *)result;\n  return retval;\n#endif\n}\n// \n```\n\n\n\n## 六、实战案例与分析\n\n### **案例 1：使用 tcmalloc 优化内存**\n\n- 比较 `malloc` 和 `tcmalloc` 在高频次分配下的性能差异。\n- 分析内存碎片、内存占用的变化。\n\n### **案例 2：使用 CPU Profiler 分析热点**\n\n- 编写一个包含复杂运算的程序，用 `CPU Profiler` 查找 CPU 使用的瓶颈函数。\n- 使用火焰图进行可视化分析，优化计算热点。\n\n### **案例 3：内存泄漏定位与修复**\n\n- 故意写一个内存泄漏示例，使用 `Heap Profiler` 进行检测，定位泄漏源并修复。\n\n## 七、常见问题与坑\n\n- **性能开销**：启用 `gperftools` 后会带来一定的性能开销，尤其是在高负载时。要注意选择合适的 profiling 级别。\n- **与其他库的兼容性**：某些情况下，`tcmalloc` 与第三方库的内存分配可能会发生冲突，需要根据具体情况选择关闭。\n- **内存泄漏的误报**：`Heap Profiler` 有时会报告不准确的内存泄漏，需要结合代码逐步排查。\n\n## 八、总结与心得\n\n- **优点**：\n  - 高效的内存管理，适合高性能应用。\n  - 支持详细的性能分析，帮助定位 CPU 和内存瓶颈。\n- **缺点**：\n  - 使用时有性能开销，建议仅在开发和调试阶段启用。\n  - 配置较为复杂，需要一定的学习曲线。\n- **实用性**：\n  - 在高性能要求的 C++ 项目中使用 `gperftools`，可以大幅提升内存管理效率和 CPU 性能。","source":"_posts/gperftools（Google 提供的开源性能优化工具集）.md","raw":"---\ntitle: \"gperftools（Google 提供的开源性能优化工具集）\"\ndate: 2025-09-17 20:00:00\ntags:\n  - 学习笔记\n  - 算法\ncategories:\n  - 数据结构与算法\n---\n# gperftools（Google 提供的开源性能优化工具集）\n\n## 一、工具概览\n\n### 什么是 gperftools？\n\n- gperftools 是 Google 提供的开源性能优化工具集，主要用于性能分析和内存管理。\n- 包括 `tcmalloc`（高效的内存分配器）和 `cpu profiler`（CPU 性能分析器）。\n\n### 主要功能\n\n- **tcmalloc**：优化的内存分配器，替代标准的 `malloc`。\n- **cpu profiler**：通过性能采样记录 **CPU 使用情况**，生成火焰图（flame graph）。\n- **heap profiler**：分析程序的堆内存使用，检测内存泄漏和过度使用。\n\n## 二、安装与配置\n\n### **安装方式**\n\n- 使用 `apt`（Ubuntu）：\n\n  ```bash\n  sudo apt-get install google-perftools libgoogle-perftools-dev\n  ```\n\n- 使用 `brew`（macOS）：\n\n  ```bash\n  brew install gperftools\n  ```\n\n- 编译源码：\n\n  ```bash\n  git clone https://github.com/gperftools/gperftools.git\n  cd gperftools\n  ./configure\n  make\n  sudo make install\n  ```\n\n### **配置环境**\n\n- 环境变量设置：\n\n  ```bash\n  export LD_PRELOAD=/usr/local/lib/libtcmalloc.so\n  ```\n\n## 三、常用工具与命令\n\n### 1. tcmalloc（内存分配器）\n\n- 作用：提高内存分配与释放效率，减少内存碎片。\n- 使用：\n  - 在应用中通过设置 `LD_PRELOAD` 来加载 `libtcmalloc`。\n  - 用 `gperftools` 编译的程序会自动使用 `tcmalloc`，无须修改代码。\n\n### 2. CPU Profiler（CPU 性能分析）\n\n#### 启用\n\n- 编译时使用 `-lprofiler` 链接 profiler 库。\n\n  ```bash\n  # LD_PRELOAD 设置加载libprofiler.so\n  # CPUPROFILE 设置采样文件\n  # CPUPROFILE_FREQUENCY 设置采样频率，默认100\n  # 强行结束不能获得采样文件 CPUPROFILESIGNAL设置采样开关信号，关闭采样只需要killall -12 perftest\n  LD_PRELOAD=/usr/local/lib/libprofiler.so CPUPROFILE=data.prof CPUPROFILE_FREQUENCY=555 CPUPROFILESIGNAL=12 ./perftest --benchmark_min_time=10000x \n  ```\n\n- 在代码中启动/停止 profiling：\n\n  ```c++\n  // 精确控制代码采样的区域\n  #include <gperftools/profiler.h>\n  ProfilerStart(\"data.prof\");\n  // 你的代码\n  ProfilerStop();\n  ```\n\n#### 分析\n\n- 使用 `pprof` 或`google-pprof`工具解析生成的 `data.prof` 文件：\n\n  ```bash\n  pprof --text ./your_program data.prof\n  ```\n\n  ![image-20250429163444432](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429163444540.png)\n\n  ```bash\n  # 每一列含义分析，以红框为例\n  # 函数中的样本数\t函数中样本百分比\t当前打印的样本百分比\t函数以及其调用函数中的样本数量\t函数以及其调用子函数中的样本百分比\t函数名\n  ```\n\n- 还可以加入`--stackes`选项打印调用栈\n\n  ```bash\n  pprof --text --stacks ./your_program data.prof\n  ```\n\n  ![image-20250429164022498](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429164022560.png)\n\n- 发现这样不够直观，可以用`--svg`生成调用图更加直观\n\n  ```bash\n  pprof --svg ./your_program ./data.prof > svgout.svg\n  ```\n\n  ![image-20250429164315976](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429164316052.png)\n\n  ```bash\n  # 结果分析\n  # 第一行类名\n  # 第二行函数名\n  # 本函数执行执行的时间（直接执行的时间）\n  # 本函数调用函数执行的时间（调用其他函数的时间）\n  ```\n\n- 可以生成火焰图：\n\n  ```bash\n  pprof --flame ./your_program data.prof\n  ```\n\n### 3. Heap Profiler（堆内存分析）\n\n- 启用：\n\n  - 编译时使用 `-lprofiler`。\n\n  - 运行时启用 heap profiler：\n\n    ```cpp\n    #include <gperftools/heap-profiler.h>\n    HeapProfilerStart(\"heap_profile\");\n    ```\n\n- 分析：\n\n  - 查看生成的 `heap_profile` 文件，定位内存泄漏、内存过度分配等问题。\n\n### 4. Leak Detector（内存泄漏检测）\n\n- 自动检测：当启用 `tcmalloc` 时，`gperftools` 自动跟踪内存分配，报告泄漏。\n\n- 例子：\n\n  ```bash\n  export HEAPPROFILE=heap_profile\n  ./your_program\n  ```\n\n### 5. 常用命令总结\n\n```bash\n# 第一个是用源码编译的，第二个是用apt下载的\npprof --help\ngoogle-pprof --help\n```\n\n| **Options**               | **功能 (NAME)**                          |\n| ------------------------- | ---------------------------------------- |\n| `--cum`                   | 按累计数据排序                           |\n| `--base=<base>`           | 在显示前从配置文件中减去 `<base>`        |\n| **Reporting Granularity** | **报告粒度**                             |\n| `--addresses`             | 按地址级别报告                           |\n| `--lines`                 | 按源代码行级别报告                       |\n| `--functions`             | 按函数级别报告（默认）                   |\n| `--files`                 | 按源代码文件级别报告                     |\n| **Output Type**           | **输出类型**                             |\n| `--text`                  | 生成文本报告（默认）                     |\n| `--gv`                    | 生成 Postscript 并显示                   |\n| `--list=<regexp>`         | 生成匹配常规表达式的源代码列表           |\n| `--disasm=<regexp>`       | 生成匹配常规表达式的指令反汇编代码       |\n| `--dot`                   | 生成 DOT 格式的文件并输出到标准输出      |\n| `--ps`                    | 生成 Postscript 格式文件输出到标准输出   |\n| `--pdf`                   | 生成 PDF 格式文件输出到标准输出          |\n| `--gif`                   | 生成 GIF 格式文件输出到标准输出          |\n| **Heap-Profile Options**  | **堆分析选项**                           |\n| `--inuse_space`           | 显示当前使用的内存（以MB为单位，默认）   |\n| `--inuse_objects`         | 显示当前使用的对象数量                   |\n| `--alloc_space`           | 显示已分配的内存（以MB为单位）           |\n| `--alloc_objects`         | 显示已分配的对象数量                     |\n| `--show_bytes`            | 显示内存使用量（以字节为单位）           |\n| `--drop_negative`         | 忽略负值差异                             |\n| **Call-graph Options**    | **调用图选项**                           |\n| `--nodecount=<n>`         | 显示最多 `<n>` 个节点（默认80）          |\n| `--nodefraction=<f>`      | 隐藏占总数小于 `<f>` 的节点（默认0.005） |\n| `--edgefraction=<f>`      | 隐藏占总数小于 `<f>` 的边（默认0.001）   |\n| `--focus=<regexp>`        | 只聚焦匹配 `<regexp>` 的节点             |\n| `--ignore=<regexp>`       | 忽略匹配 `<regexp>` 的节点               |\n| `--scale=<n>`             | 设置 GV 渲染的缩放比例（默认0）          |\n\n## 四、工具集成与调优\n\n### **集成与调试**\n\n- 配合 **perf** 或 **Valgrind** 使用，进行内存、CPU 性能多角度分析。\n- 与 **gdb** 配合，调试性能问题和内存泄漏。\n\n### **性能优化**\n\n- 优化内存使用，减少内存分配开销。\n- 通过 `CPU profiler` 定位 CPU 瓶颈函数，优化代码热点。\n- 使用 `Heap Profiler` 分析程序内存消耗，减少不必要的内存分配。\n\n## 五、工作原理与源码分析\n\n### tcmalloc\n\n#### 介绍\n\ntcmalloc是google开发的一个专门为高并发场景优化的内存分配器，全称为”thread cache malloc”。按照[官网](http://goog-perftools.sourceforge.net/doc/tcmalloc.html)的介绍，tcmalloc相比于glibc2.3的malloc(底层实现为ptmalloc2)主要有以下优点：\n\n1. 快速：一台2.8GHz的P4机器上，执行一次malloc及free大约需要300纳秒;而tcmalloc的版本同样的操作大约只需要50纳秒。\n2. 空间占用小：相比ptmalloc2，tcmalloc对小对象占用空间进行了优化。例如：分配N个8字节对象只需要占用8N*1.01字节的空间。即，只需要多使用1%的空间。而ptmalloc2中每个对象都需要使用一个4字节的头信息，最后占用的字节可能达到8N*8。\n3. 不容易出现内存暴涨\n\n#### 替换原理\n\nglibc中的memory-allocation方法均被为声明为[弱符号](https://en.wikipedia.org/wiki/Weak_symbol)，只需要在tcmalloc中将其重新定义即可。 具体的重新定义代码在src/libc_override*.h中(不同平台实现不同)，下面是Linux平台下部分memory-allocation函数的重新定义实现：\n\n```c++\nvoid* operator new(size_t size)                  { return tc_new(size);       }\nvoid operator delete(void* p) __THROW            { tc_delete(p);              }\nvoid* operator new[](size_t size)                { return tc_newarray(size);  }\nvoid operator delete[](void* p) __THROW          { tc_deletearray(p);         }\nextern \"C\" {\n  void* malloc(size_t s) __THROW                 { return tc_malloc(s);       }\n  void  free(void* p) __THROW                    { tc_free(p);                }\n  void* realloc(void* p, size_t s) __THROW       { return tc_realloc(p, s);   }\n  void* calloc(size_t n, size_t s) __THROW       { return tc_calloc(n, s);    }\n  void  cfree(void* p) __THROW                   { tc_cfree(p);               }\n}  // extern \"C\"\n```\n\n#### 整体结构\n\n![结构图](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518171450479.png)\n\n上图展示了tcmalloc的整体结构, tcmalloc主要由三个组件组成：ThreadCache、CentralFreeList及PageHeap。 其中：\n\n- ThreadCache: 线程缓存，它是一个TSL(线程本地存储)对象，尺寸小于256K的小内存申请均由ThreadCache进行分配；通过ThreadCache分配过程中不需要任何锁，可以极大的提高分配速度\n- PageHeap: 中央堆分配器，被所有线程共享(分配时需要全局锁定)，负责与操作系统的直接交互(申请及释放内存)，并且大尺寸的内存申请直接通过PageHeap进行分配\n- CentralFreeList：作为PageHeap与ThreadCache的中间人，负责\n  1. 将PageHeap中的内存切分为小块，在恰当时机分配给ThreadCache。\n  2. 获取从ThreadCache中回收的内存并在恰当的时机将部分内存归还给PageHeap\n\n#### 核心思想：Segregated Free List(离散式空闲列表)\n\n![结构图](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518171727566.png)\n\n##### 小内存分配：ThreadCache\n\ntcmalloc实现中，每个thread独立维护了各自的离散式空闲列表，它的核心结构如下：\n\n```c++\nclass FreeList {\nprivate:\n void*    list_;\n uint32_t length_;\n uint32_t lowater_;\n uint32_t max_length_;\n};\n\nclass ThreadCache {\nprivate:\n     FreeList      list_[kNumClasses];    \n};\n```\n\n```mermaid\nflowchart TD\n    A[请求分配小内存] --> B[通过 SizeMap 获取 size class 和 object size]\n    B --> C{ThreadCache 中的 free list 是否为空？}\n    C -- 是 --> D[从 free list 中取出第一个 object 返回]\n    C -- 否 --> E[从 CentralFreeList 获取若干 object]\n    E --> F[取出一个 object 返回，剩下的放入 ThreadCache]\n    E --> G{CentralFreeList 是否也不够？}\n    G -- 是 --> H[CentralFreeList 向 PageHeap 申请一串页面（Span）]\n    H --> I[切割页面为多个 object]\n    I --> J[将部分 object 转移给 ThreadCache]\n    J --> F\n    G -- 否 --> F\n```\n\n##### 大内存分配：PageHeap\n\nPageHeap的职能之一是向操作系统申请内存，与大多数现代分配器一样，tcmalloc使用基于页的分配方式，即每次至少像系统申请1页空间。tcmalloc中定义的页大小为8K个字节(多数linux系统中一页大小为4K字节，也就是说tcmalloc中的一页对应linux中两页)。 虽然PageHeap是按页申请内存，但是它管理内存的基本单位为Span(跨度)，Span对象代表了表示连续的页面。 如下图所示，分别有a，b，c，d四个Span；a占据了2个页面，b占据了1个页面，c占据了4个页面，d占据了3个页面。\n\n![结构图](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518172159207.png)\n\n下面是Span的定义\n\n```c++\nstruct Span {\n  PageID        start;          // Span描述的内存的起始地址\n  Length        length;         // Span页面数量\n  Span*         next;           // Span由双向链表组成，PageHeap和CentralFreeList中都用的到\n  Span*         prev;           //\n  void*         objects;        // Span会在CentralFreeList中拆分成由object组成的free list\n  unsigned int  refcount : 16;  // Span的object被引用次数，当refcount=0时，表示此Span没有被使用\n  unsigned int  sizeclass : 8;  // Span属于的size class\n  unsigned int  location : 2;   // Span在的位置IN_USE？normal？returned？\n  unsigned int  sample : 1;     // Sampled object?\n  // What freelist the span is on: IN_USE if on none, or normal or returned\n  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };\n};\n```\n\n来看下PageHeap的主要结构及示意图：\n\n```c++\nPageMap pagemap_; // page id 到 Span的映射\n\nstruct SpanList {\n   Span        normal;\n   Span        returned;\n};\n\nSpanList large_;\n\nSpanList free_[kMaxPages]; // kMaxPages = 128\n```\n\n![结构图](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518172237981.png)\n\n##### 中间人：CentralFreeList\n\ntcmalloc为每个size class设置设置了一个CentralFreeList(中央自由列表)，ThreadCache之间共享这些CentralFreeList\n\n```c++\n static CentralFreeListPadded central_cache_[kNumClasses];\n  class CentralFreeList {\n  private:\n      SpinLock lock_;\n      size_t size_class_;\n      Span empty_;       \n      Span nonempty_;\n  };\n```\n\n作为中间人，CentralFreeList的功能之一就是从PageHeap中取出部分Span并按照预定大小(SizeMap中定义)将其拆分成大小固定的object供ThreadCache共享；\n\n```mermaid\nflowchart TD\n  A[从 PageHeap 获取 Span] --> B[RegisterSizeClass<br/>设置location和sizeclass]\n  B --> C[Span 切分为 objects<br/>挂到 Span::objects 链表]\n  C --> D[挂到 CentralFreeList::nonempty_]\n\n  E[ThreadCache 请求 object] --> F[从 nonempty_ Span 取 object]\n  F --> G[refcount += 1]\n\n  F -->|Span 空| H[从 nonempty_ 移除<br/>挂到 empty_]\n\n  I[ThreadCache 归还 object] --> J[添加 object 到 Span::objects]\n  J --> K[refcount -= 1]\n\n  K -->|refcount == 0| L[\"从链表移除<br/>PageHeap::Delete(Span)\"]\n  K -->|Span 在 empty_| M[挂回 nonempty_]\n```\n\n\n\n```mermaid\nsequenceDiagram\n  participant CentralFreeList\n  participant PageHeap\n  participant Span\n  participant ThreadCache\n\n  Note over CentralFreeList: 从 PageHeap 获取 Span\n  CentralFreeList->>PageHeap: Request Span\n  PageHeap-->>CentralFreeList: Return Span\n  CentralFreeList->>Span: RegisterSizeClass (location=IN_USE, sizeclass=X)\n  CentralFreeList->>Span: Split Span into objects (free list)\n  CentralFreeList->>CentralFreeList: Add Span to nonempty_ list\n\n  Note over ThreadCache: 从 CentralFreeList 分配 object\n  ThreadCache->>CentralFreeList: Request object\n  CentralFreeList->>Span: Get object from free list\n  Span->>Span: refcount++\n\n  alt No object left in Span\n    CentralFreeList->>CentralFreeList: Move Span to empty_ list\n  end\n\n  Note over ThreadCache: 归还 object 给 CentralFreeList\n  ThreadCache->>CentralFreeList: Return object\n  CentralFreeList->>Span: Add object back to free list\n  Span->>Span: refcount--\n\n  alt refcount == 0\n    CentralFreeList->>CentralFreeList: Remove Span from list\n    CentralFreeList->>PageHeap: Delete(Span)\n  else Span in empty_\n    CentralFreeList->>CentralFreeList: Move Span to nonempty_ list\n  end\n```\n\n### cpu profiler\n\n#### 介绍\n\n这是最初由 Google 开发的 CPU 分析器。使用方法分为三个部分：将库链接到应用程序、运行代码以及分析输出。\n\n#### 工作流程\n\n```mermaid\nflowchart TD\n    Start([程序开始运行])\n    InitProfiler[初始化 Profiler<br>（ProfilerStart）]\n    SetupSignal[设置定时器<br>定期触发 SIGPROF 信号]\n    InstallHandler[安装 SIGPROF 的信号处理器<br>（ProfilerSignalHandler）]\n    Wait[程序继续运行，等待采样时刻]\n    OnSignal[定时器触发 SIGPROF 信号]\n    GetPC[信号处理器中获取当前函数调用地址<br>使用 backtrace 等方法]\n    RecordSample[记录当前调用栈<br>写入 profile 数据结构]\n    WriteToFile[周期性写入 profile 数据文件]\n    StopProfiler[ProfilerStop 停止分析，关闭文件]\n    End([程序结束运行])\n\n    Start --> InitProfiler --> SetupSignal --> InstallHandler --> Wait\n    Wait --> OnSignal --> GetPC --> RecordSample --> Wait\n    RecordSample --> WriteToFile --> Wait\n    Wait --> StopProfiler --> End\n  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n#### 关键源码\n\n```c++\n// 启动 CPU Profiler，采样逻辑主入口\nextern “C” PERFTOOLS_DLL_DECL int ProfilerStart(const char* fname) {\n    return CpuProfiler::instance_.Start(fname, NULL);\n}\nbool CpuProfiler::Start(const char* fname, const ProfilerOptions* options) {\n    collector_.Start(fname, collector_options);\n    // Setup handler for SIGPROF interrupts\n    EnableHandler();\n    return true;\n}\n// 初始化数据收集需要的数据结构\nbool ProfileData::Start(const char* fname, const ProfileData::Options& options) {\n \n    // Open output file and initialize various data structures\n    int fd =open(fname, O_CREAT | O_WRONLY | O_TRUNC, 0666);\n    start_time_ = time(NULL);\n    fname_ = strdup(fname);\n \n    // Reset counters\n    num_evicted_ = 0;\n    count_ = 0;\n    evictions_ = 0;\n    total_bytes_ = 0;\n \n    hash_ = new Bucket[kBuckets];\n    evict_ = new Slot[kBufferLength];\n    memset(hash_, 0, sizeof(hash_[0]) * kBuckets);\n \n    // Record special entries\n    evict_[num_evicted_++] = 0; // count for header\n    evict_[num_evicted_++] = 3; // depth for header\n    evict_[num_evicted_++] = 0; // Version number\n    CHECK_NE(0, options.frequency());\n    int period =1000000/ options.frequency();\n    evict_[num_evicted_++] = period; // Period (microseconds)\n    evict_[num_evicted_++] = 0; // Padding\n    out_ = fd;\n    return true;\n}\n\n// 把prof_handler这个函数注册到了某个地方\nvoid CpuProfiler::EnableHandler() {\n    prof_handler_token_ = ProfileHandlerRegisterCallback(prof_handler, this);\n}\nProfileHandlerToken* ProfileHandlerRegisterCallback(\n    ProfileHandlerCallback callback, void* callback_arg) {\n    return ProfileHandler::Instance()->RegisterCallback(callback, callback_arg);\n}\n// 根据环境变量CPUPROFILE_REALTIME的配置，来决定让SIGPROF还是SIGALRM信号来触发SignalHandler信号处理函数，并根据环境变量CPUPROFILE_FREQUENCY的配置来设置自己的一个频率变量 frequency_\nProfileHandler::ProfileHandler() {\n \n    timer_type_ = (getenv(“CPUPROFILE_REALTIME”) ? ITIMER_REAL : ITIMER_PROF);\n    signal_number_ = (timer_type_ == ITIMER_PROF ? SIGPROF : SIGALRM);\n \n    // Get frequency of interrupts (if specified)\n    char junk;\n    constchar* fr =getenv(“CPUPROFILE_FREQUENCY”);\n \n    if (fr != NULL && (sscanf(fr, \"%u%c\", &frequency_, &junk) == 1) && (frequency_ > 0)) {\n        // Limit to kMaxFrequency\n        frequency_ = (frequency_ > kMaxFrequency) ? kMaxFrequency : frequency_;\n    } else {\n        frequency_ = kDefaultFrequency;\n    }\n \n    // Install the signal handler.\n    structsigaction sa;\n    sa.sa_sigaction = SignalHandler;\n    sa.sa_flags = SA_RESTART | SA_SIGINFO;\n    sigemptyset(&sa.sa_mask);\n    sigaction(signal_number_, &sa, NULL);\n}\n// 加入第一个callback的时候调用StartTimer（）函数来启动定时器，然后调用EnableHander函数来开启回调\nProfileHandlerToken* ProfileHandler::RegisterCallback(ProfileHandlerCallback callback, void* callback_arg) {\n \n    ProfileHandlerToken* token = new ProfileHandlerToken(callback, callback_arg);\n    SpinLockHolder cl(&control_lock_);\n    DisableHandler();\n    {\n        SpinLockHolder sl(&signal_lock_);\n        callbacks_.push_back(token);\n    }\n \n    // Start the timer if timer is shared and this is a first callback.\n    if ((callback_count_ == 0) && (timer_sharing_ == TIMERS_SHARED)) {\n        StartTimer();\n    }\n    ++callback_count_;\n    EnableHandler();\n    return token;\n}\n// \nvoid ProfileHandler::StartTimer() {\n    struct itimerval timer;\n    timer.it_interval.tv_sec = 0;\n    timer.it_interval.tv_usec = 1000000 / frequency_;\n    timer.it_value = timer.it_interval;\n    setitimer(timer_type_, &timer, 0);\n}\n//\nvoid ProfileHandler::EnableHandler() {\n    struct sigaction sa;\n    sa.sa_sigaction = SignalHandler;\n    sa.sa_flags = SA_RESTART | SA_SIGINFO;\n    sigemptyset(&sa.sa_mask);\n    const int signal_number = (timer_type_ == ITIMER_PROF ? SIGPROF : SIGALRM);\n    RAW_CHECK(sigaction(signal_number, &sa, NULL) == 0, \"sigprof (enable)\");\n}\n```\n\n\n\n### heap profiler\n\n#### 介绍\n\nHeap Profiling 通常指对应用程序的堆分配进行收集或采样，来向我们报告程序的内存使用情况，以便分析内存占用原因或定位内存泄漏根源。\n\n#### 工作流程\n\n**Heap Profile 的 stack trace + statistics 数据模型与 CPU Proflie 是一致的**。\n\n```mermaid\nflowchart TD\n    A[\"HeapProfilerStart()\"] --> B[初始化采样参数与文件输出路径]\n    B --> C[注册 malloc/free hook]\n    C --> D[用户程序 malloc]\n    D --> E{是否触发采样?}:::important\n\n    E -- 否 --> F[正常 malloc]\n    E -- 是 --> G[记录采样信息]\n    \n    G --> H[获取调用栈 stacktrace]\n    H --> I[记录 size + stacktrace 到 ProfileTable]\n    I --> J[继续 malloc 执行]\n    \n    J --> K[用户程序运行中多次采样]\n\n    K --> L[\"HeapProfilerDump() 或 Stop()\"]\n    L --> M[导出 .heap 文件]\n    M --> N[使用 pprof 工具进行分析]\nclassDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n\n\n#### 关键源码\n\n```c++\n// 启动入口\nextern \"C\" void HeapProfilerStart(const char* prefix) {\n  (void)tcmalloc::GetProgramInvocationName();\n  SpinLockHolder l(&heap_lock);\n  if (is_on) return;\n  is_on = true;\n  RAW_VLOG(0, \"Starting tracking the heap\");\n    \n  MallocExtension::Initialize();\n  heap_profiler_memory = LowLevelAlloc::NewArena();\n  heap_profile = new(ProfilerMalloc(sizeof(HeapProfileTable)))\n      HeapProfileTable(ProfilerMalloc, ProfilerFree);\n\n  last_dump_alloc = 0;\n  last_dump_free = 0;\n  high_water_mark = 0;\n  last_dump_time = 0;\n    \n  // Now set the hooks that capture new/delete and malloc/free.\n  RAW_CHECK(MallocHook::AddNewHook(&NewHook), \"\");\n  RAW_CHECK(MallocHook::AddDeleteHook(&DeleteHook), \"\");\n  ……\n}\n// tcmalloc 在 malloc() 和 operator new 中增加了一些采样逻辑，当根据条件触发采样 hook 时，会执行以下函数\n// Record an allocation in the profile.\nstatic void RecordAlloc(const void* ptr, size_t bytes, int skip_count) {\n  // Take the stack trace outside the critical section.\nvoid* stack[HeapProfileTable::kMaxStackDepth];\n  int depth = HeapProfileTable::GetCallerStackTrace(skip_count + 1, stack);\n  SpinLockHolder l(&heap_lock);\n  if (is_on) {\n    heap_profile->RecordAlloc(ptr, bytes, depth, stack);\n    MaybeDumpProfileLocked();\n  }\n}\nvoid HeapProfileTable::RecordAlloc(\n    const void* ptr, size_t bytes, int stack_depth,\n    const void* const call_stack[]) {\n  Bucket* b = GetBucket(stack_depth, call_stack);\n  b->allocs++;\n  b->alloc_size += bytes;\n  total_.allocs++;\n  total_.alloc_size += bytes;\n  AllocValue v;\n  v.set_bucket(b);  // also did set_live(false); set_ignore(false)\n  v.bytes = bytes;\n  address_map_->Insert(ptr, v);\n}\n// 在 free() 或 operator delete 中同样需要增加一些逻辑来记录内存释放情况\n// Record a deallocation in the profile.\nstatic void RecordFree(const void* ptr) {\n  SpinLockHolder l(&heap_lock);\n  if (is_on) {\n    heap_profile->RecordFree(ptr);\n    MaybeDumpProfileLocked();\n  }\n}\nvoid HeapProfileTable::RecordFree(const void* ptr) {\n  AllocValue v;\n  if (address_map_->FindAndRemove(ptr, &v)) {\n    Bucket* b = v.bucket();\n    b->frees++;\n    b->free_size += v.bytes;\n    total_.frees++;\n    total_.free_size += v.bytes;\n  }\n}\n// 调用 GetCallerStackTrace() 获取调用栈。\nextern \"C\" int MallocHook_GetCallerStackTrace(void** result, int max_depth,\n                                              int skip_count) {\n#if defined(NO_TCMALLOC_SAMPLES)\n  return 0;\n#else\n  if (max_depth < 1) {\n    return 0;\n  }\n  int retval = tcmalloc::GrabBacktrace(result, max_depth, skip_count);\n  // prevent tail-call above\n  *(void* volatile *)result;\n  return retval;\n#endif\n}\n// \n```\n\n\n\n## 六、实战案例与分析\n\n### **案例 1：使用 tcmalloc 优化内存**\n\n- 比较 `malloc` 和 `tcmalloc` 在高频次分配下的性能差异。\n- 分析内存碎片、内存占用的变化。\n\n### **案例 2：使用 CPU Profiler 分析热点**\n\n- 编写一个包含复杂运算的程序，用 `CPU Profiler` 查找 CPU 使用的瓶颈函数。\n- 使用火焰图进行可视化分析，优化计算热点。\n\n### **案例 3：内存泄漏定位与修复**\n\n- 故意写一个内存泄漏示例，使用 `Heap Profiler` 进行检测，定位泄漏源并修复。\n\n## 七、常见问题与坑\n\n- **性能开销**：启用 `gperftools` 后会带来一定的性能开销，尤其是在高负载时。要注意选择合适的 profiling 级别。\n- **与其他库的兼容性**：某些情况下，`tcmalloc` 与第三方库的内存分配可能会发生冲突，需要根据具体情况选择关闭。\n- **内存泄漏的误报**：`Heap Profiler` 有时会报告不准确的内存泄漏，需要结合代码逐步排查。\n\n## 八、总结与心得\n\n- **优点**：\n  - 高效的内存管理，适合高性能应用。\n  - 支持详细的性能分析，帮助定位 CPU 和内存瓶颈。\n- **缺点**：\n  - 使用时有性能开销，建议仅在开发和调试阶段启用。\n  - 配置较为复杂，需要一定的学习曲线。\n- **实用性**：\n  - 在高性能要求的 C++ 项目中使用 `gperftools`，可以大幅提升内存管理效率和 CPU 性能。","slug":"gperftools（Google 提供的开源性能优化工具集）","published":1,"updated":"2025-09-17T11:44:29.044Z","comments":1,"layout":"post","photos":[],"_id":"cmfnx0xvu0002bsvpgn6aehf1","content":"<h1 id=\"gperftools（Google-提供的开源性能优化工具集）\"><a href=\"#gperftools（Google-提供的开源性能优化工具集）\" class=\"headerlink\" title=\"gperftools（Google 提供的开源性能优化工具集）\"></a>gperftools（Google 提供的开源性能优化工具集）</h1><h2 id=\"一、工具概览\"><a href=\"#一、工具概览\" class=\"headerlink\" title=\"一、工具概览\"></a>一、工具概览</h2><h3 id=\"什么是-gperftools？\"><a href=\"#什么是-gperftools？\" class=\"headerlink\" title=\"什么是 gperftools？\"></a>什么是 gperftools？</h3><ul>\n<li>gperftools 是 Google 提供的开源性能优化工具集，主要用于性能分析和内存管理。</li>\n<li>包括 <code>tcmalloc</code>（高效的内存分配器）和 <code>cpu profiler</code>（CPU 性能分析器）。</li>\n</ul>\n<h3 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><ul>\n<li><strong>tcmalloc</strong>：优化的内存分配器，替代标准的 <code>malloc</code>。</li>\n<li><strong>cpu profiler</strong>：通过性能采样记录 <strong>CPU 使用情况</strong>，生成火焰图（flame graph）。</li>\n<li><strong>heap profiler</strong>：分析程序的堆内存使用，检测内存泄漏和过度使用。</li>\n</ul>\n<h2 id=\"二、安装与配置\"><a href=\"#二、安装与配置\" class=\"headerlink\" title=\"二、安装与配置\"></a>二、安装与配置</h2><h3 id=\"安装方式\"><a href=\"#安装方式\" class=\"headerlink\" title=\"安装方式\"></a><strong>安装方式</strong></h3><ul>\n<li><p>使用 <code>apt</code>（Ubuntu）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">sudo</span> apt-get install google-perftools libgoogle-perftools-dev<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>使用 <code>brew</code>（macOS）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">brew install gperftools<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>编译源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/gperftools/gperftools.git<br><span class=\"hljs-built_in\">cd</span> gperftools<br>./configure<br>make<br><span class=\"hljs-built_in\">sudo</span> make install<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a><strong>配置环境</strong></h3><ul>\n<li><p>环境变量设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> LD_PRELOAD=/usr/local/lib/libtcmalloc.so<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"三、常用工具与命令\"><a href=\"#三、常用工具与命令\" class=\"headerlink\" title=\"三、常用工具与命令\"></a>三、常用工具与命令</h2><h3 id=\"1-tcmalloc（内存分配器）\"><a href=\"#1-tcmalloc（内存分配器）\" class=\"headerlink\" title=\"1. tcmalloc（内存分配器）\"></a>1. tcmalloc（内存分配器）</h3><ul>\n<li>作用：提高内存分配与释放效率，减少内存碎片。</li>\n<li>使用：<ul>\n<li>在应用中通过设置 <code>LD_PRELOAD</code> 来加载 <code>libtcmalloc</code>。</li>\n<li>用 <code>gperftools</code> 编译的程序会自动使用 <code>tcmalloc</code>，无须修改代码。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-CPU-Profiler（CPU-性能分析）\"><a href=\"#2-CPU-Profiler（CPU-性能分析）\" class=\"headerlink\" title=\"2. CPU Profiler（CPU 性能分析）\"></a>2. CPU Profiler（CPU 性能分析）</h3><h4 id=\"启用\"><a href=\"#启用\" class=\"headerlink\" title=\"启用\"></a>启用</h4><ul>\n<li><p>编译时使用 <code>-lprofiler</code> 链接 profiler 库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># LD_PRELOAD 设置加载libprofiler.so</span><br><span class=\"hljs-comment\"># CPUPROFILE 设置采样文件</span><br><span class=\"hljs-comment\"># CPUPROFILE_FREQUENCY 设置采样频率，默认100</span><br><span class=\"hljs-comment\"># 强行结束不能获得采样文件 CPUPROFILESIGNAL设置采样开关信号，关闭采样只需要killall -12 perftest</span><br>LD_PRELOAD=/usr/local/lib/libprofiler.so CPUPROFILE=data.prof CPUPROFILE_FREQUENCY=555 CPUPROFILESIGNAL=12 ./perftest --benchmark_min_time=10000x <br></code></pre></td></tr></table></figure>\n</li>\n<li><p>在代码中启动&#x2F;停止 profiling：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 精确控制代码采样的区域</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;gperftools/profiler.h&gt;</span></span><br><span class=\"hljs-built_in\">ProfilerStart</span>(<span class=\"hljs-string\">&quot;data.prof&quot;</span>);<br><span class=\"hljs-comment\">// 你的代码</span><br><span class=\"hljs-built_in\">ProfilerStop</span>();<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li><p>使用 <code>pprof</code> 或<code>google-pprof</code>工具解析生成的 <code>data.prof</code> 文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pprof --text ./your_program data.prof<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429163444540.png\" alt=\"image-20250429163444432\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 每一列含义分析，以红框为例</span><br><span class=\"hljs-comment\"># 函数中的样本数\t函数中样本百分比\t当前打印的样本百分比\t函数以及其调用函数中的样本数量\t函数以及其调用子函数中的样本百分比\t函数名</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>还可以加入<code>--stackes</code>选项打印调用栈</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pprof --text --stacks ./your_program data.prof<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429164022560.png\" alt=\"image-20250429164022498\"></p>\n</li>\n<li><p>发现这样不够直观，可以用<code>--svg</code>生成调用图更加直观</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pprof --svg ./your_program ./data.prof &gt; svgout.svg<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429164316052.png\" alt=\"image-20250429164315976\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 结果分析</span><br><span class=\"hljs-comment\"># 第一行类名</span><br><span class=\"hljs-comment\"># 第二行函数名</span><br><span class=\"hljs-comment\"># 本函数执行执行的时间（直接执行的时间）</span><br><span class=\"hljs-comment\"># 本函数调用函数执行的时间（调用其他函数的时间）</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>可以生成火焰图：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pprof --flame ./your_program data.prof<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-Heap-Profiler（堆内存分析）\"><a href=\"#3-Heap-Profiler（堆内存分析）\" class=\"headerlink\" title=\"3. Heap Profiler（堆内存分析）\"></a>3. Heap Profiler（堆内存分析）</h3><ul>\n<li><p>启用：</p>\n<ul>\n<li><p>编译时使用 <code>-lprofiler</code>。</p>\n</li>\n<li><p>运行时启用 heap profiler：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;gperftools/heap-profiler.h&gt;</span></span><br><span class=\"hljs-built_in\">HeapProfilerStart</span>(<span class=\"hljs-string\">&quot;heap_profile&quot;</span>);<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>分析：</p>\n<ul>\n<li>查看生成的 <code>heap_profile</code> 文件，定位内存泄漏、内存过度分配等问题。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-Leak-Detector（内存泄漏检测）\"><a href=\"#4-Leak-Detector（内存泄漏检测）\" class=\"headerlink\" title=\"4. Leak Detector（内存泄漏检测）\"></a>4. Leak Detector（内存泄漏检测）</h3><ul>\n<li><p>自动检测：当启用 <code>tcmalloc</code> 时，<code>gperftools</code> 自动跟踪内存分配，报告泄漏。</p>\n</li>\n<li><p>例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> HEAPPROFILE=heap_profile<br>./your_program<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5-常用命令总结\"><a href=\"#5-常用命令总结\" class=\"headerlink\" title=\"5. 常用命令总结\"></a>5. 常用命令总结</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 第一个是用源码编译的，第二个是用apt下载的</span><br>pprof --<span class=\"hljs-built_in\">help</span><br>google-pprof --<span class=\"hljs-built_in\">help</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>Options</strong></th>\n<th><strong>功能 (NAME)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>--cum</code></td>\n<td>按累计数据排序</td>\n</tr>\n<tr>\n<td><code>--base=&lt;base&gt;</code></td>\n<td>在显示前从配置文件中减去 <code>&lt;base&gt;</code></td>\n</tr>\n<tr>\n<td><strong>Reporting Granularity</strong></td>\n<td><strong>报告粒度</strong></td>\n</tr>\n<tr>\n<td><code>--addresses</code></td>\n<td>按地址级别报告</td>\n</tr>\n<tr>\n<td><code>--lines</code></td>\n<td>按源代码行级别报告</td>\n</tr>\n<tr>\n<td><code>--functions</code></td>\n<td>按函数级别报告（默认）</td>\n</tr>\n<tr>\n<td><code>--files</code></td>\n<td>按源代码文件级别报告</td>\n</tr>\n<tr>\n<td><strong>Output Type</strong></td>\n<td><strong>输出类型</strong></td>\n</tr>\n<tr>\n<td><code>--text</code></td>\n<td>生成文本报告（默认）</td>\n</tr>\n<tr>\n<td><code>--gv</code></td>\n<td>生成 Postscript 并显示</td>\n</tr>\n<tr>\n<td><code>--list=&lt;regexp&gt;</code></td>\n<td>生成匹配常规表达式的源代码列表</td>\n</tr>\n<tr>\n<td><code>--disasm=&lt;regexp&gt;</code></td>\n<td>生成匹配常规表达式的指令反汇编代码</td>\n</tr>\n<tr>\n<td><code>--dot</code></td>\n<td>生成 DOT 格式的文件并输出到标准输出</td>\n</tr>\n<tr>\n<td><code>--ps</code></td>\n<td>生成 Postscript 格式文件输出到标准输出</td>\n</tr>\n<tr>\n<td><code>--pdf</code></td>\n<td>生成 PDF 格式文件输出到标准输出</td>\n</tr>\n<tr>\n<td><code>--gif</code></td>\n<td>生成 GIF 格式文件输出到标准输出</td>\n</tr>\n<tr>\n<td><strong>Heap-Profile Options</strong></td>\n<td><strong>堆分析选项</strong></td>\n</tr>\n<tr>\n<td><code>--inuse_space</code></td>\n<td>显示当前使用的内存（以MB为单位，默认）</td>\n</tr>\n<tr>\n<td><code>--inuse_objects</code></td>\n<td>显示当前使用的对象数量</td>\n</tr>\n<tr>\n<td><code>--alloc_space</code></td>\n<td>显示已分配的内存（以MB为单位）</td>\n</tr>\n<tr>\n<td><code>--alloc_objects</code></td>\n<td>显示已分配的对象数量</td>\n</tr>\n<tr>\n<td><code>--show_bytes</code></td>\n<td>显示内存使用量（以字节为单位）</td>\n</tr>\n<tr>\n<td><code>--drop_negative</code></td>\n<td>忽略负值差异</td>\n</tr>\n<tr>\n<td><strong>Call-graph Options</strong></td>\n<td><strong>调用图选项</strong></td>\n</tr>\n<tr>\n<td><code>--nodecount=&lt;n&gt;</code></td>\n<td>显示最多 <code>&lt;n&gt;</code> 个节点（默认80）</td>\n</tr>\n<tr>\n<td><code>--nodefraction=&lt;f&gt;</code></td>\n<td>隐藏占总数小于 <code>&lt;f&gt;</code> 的节点（默认0.005）</td>\n</tr>\n<tr>\n<td><code>--edgefraction=&lt;f&gt;</code></td>\n<td>隐藏占总数小于 <code>&lt;f&gt;</code> 的边（默认0.001）</td>\n</tr>\n<tr>\n<td><code>--focus=&lt;regexp&gt;</code></td>\n<td>只聚焦匹配 <code>&lt;regexp&gt;</code> 的节点</td>\n</tr>\n<tr>\n<td><code>--ignore=&lt;regexp&gt;</code></td>\n<td>忽略匹配 <code>&lt;regexp&gt;</code> 的节点</td>\n</tr>\n<tr>\n<td><code>--scale=&lt;n&gt;</code></td>\n<td>设置 GV 渲染的缩放比例（默认0）</td>\n</tr>\n</tbody></table>\n<h2 id=\"四、工具集成与调优\"><a href=\"#四、工具集成与调优\" class=\"headerlink\" title=\"四、工具集成与调优\"></a>四、工具集成与调优</h2><h3 id=\"集成与调试\"><a href=\"#集成与调试\" class=\"headerlink\" title=\"集成与调试\"></a><strong>集成与调试</strong></h3><ul>\n<li>配合 <strong>perf</strong> 或 <strong>Valgrind</strong> 使用，进行内存、CPU 性能多角度分析。</li>\n<li>与 <strong>gdb</strong> 配合，调试性能问题和内存泄漏。</li>\n</ul>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a><strong>性能优化</strong></h3><ul>\n<li>优化内存使用，减少内存分配开销。</li>\n<li>通过 <code>CPU profiler</code> 定位 CPU 瓶颈函数，优化代码热点。</li>\n<li>使用 <code>Heap Profiler</code> 分析程序内存消耗，减少不必要的内存分配。</li>\n</ul>\n<h2 id=\"五、工作原理与源码分析\"><a href=\"#五、工作原理与源码分析\" class=\"headerlink\" title=\"五、工作原理与源码分析\"></a>五、工作原理与源码分析</h2><h3 id=\"tcmalloc\"><a href=\"#tcmalloc\" class=\"headerlink\" title=\"tcmalloc\"></a>tcmalloc</h3><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>tcmalloc是google开发的一个专门为高并发场景优化的内存分配器，全称为”thread cache malloc”。按照<a href=\"http://goog-perftools.sourceforge.net/doc/tcmalloc.html\">官网</a>的介绍，tcmalloc相比于glibc2.3的malloc(底层实现为ptmalloc2)主要有以下优点：</p>\n<ol>\n<li>快速：一台2.8GHz的P4机器上，执行一次malloc及free大约需要300纳秒;而tcmalloc的版本同样的操作大约只需要50纳秒。</li>\n<li>空间占用小：相比ptmalloc2，tcmalloc对小对象占用空间进行了优化。例如：分配N个8字节对象只需要占用8N<em>1.01字节的空间。即，只需要多使用1%的空间。而ptmalloc2中每个对象都需要使用一个4字节的头信息，最后占用的字节可能达到8N</em>8。</li>\n<li>不容易出现内存暴涨</li>\n</ol>\n<h4 id=\"替换原理\"><a href=\"#替换原理\" class=\"headerlink\" title=\"替换原理\"></a>替换原理</h4><p>glibc中的memory-allocation方法均被为声明为<a href=\"https://en.wikipedia.org/wiki/Weak_symbol\">弱符号</a>，只需要在tcmalloc中将其重新定义即可。 具体的重新定义代码在src&#x2F;libc_override*.h中(不同平台实现不同)，下面是Linux平台下部分memory-allocation函数的重新定义实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span>                  </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tc_new</span>(size);       &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span> __THROW            </span>&#123; <span class=\"hljs-built_in\">tc_delete</span>(p);              &#125;<br><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">new</span>[](<span class=\"hljs-type\">size_t</span> size)                &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tc_newarray</span>(size);  &#125;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">delete</span>[](<span class=\"hljs-type\">void</span>* p) __THROW          &#123; <span class=\"hljs-built_in\">tc_deletearray</span>(p);         &#125;<br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">malloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> s)</span> __THROW                 </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tc_malloc</span>(s);       &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title\">free</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span> __THROW                    </span>&#123; <span class=\"hljs-built_in\">tc_free</span>(p);                &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">realloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p, <span class=\"hljs-type\">size_t</span> s)</span> __THROW       </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tc_realloc</span>(p, s);   &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">calloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> n, <span class=\"hljs-type\">size_t</span> s)</span> __THROW       </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tc_calloc</span>(n, s);    &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title\">cfree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span> __THROW                   </span>&#123; <span class=\"hljs-built_in\">tc_cfree</span>(p);               &#125;<br>&#125;  <span class=\"hljs-comment\">// extern &quot;C&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"整体结构\"><a href=\"#整体结构\" class=\"headerlink\" title=\"整体结构\"></a>整体结构</h4><p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518171450479.png\" alt=\"结构图\"></p>\n<p>上图展示了tcmalloc的整体结构, tcmalloc主要由三个组件组成：ThreadCache、CentralFreeList及PageHeap。 其中：</p>\n<ul>\n<li>ThreadCache: 线程缓存，它是一个TSL(线程本地存储)对象，尺寸小于256K的小内存申请均由ThreadCache进行分配；通过ThreadCache分配过程中不需要任何锁，可以极大的提高分配速度</li>\n<li>PageHeap: 中央堆分配器，被所有线程共享(分配时需要全局锁定)，负责与操作系统的直接交互(申请及释放内存)，并且大尺寸的内存申请直接通过PageHeap进行分配</li>\n<li>CentralFreeList：作为PageHeap与ThreadCache的中间人，负责<ol>\n<li>将PageHeap中的内存切分为小块，在恰当时机分配给ThreadCache。</li>\n<li>获取从ThreadCache中回收的内存并在恰当的时机将部分内存归还给PageHeap</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"核心思想：Segregated-Free-List-离散式空闲列表\"><a href=\"#核心思想：Segregated-Free-List-离散式空闲列表\" class=\"headerlink\" title=\"核心思想：Segregated Free List(离散式空闲列表)\"></a>核心思想：Segregated Free List(离散式空闲列表)</h4><p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518171727566.png\" alt=\"结构图\"></p>\n<h5 id=\"小内存分配：ThreadCache\"><a href=\"#小内存分配：ThreadCache\" class=\"headerlink\" title=\"小内存分配：ThreadCache\"></a>小内存分配：ThreadCache</h5><p>tcmalloc实现中，每个thread独立维护了各自的离散式空闲列表，它的核心结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FreeList</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br> <span class=\"hljs-type\">void</span>*    list_;<br> <span class=\"hljs-type\">uint32_t</span> length_;<br> <span class=\"hljs-type\">uint32_t</span> lowater_;<br> <span class=\"hljs-type\">uint32_t</span> max_length_;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ThreadCache</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>     FreeList      list_[kNumClasses];    <br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<pre><code class=\" mermaid\">flowchart TD\n    A[请求分配小内存] --&gt; B[通过 SizeMap 获取 size class 和 object size]\n    B --&gt; C&#123;ThreadCache 中的 free list 是否为空？&#125;\n    C -- 是 --&gt; D[从 free list 中取出第一个 object 返回]\n    C -- 否 --&gt; E[从 CentralFreeList 获取若干 object]\n    E --&gt; F[取出一个 object 返回，剩下的放入 ThreadCache]\n    E --&gt; G&#123;CentralFreeList 是否也不够？&#125;\n    G -- 是 --&gt; H[CentralFreeList 向 PageHeap 申请一串页面（Span）]\n    H --&gt; I[切割页面为多个 object]\n    I --&gt; J[将部分 object 转移给 ThreadCache]\n    J --&gt; F\n    G -- 否 --&gt; F\n</code></pre>\n\n<h5 id=\"大内存分配：PageHeap\"><a href=\"#大内存分配：PageHeap\" class=\"headerlink\" title=\"大内存分配：PageHeap\"></a>大内存分配：PageHeap</h5><p>PageHeap的职能之一是向操作系统申请内存，与大多数现代分配器一样，tcmalloc使用基于页的分配方式，即每次至少像系统申请1页空间。tcmalloc中定义的页大小为8K个字节(多数linux系统中一页大小为4K字节，也就是说tcmalloc中的一页对应linux中两页)。 虽然PageHeap是按页申请内存，但是它管理内存的基本单位为Span(跨度)，Span对象代表了表示连续的页面。 如下图所示，分别有a，b，c，d四个Span；a占据了2个页面，b占据了1个页面，c占据了4个页面，d占据了3个页面。</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518172159207.png\" alt=\"结构图\"></p>\n<p>下面是Span的定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Span</span> &#123;<br>  PageID        start;          <span class=\"hljs-comment\">// Span描述的内存的起始地址</span><br>  Length        length;         <span class=\"hljs-comment\">// Span页面数量</span><br>  Span*         next;           <span class=\"hljs-comment\">// Span由双向链表组成，PageHeap和CentralFreeList中都用的到</span><br>  Span*         prev;           <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-type\">void</span>*         objects;        <span class=\"hljs-comment\">// Span会在CentralFreeList中拆分成由object组成的free list</span><br>  <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>  refcount : <span class=\"hljs-number\">16</span>;  <span class=\"hljs-comment\">// Span的object被引用次数，当refcount=0时，表示此Span没有被使用</span><br>  <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>  sizeclass : <span class=\"hljs-number\">8</span>;  <span class=\"hljs-comment\">// Span属于的size class</span><br>  <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>  location : <span class=\"hljs-number\">2</span>;   <span class=\"hljs-comment\">// Span在的位置IN_USE？normal？returned？</span><br>  <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>  sample : <span class=\"hljs-number\">1</span>;     <span class=\"hljs-comment\">// Sampled object?</span><br>  <span class=\"hljs-comment\">// What freelist the span is on: IN_USE if on none, or normal or returned</span><br>  <span class=\"hljs-keyword\">enum</span> &#123; IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>来看下PageHeap的主要结构及示意图：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">PageMap pagemap_; <span class=\"hljs-comment\">// page id 到 Span的映射</span><br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SpanList</span> &#123;<br>   Span        normal;<br>   Span        returned;<br>&#125;;<br><br>SpanList large_;<br><br>SpanList free_[kMaxPages]; <span class=\"hljs-comment\">// kMaxPages = 128</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518172237981.png\" alt=\"结构图\"></p>\n<h5 id=\"中间人：CentralFreeList\"><a href=\"#中间人：CentralFreeList\" class=\"headerlink\" title=\"中间人：CentralFreeList\"></a>中间人：CentralFreeList</h5><p>tcmalloc为每个size class设置设置了一个CentralFreeList(中央自由列表)，ThreadCache之间共享这些CentralFreeList</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">static</span> CentralFreeListPadded central_cache_[kNumClasses];<br> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CentralFreeList</span> &#123;<br> <span class=\"hljs-keyword\">private</span>:<br>     SpinLock lock_;<br>     <span class=\"hljs-type\">size_t</span> size_class_;<br>     Span empty_;       <br>     Span nonempty_;<br> &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>作为中间人，CentralFreeList的功能之一就是从PageHeap中取出部分Span并按照预定大小(SizeMap中定义)将其拆分成大小固定的object供ThreadCache共享；</p>\n<pre><code class=\" mermaid\">flowchart TD\n  A[从 PageHeap 获取 Span] --&gt; B[RegisterSizeClass&lt;br/&gt;设置location和sizeclass]\n  B --&gt; C[Span 切分为 objects&lt;br/&gt;挂到 Span::objects 链表]\n  C --&gt; D[挂到 CentralFreeList::nonempty_]\n\n  E[ThreadCache 请求 object] --&gt; F[从 nonempty_ Span 取 object]\n  F --&gt; G[refcount += 1]\n\n  F --&gt;|Span 空| H[从 nonempty_ 移除&lt;br/&gt;挂到 empty_]\n\n  I[ThreadCache 归还 object] --&gt; J[添加 object 到 Span::objects]\n  J --&gt; K[refcount -= 1]\n\n  K --&gt;|refcount == 0| L[&quot;从链表移除&lt;br/&gt;PageHeap::Delete(Span)&quot;]\n  K --&gt;|Span 在 empty_| M[挂回 nonempty_]\n</code></pre>\n\n\n\n<pre><code class=\" mermaid\">sequenceDiagram\n  participant CentralFreeList\n  participant PageHeap\n  participant Span\n  participant ThreadCache\n\n  Note over CentralFreeList: 从 PageHeap 获取 Span\n  CentralFreeList-&gt;&gt;PageHeap: Request Span\n  PageHeap--&gt;&gt;CentralFreeList: Return Span\n  CentralFreeList-&gt;&gt;Span: RegisterSizeClass (location=IN_USE, sizeclass=X)\n  CentralFreeList-&gt;&gt;Span: Split Span into objects (free list)\n  CentralFreeList-&gt;&gt;CentralFreeList: Add Span to nonempty_ list\n\n  Note over ThreadCache: 从 CentralFreeList 分配 object\n  ThreadCache-&gt;&gt;CentralFreeList: Request object\n  CentralFreeList-&gt;&gt;Span: Get object from free list\n  Span-&gt;&gt;Span: refcount++\n\n  alt No object left in Span\n    CentralFreeList-&gt;&gt;CentralFreeList: Move Span to empty_ list\n  end\n\n  Note over ThreadCache: 归还 object 给 CentralFreeList\n  ThreadCache-&gt;&gt;CentralFreeList: Return object\n  CentralFreeList-&gt;&gt;Span: Add object back to free list\n  Span-&gt;&gt;Span: refcount--\n\n  alt refcount == 0\n    CentralFreeList-&gt;&gt;CentralFreeList: Remove Span from list\n    CentralFreeList-&gt;&gt;PageHeap: Delete(Span)\n  else Span in empty_\n    CentralFreeList-&gt;&gt;CentralFreeList: Move Span to nonempty_ list\n  end\n</code></pre>\n\n<h3 id=\"cpu-profiler\"><a href=\"#cpu-profiler\" class=\"headerlink\" title=\"cpu profiler\"></a>cpu profiler</h3><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>这是最初由 Google 开发的 CPU 分析器。使用方法分为三个部分：将库链接到应用程序、运行代码以及分析输出。</p>\n<h4 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h4><pre><code class=\" mermaid\">flowchart TD\n    Start([程序开始运行])\n    InitProfiler[初始化 Profiler&lt;br&gt;（ProfilerStart）]\n    SetupSignal[设置定时器&lt;br&gt;定期触发 SIGPROF 信号]\n    InstallHandler[安装 SIGPROF 的信号处理器&lt;br&gt;（ProfilerSignalHandler）]\n    Wait[程序继续运行，等待采样时刻]\n    OnSignal[定时器触发 SIGPROF 信号]\n    GetPC[信号处理器中获取当前函数调用地址&lt;br&gt;使用 backtrace 等方法]\n    RecordSample[记录当前调用栈&lt;br&gt;写入 profile 数据结构]\n    WriteToFile[周期性写入 profile 数据文件]\n    StopProfiler[ProfilerStop 停止分析，关闭文件]\n    End([程序结束运行])\n\n    Start --&gt; InitProfiler --&gt; SetupSignal --&gt; InstallHandler --&gt; Wait\n    Wait --&gt; OnSignal --&gt; GetPC --&gt; RecordSample --&gt; Wait\n    RecordSample --&gt; WriteToFile --&gt; Wait\n    Wait --&gt; StopProfiler --&gt; End\n  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n</code></pre>\n\n<h4 id=\"关键源码\"><a href=\"#关键源码\" class=\"headerlink\" title=\"关键源码\"></a>关键源码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 启动 CPU Profiler，采样逻辑主入口</span><br><span class=\"hljs-keyword\">extern</span> “C” <span class=\"hljs-function\">PERFTOOLS_DLL_DECL <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">ProfilerStart</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* fname)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> CpuProfiler::instance_.<span class=\"hljs-built_in\">Start</span>(fname, <span class=\"hljs-literal\">NULL</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">CpuProfiler::Start</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* fname, <span class=\"hljs-type\">const</span> ProfilerOptions* options)</span> </span>&#123;<br>    collector_.<span class=\"hljs-built_in\">Start</span>(fname, collector_options);<br>    <span class=\"hljs-comment\">// Setup handler for SIGPROF interrupts</span><br>    <span class=\"hljs-built_in\">EnableHandler</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><span class=\"hljs-comment\">// 初始化数据收集需要的数据结构</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">ProfileData::Start</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* fname, <span class=\"hljs-type\">const</span> ProfileData::Options&amp; options)</span> </span>&#123;<br> <br>    <span class=\"hljs-comment\">// Open output file and initialize various data structures</span><br>    <span class=\"hljs-type\">int</span> fd =<span class=\"hljs-built_in\">open</span>(fname, O_CREAT | O_WRONLY | O_TRUNC, <span class=\"hljs-number\">0666</span>);<br>    start_time_ = <span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">NULL</span>);<br>    fname_ = <span class=\"hljs-built_in\">strdup</span>(fname);<br> <br>    <span class=\"hljs-comment\">// Reset counters</span><br>    num_evicted_ = <span class=\"hljs-number\">0</span>;<br>    count_ = <span class=\"hljs-number\">0</span>;<br>    evictions_ = <span class=\"hljs-number\">0</span>;<br>    total_bytes_ = <span class=\"hljs-number\">0</span>;<br> <br>    hash_ = <span class=\"hljs-keyword\">new</span> Bucket[kBuckets];<br>    evict_ = <span class=\"hljs-keyword\">new</span> Slot[kBufferLength];<br>    <span class=\"hljs-built_in\">memset</span>(hash_, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(hash_[<span class=\"hljs-number\">0</span>]) * kBuckets);<br> <br>    <span class=\"hljs-comment\">// Record special entries</span><br>    evict_[num_evicted_++] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// count for header</span><br>    evict_[num_evicted_++] = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// depth for header</span><br>    evict_[num_evicted_++] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Version number</span><br>    <span class=\"hljs-built_in\">CHECK_NE</span>(<span class=\"hljs-number\">0</span>, options.<span class=\"hljs-built_in\">frequency</span>());<br>    <span class=\"hljs-type\">int</span> period =<span class=\"hljs-number\">1000000</span>/ options.<span class=\"hljs-built_in\">frequency</span>();<br>    evict_[num_evicted_++] = period; <span class=\"hljs-comment\">// Period (microseconds)</span><br>    evict_[num_evicted_++] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Padding</span><br>    out_ = fd;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 把prof_handler这个函数注册到了某个地方</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CpuProfiler::EnableHandler</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    prof_handler_token_ = <span class=\"hljs-built_in\">ProfileHandlerRegisterCallback</span>(prof_handler, <span class=\"hljs-keyword\">this</span>);<br>&#125;<br><span class=\"hljs-function\">ProfileHandlerToken* <span class=\"hljs-title\">ProfileHandlerRegisterCallback</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    ProfileHandlerCallback callback, <span class=\"hljs-type\">void</span>* callback_arg)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> ProfileHandler::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">RegisterCallback</span>(callback, callback_arg);<br>&#125;<br><span class=\"hljs-comment\">// 根据环境变量CPUPROFILE_REALTIME的配置，来决定让SIGPROF还是SIGALRM信号来触发SignalHandler信号处理函数，并根据环境变量CPUPROFILE_FREQUENCY的配置来设置自己的一个频率变量 frequency_</span><br>ProfileHandler::<span class=\"hljs-built_in\">ProfileHandler</span>() &#123;<br> <br>    timer_type_ = (<span class=\"hljs-built_in\">getenv</span>(“CPUPROFILE_REALTIME”) ? ITIMER_REAL : ITIMER_PROF);<br>    signal_number_ = (timer_type_ == ITIMER_PROF ? SIGPROF : SIGALRM);<br> <br>    <span class=\"hljs-comment\">// Get frequency of interrupts (if specified)</span><br>    <span class=\"hljs-type\">char</span> junk;<br>    constchar* fr =<span class=\"hljs-built_in\">getenv</span>(“CPUPROFILE_FREQUENCY”);<br> <br>    <span class=\"hljs-keyword\">if</span> (fr != <span class=\"hljs-literal\">NULL</span> &amp;&amp; (<span class=\"hljs-built_in\">sscanf</span>(fr, <span class=\"hljs-string\">&quot;%u%c&quot;</span>, &amp;frequency_, &amp;junk) == <span class=\"hljs-number\">1</span>) &amp;&amp; (frequency_ &gt; <span class=\"hljs-number\">0</span>)) &#123;<br>        <span class=\"hljs-comment\">// Limit to kMaxFrequency</span><br>        frequency_ = (frequency_ &gt; kMaxFrequency) ? kMaxFrequency : frequency_;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        frequency_ = kDefaultFrequency;<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// Install the signal handler.</span><br>    structsigaction sa;<br>    sa.sa_sigaction = SignalHandler;<br>    sa.sa_flags = SA_RESTART | SA_SIGINFO;<br>    <span class=\"hljs-built_in\">sigemptyset</span>(&amp;sa.sa_mask);<br>    <span class=\"hljs-built_in\">sigaction</span>(signal_number_, &amp;sa, <span class=\"hljs-literal\">NULL</span>);<br>&#125;<br><span class=\"hljs-comment\">// 加入第一个callback的时候调用StartTimer（）函数来启动定时器，然后调用EnableHander函数来开启回调</span><br><span class=\"hljs-function\">ProfileHandlerToken* <span class=\"hljs-title\">ProfileHandler::RegisterCallback</span><span class=\"hljs-params\">(ProfileHandlerCallback callback, <span class=\"hljs-type\">void</span>* callback_arg)</span> </span>&#123;<br> <br>    ProfileHandlerToken* token = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ProfileHandlerToken</span>(callback, callback_arg);<br>    <span class=\"hljs-function\">SpinLockHolder <span class=\"hljs-title\">cl</span><span class=\"hljs-params\">(&amp;control_lock_)</span></span>;<br>    <span class=\"hljs-built_in\">DisableHandler</span>();<br>    &#123;<br>        <span class=\"hljs-function\">SpinLockHolder <span class=\"hljs-title\">sl</span><span class=\"hljs-params\">(&amp;signal_lock_)</span></span>;<br>        callbacks_.<span class=\"hljs-built_in\">push_back</span>(token);<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// Start the timer if timer is shared and this is a first callback.</span><br>    <span class=\"hljs-keyword\">if</span> ((callback_count_ == <span class=\"hljs-number\">0</span>) &amp;&amp; (timer_sharing_ == TIMERS_SHARED)) &#123;<br>        <span class=\"hljs-built_in\">StartTimer</span>();<br>    &#125;<br>    ++callback_count_;<br>    <span class=\"hljs-built_in\">EnableHandler</span>();<br>    <span class=\"hljs-keyword\">return</span> token;<br>&#125;<br><span class=\"hljs-comment\">// </span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ProfileHandler::StartTimer</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">itimerval</span> timer;<br>    timer.it_interval.tv_sec = <span class=\"hljs-number\">0</span>;<br>    timer.it_interval.tv_usec = <span class=\"hljs-number\">1000000</span> / frequency_;<br>    timer.it_value = timer.it_interval;<br>    <span class=\"hljs-built_in\">setitimer</span>(timer_type_, &amp;timer, <span class=\"hljs-number\">0</span>);<br>&#125;<br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ProfileHandler::EnableHandler</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sigaction</span> sa;<br>    sa.sa_sigaction = SignalHandler;<br>    sa.sa_flags = SA_RESTART | SA_SIGINFO;<br>    <span class=\"hljs-built_in\">sigemptyset</span>(&amp;sa.sa_mask);<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> signal_number = (timer_type_ == ITIMER_PROF ? SIGPROF : SIGALRM);<br>    <span class=\"hljs-built_in\">RAW_CHECK</span>(<span class=\"hljs-built_in\">sigaction</span>(signal_number, &amp;sa, <span class=\"hljs-literal\">NULL</span>) == <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;sigprof (enable)&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"heap-profiler\"><a href=\"#heap-profiler\" class=\"headerlink\" title=\"heap profiler\"></a>heap profiler</h3><h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>Heap Profiling 通常指对应用程序的堆分配进行收集或采样，来向我们报告程序的内存使用情况，以便分析内存占用原因或定位内存泄漏根源。</p>\n<h4 id=\"工作流程-1\"><a href=\"#工作流程-1\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h4><p><strong>Heap Profile 的 stack trace + statistics 数据模型与 CPU Proflie 是一致的</strong>。</p>\n<pre><code class=\" mermaid\">flowchart TD\n    A[&quot;HeapProfilerStart()&quot;] --&gt; B[初始化采样参数与文件输出路径]\n    B --&gt; C[注册 malloc/free hook]\n    C --&gt; D[用户程序 malloc]\n    D --&gt; E&#123;是否触发采样?&#125;:::important\n\n    E -- 否 --&gt; F[正常 malloc]\n    E -- 是 --&gt; G[记录采样信息]\n    \n    G --&gt; H[获取调用栈 stacktrace]\n    H --&gt; I[记录 size + stacktrace 到 ProfileTable]\n    I --&gt; J[继续 malloc 执行]\n    \n    J --&gt; K[用户程序运行中多次采样]\n\n    K --&gt; L[&quot;HeapProfilerDump() 或 Stop()&quot;]\n    L --&gt; M[导出 .heap 文件]\n    M --&gt; N[使用 pprof 工具进行分析]\nclassDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n</code></pre>\n\n\n\n<h4 id=\"关键源码-1\"><a href=\"#关键源码-1\" class=\"headerlink\" title=\"关键源码\"></a>关键源码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 启动入口</span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">HeapProfilerStart</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* prefix)</span> </span>&#123;<br>  (<span class=\"hljs-type\">void</span>)tcmalloc::<span class=\"hljs-built_in\">GetProgramInvocationName</span>();<br>  <span class=\"hljs-function\">SpinLockHolder <span class=\"hljs-title\">l</span><span class=\"hljs-params\">(&amp;heap_lock)</span></span>;<br>  <span class=\"hljs-keyword\">if</span> (is_on) <span class=\"hljs-keyword\">return</span>;<br>  is_on = <span class=\"hljs-literal\">true</span>;<br>  <span class=\"hljs-built_in\">RAW_VLOG</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;Starting tracking the heap&quot;</span>);<br>    <br>  MallocExtension::<span class=\"hljs-built_in\">Initialize</span>();<br>  heap_profiler_memory = LowLevelAlloc::<span class=\"hljs-built_in\">NewArena</span>();<br>  heap_profile = <span class=\"hljs-built_in\">new</span>(<span class=\"hljs-built_in\">ProfilerMalloc</span>(<span class=\"hljs-built_in\">sizeof</span>(HeapProfileTable)))<br>      <span class=\"hljs-built_in\">HeapProfileTable</span>(ProfilerMalloc, ProfilerFree);<br><br>  last_dump_alloc = <span class=\"hljs-number\">0</span>;<br>  last_dump_free = <span class=\"hljs-number\">0</span>;<br>  high_water_mark = <span class=\"hljs-number\">0</span>;<br>  last_dump_time = <span class=\"hljs-number\">0</span>;<br>    <br>  <span class=\"hljs-comment\">// Now set the hooks that capture new/delete and malloc/free.</span><br>  <span class=\"hljs-built_in\">RAW_CHECK</span>(MallocHook::<span class=\"hljs-built_in\">AddNewHook</span>(&amp;NewHook), <span class=\"hljs-string\">&quot;&quot;</span>);<br>  <span class=\"hljs-built_in\">RAW_CHECK</span>(MallocHook::<span class=\"hljs-built_in\">AddDeleteHook</span>(&amp;DeleteHook), <span class=\"hljs-string\">&quot;&quot;</span>);<br>  ……<br>&#125;<br><span class=\"hljs-comment\">// tcmalloc 在 malloc() 和 operator new 中增加了一些采样逻辑，当根据条件触发采样 hook 时，会执行以下函数</span><br><span class=\"hljs-comment\">// Record an allocation in the profile.</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">RecordAlloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* ptr, <span class=\"hljs-type\">size_t</span> bytes, <span class=\"hljs-type\">int</span> skip_count)</span> </span>&#123;<br>  <span class=\"hljs-comment\">// Take the stack trace outside the critical section.</span><br><span class=\"hljs-type\">void</span>* stack[HeapProfileTable::kMaxStackDepth];<br>  <span class=\"hljs-type\">int</span> depth = HeapProfileTable::<span class=\"hljs-built_in\">GetCallerStackTrace</span>(skip_count + <span class=\"hljs-number\">1</span>, stack);<br>  <span class=\"hljs-function\">SpinLockHolder <span class=\"hljs-title\">l</span><span class=\"hljs-params\">(&amp;heap_lock)</span></span>;<br>  <span class=\"hljs-keyword\">if</span> (is_on) &#123;<br>    heap_profile-&gt;<span class=\"hljs-built_in\">RecordAlloc</span>(ptr, bytes, depth, stack);<br>    <span class=\"hljs-built_in\">MaybeDumpProfileLocked</span>();<br>  &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">HeapProfileTable::RecordAlloc</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* ptr, <span class=\"hljs-type\">size_t</span> bytes, <span class=\"hljs-type\">int</span> stack_depth,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-type\">const</span> call_stack[])</span> </span>&#123;<br>  Bucket* b = <span class=\"hljs-built_in\">GetBucket</span>(stack_depth, call_stack);<br>  b-&gt;allocs++;<br>  b-&gt;alloc_size += bytes;<br>  total_.allocs++;<br>  total_.alloc_size += bytes;<br>  AllocValue v;<br>  v.<span class=\"hljs-built_in\">set_bucket</span>(b);  <span class=\"hljs-comment\">// also did set_live(false); set_ignore(false)</span><br>  v.bytes = bytes;<br>  address_map_-&gt;<span class=\"hljs-built_in\">Insert</span>(ptr, v);<br>&#125;<br><span class=\"hljs-comment\">// 在 free() 或 operator delete 中同样需要增加一些逻辑来记录内存释放情况</span><br><span class=\"hljs-comment\">// Record a deallocation in the profile.</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">RecordFree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* ptr)</span> </span>&#123;<br>  <span class=\"hljs-function\">SpinLockHolder <span class=\"hljs-title\">l</span><span class=\"hljs-params\">(&amp;heap_lock)</span></span>;<br>  <span class=\"hljs-keyword\">if</span> (is_on) &#123;<br>    heap_profile-&gt;<span class=\"hljs-built_in\">RecordFree</span>(ptr);<br>    <span class=\"hljs-built_in\">MaybeDumpProfileLocked</span>();<br>  &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">HeapProfileTable::RecordFree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* ptr)</span> </span>&#123;<br>  AllocValue v;<br>  <span class=\"hljs-keyword\">if</span> (address_map_-&gt;<span class=\"hljs-built_in\">FindAndRemove</span>(ptr, &amp;v)) &#123;<br>    Bucket* b = v.<span class=\"hljs-built_in\">bucket</span>();<br>    b-&gt;frees++;<br>    b-&gt;free_size += v.bytes;<br>    total_.frees++;<br>    total_.free_size += v.bytes;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 调用 GetCallerStackTrace() 获取调用栈。</span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">MallocHook_GetCallerStackTrace</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>** result, <span class=\"hljs-type\">int</span> max_depth,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                                              <span class=\"hljs-type\">int</span> skip_count)</span> </span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(NO_TCMALLOC_SAMPLES)</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>  <span class=\"hljs-keyword\">if</span> (max_depth &lt; <span class=\"hljs-number\">1</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-type\">int</span> retval = tcmalloc::<span class=\"hljs-built_in\">GrabBacktrace</span>(result, max_depth, skip_count);<br>  <span class=\"hljs-comment\">// prevent tail-call above</span><br>  *(<span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">volatile</span> *)result;<br>  <span class=\"hljs-keyword\">return</span> retval;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br><span class=\"hljs-comment\">// </span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"六、实战案例与分析\"><a href=\"#六、实战案例与分析\" class=\"headerlink\" title=\"六、实战案例与分析\"></a>六、实战案例与分析</h2><h3 id=\"案例-1：使用-tcmalloc-优化内存\"><a href=\"#案例-1：使用-tcmalloc-优化内存\" class=\"headerlink\" title=\"案例 1：使用 tcmalloc 优化内存\"></a><strong>案例 1：使用 tcmalloc 优化内存</strong></h3><ul>\n<li>比较 <code>malloc</code> 和 <code>tcmalloc</code> 在高频次分配下的性能差异。</li>\n<li>分析内存碎片、内存占用的变化。</li>\n</ul>\n<h3 id=\"案例-2：使用-CPU-Profiler-分析热点\"><a href=\"#案例-2：使用-CPU-Profiler-分析热点\" class=\"headerlink\" title=\"案例 2：使用 CPU Profiler 分析热点\"></a><strong>案例 2：使用 CPU Profiler 分析热点</strong></h3><ul>\n<li>编写一个包含复杂运算的程序，用 <code>CPU Profiler</code> 查找 CPU 使用的瓶颈函数。</li>\n<li>使用火焰图进行可视化分析，优化计算热点。</li>\n</ul>\n<h3 id=\"案例-3：内存泄漏定位与修复\"><a href=\"#案例-3：内存泄漏定位与修复\" class=\"headerlink\" title=\"案例 3：内存泄漏定位与修复\"></a><strong>案例 3：内存泄漏定位与修复</strong></h3><ul>\n<li>故意写一个内存泄漏示例，使用 <code>Heap Profiler</code> 进行检测，定位泄漏源并修复。</li>\n</ul>\n<h2 id=\"七、常见问题与坑\"><a href=\"#七、常见问题与坑\" class=\"headerlink\" title=\"七、常见问题与坑\"></a>七、常见问题与坑</h2><ul>\n<li><strong>性能开销</strong>：启用 <code>gperftools</code> 后会带来一定的性能开销，尤其是在高负载时。要注意选择合适的 profiling 级别。</li>\n<li><strong>与其他库的兼容性</strong>：某些情况下，<code>tcmalloc</code> 与第三方库的内存分配可能会发生冲突，需要根据具体情况选择关闭。</li>\n<li><strong>内存泄漏的误报</strong>：<code>Heap Profiler</code> 有时会报告不准确的内存泄漏，需要结合代码逐步排查。</li>\n</ul>\n<h2 id=\"八、总结与心得\"><a href=\"#八、总结与心得\" class=\"headerlink\" title=\"八、总结与心得\"></a>八、总结与心得</h2><ul>\n<li><strong>优点</strong>：<ul>\n<li>高效的内存管理，适合高性能应用。</li>\n<li>支持详细的性能分析，帮助定位 CPU 和内存瓶颈。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：<ul>\n<li>使用时有性能开销，建议仅在开发和调试阶段启用。</li>\n<li>配置较为复杂，需要一定的学习曲线。</li>\n</ul>\n</li>\n<li><strong>实用性</strong>：<ul>\n<li>在高性能要求的 C++ 项目中使用 <code>gperftools</code>，可以大幅提升内存管理效率和 CPU 性能。</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"gperftools（Google-提供的开源性能优化工具集）\"><a href=\"#gperftools（Google-提供的开源性能优化工具集）\" class=\"headerlink\" title=\"gperftools（Google 提供的开源性能优化工具集）\"></a>gperftools（Google 提供的开源性能优化工具集）</h1><h2 id=\"一、工具概览\"><a href=\"#一、工具概览\" class=\"headerlink\" title=\"一、工具概览\"></a>一、工具概览</h2><h3 id=\"什么是-gperftools？\"><a href=\"#什么是-gperftools？\" class=\"headerlink\" title=\"什么是 gperftools？\"></a>什么是 gperftools？</h3><ul>\n<li>gperftools 是 Google 提供的开源性能优化工具集，主要用于性能分析和内存管理。</li>\n<li>包括 <code>tcmalloc</code>（高效的内存分配器）和 <code>cpu profiler</code>（CPU 性能分析器）。</li>\n</ul>\n<h3 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><ul>\n<li><strong>tcmalloc</strong>：优化的内存分配器，替代标准的 <code>malloc</code>。</li>\n<li><strong>cpu profiler</strong>：通过性能采样记录 <strong>CPU 使用情况</strong>，生成火焰图（flame graph）。</li>\n<li><strong>heap profiler</strong>：分析程序的堆内存使用，检测内存泄漏和过度使用。</li>\n</ul>\n<h2 id=\"二、安装与配置\"><a href=\"#二、安装与配置\" class=\"headerlink\" title=\"二、安装与配置\"></a>二、安装与配置</h2><h3 id=\"安装方式\"><a href=\"#安装方式\" class=\"headerlink\" title=\"安装方式\"></a><strong>安装方式</strong></h3><ul>\n<li><p>使用 <code>apt</code>（Ubuntu）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">sudo</span> apt-get install google-perftools libgoogle-perftools-dev<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>使用 <code>brew</code>（macOS）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">brew install gperftools<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>编译源码：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/gperftools/gperftools.git<br><span class=\"hljs-built_in\">cd</span> gperftools<br>./configure<br>make<br><span class=\"hljs-built_in\">sudo</span> make install<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a><strong>配置环境</strong></h3><ul>\n<li><p>环境变量设置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> LD_PRELOAD=/usr/local/lib/libtcmalloc.so<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"三、常用工具与命令\"><a href=\"#三、常用工具与命令\" class=\"headerlink\" title=\"三、常用工具与命令\"></a>三、常用工具与命令</h2><h3 id=\"1-tcmalloc（内存分配器）\"><a href=\"#1-tcmalloc（内存分配器）\" class=\"headerlink\" title=\"1. tcmalloc（内存分配器）\"></a>1. tcmalloc（内存分配器）</h3><ul>\n<li>作用：提高内存分配与释放效率，减少内存碎片。</li>\n<li>使用：<ul>\n<li>在应用中通过设置 <code>LD_PRELOAD</code> 来加载 <code>libtcmalloc</code>。</li>\n<li>用 <code>gperftools</code> 编译的程序会自动使用 <code>tcmalloc</code>，无须修改代码。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-CPU-Profiler（CPU-性能分析）\"><a href=\"#2-CPU-Profiler（CPU-性能分析）\" class=\"headerlink\" title=\"2. CPU Profiler（CPU 性能分析）\"></a>2. CPU Profiler（CPU 性能分析）</h3><h4 id=\"启用\"><a href=\"#启用\" class=\"headerlink\" title=\"启用\"></a>启用</h4><ul>\n<li><p>编译时使用 <code>-lprofiler</code> 链接 profiler 库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># LD_PRELOAD 设置加载libprofiler.so</span><br><span class=\"hljs-comment\"># CPUPROFILE 设置采样文件</span><br><span class=\"hljs-comment\"># CPUPROFILE_FREQUENCY 设置采样频率，默认100</span><br><span class=\"hljs-comment\"># 强行结束不能获得采样文件 CPUPROFILESIGNAL设置采样开关信号，关闭采样只需要killall -12 perftest</span><br>LD_PRELOAD=/usr/local/lib/libprofiler.so CPUPROFILE=data.prof CPUPROFILE_FREQUENCY=555 CPUPROFILESIGNAL=12 ./perftest --benchmark_min_time=10000x <br></code></pre></td></tr></table></figure>\n</li>\n<li><p>在代码中启动&#x2F;停止 profiling：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 精确控制代码采样的区域</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;gperftools/profiler.h&gt;</span></span><br><span class=\"hljs-built_in\">ProfilerStart</span>(<span class=\"hljs-string\">&quot;data.prof&quot;</span>);<br><span class=\"hljs-comment\">// 你的代码</span><br><span class=\"hljs-built_in\">ProfilerStop</span>();<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li><p>使用 <code>pprof</code> 或<code>google-pprof</code>工具解析生成的 <code>data.prof</code> 文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pprof --text ./your_program data.prof<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429163444540.png\" alt=\"image-20250429163444432\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 每一列含义分析，以红框为例</span><br><span class=\"hljs-comment\"># 函数中的样本数\t函数中样本百分比\t当前打印的样本百分比\t函数以及其调用函数中的样本数量\t函数以及其调用子函数中的样本百分比\t函数名</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>还可以加入<code>--stackes</code>选项打印调用栈</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pprof --text --stacks ./your_program data.prof<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429164022560.png\" alt=\"image-20250429164022498\"></p>\n</li>\n<li><p>发现这样不够直观，可以用<code>--svg</code>生成调用图更加直观</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pprof --svg ./your_program ./data.prof &gt; svgout.svg<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250429164316052.png\" alt=\"image-20250429164315976\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 结果分析</span><br><span class=\"hljs-comment\"># 第一行类名</span><br><span class=\"hljs-comment\"># 第二行函数名</span><br><span class=\"hljs-comment\"># 本函数执行执行的时间（直接执行的时间）</span><br><span class=\"hljs-comment\"># 本函数调用函数执行的时间（调用其他函数的时间）</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>可以生成火焰图：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pprof --flame ./your_program data.prof<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"3-Heap-Profiler（堆内存分析）\"><a href=\"#3-Heap-Profiler（堆内存分析）\" class=\"headerlink\" title=\"3. Heap Profiler（堆内存分析）\"></a>3. Heap Profiler（堆内存分析）</h3><ul>\n<li><p>启用：</p>\n<ul>\n<li><p>编译时使用 <code>-lprofiler</code>。</p>\n</li>\n<li><p>运行时启用 heap profiler：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;gperftools/heap-profiler.h&gt;</span></span><br><span class=\"hljs-built_in\">HeapProfilerStart</span>(<span class=\"hljs-string\">&quot;heap_profile&quot;</span>);<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>分析：</p>\n<ul>\n<li>查看生成的 <code>heap_profile</code> 文件，定位内存泄漏、内存过度分配等问题。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-Leak-Detector（内存泄漏检测）\"><a href=\"#4-Leak-Detector（内存泄漏检测）\" class=\"headerlink\" title=\"4. Leak Detector（内存泄漏检测）\"></a>4. Leak Detector（内存泄漏检测）</h3><ul>\n<li><p>自动检测：当启用 <code>tcmalloc</code> 时，<code>gperftools</code> 自动跟踪内存分配，报告泄漏。</p>\n</li>\n<li><p>例子：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">export</span> HEAPPROFILE=heap_profile<br>./your_program<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5-常用命令总结\"><a href=\"#5-常用命令总结\" class=\"headerlink\" title=\"5. 常用命令总结\"></a>5. 常用命令总结</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 第一个是用源码编译的，第二个是用apt下载的</span><br>pprof --<span class=\"hljs-built_in\">help</span><br>google-pprof --<span class=\"hljs-built_in\">help</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>Options</strong></th>\n<th><strong>功能 (NAME)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>--cum</code></td>\n<td>按累计数据排序</td>\n</tr>\n<tr>\n<td><code>--base=&lt;base&gt;</code></td>\n<td>在显示前从配置文件中减去 <code>&lt;base&gt;</code></td>\n</tr>\n<tr>\n<td><strong>Reporting Granularity</strong></td>\n<td><strong>报告粒度</strong></td>\n</tr>\n<tr>\n<td><code>--addresses</code></td>\n<td>按地址级别报告</td>\n</tr>\n<tr>\n<td><code>--lines</code></td>\n<td>按源代码行级别报告</td>\n</tr>\n<tr>\n<td><code>--functions</code></td>\n<td>按函数级别报告（默认）</td>\n</tr>\n<tr>\n<td><code>--files</code></td>\n<td>按源代码文件级别报告</td>\n</tr>\n<tr>\n<td><strong>Output Type</strong></td>\n<td><strong>输出类型</strong></td>\n</tr>\n<tr>\n<td><code>--text</code></td>\n<td>生成文本报告（默认）</td>\n</tr>\n<tr>\n<td><code>--gv</code></td>\n<td>生成 Postscript 并显示</td>\n</tr>\n<tr>\n<td><code>--list=&lt;regexp&gt;</code></td>\n<td>生成匹配常规表达式的源代码列表</td>\n</tr>\n<tr>\n<td><code>--disasm=&lt;regexp&gt;</code></td>\n<td>生成匹配常规表达式的指令反汇编代码</td>\n</tr>\n<tr>\n<td><code>--dot</code></td>\n<td>生成 DOT 格式的文件并输出到标准输出</td>\n</tr>\n<tr>\n<td><code>--ps</code></td>\n<td>生成 Postscript 格式文件输出到标准输出</td>\n</tr>\n<tr>\n<td><code>--pdf</code></td>\n<td>生成 PDF 格式文件输出到标准输出</td>\n</tr>\n<tr>\n<td><code>--gif</code></td>\n<td>生成 GIF 格式文件输出到标准输出</td>\n</tr>\n<tr>\n<td><strong>Heap-Profile Options</strong></td>\n<td><strong>堆分析选项</strong></td>\n</tr>\n<tr>\n<td><code>--inuse_space</code></td>\n<td>显示当前使用的内存（以MB为单位，默认）</td>\n</tr>\n<tr>\n<td><code>--inuse_objects</code></td>\n<td>显示当前使用的对象数量</td>\n</tr>\n<tr>\n<td><code>--alloc_space</code></td>\n<td>显示已分配的内存（以MB为单位）</td>\n</tr>\n<tr>\n<td><code>--alloc_objects</code></td>\n<td>显示已分配的对象数量</td>\n</tr>\n<tr>\n<td><code>--show_bytes</code></td>\n<td>显示内存使用量（以字节为单位）</td>\n</tr>\n<tr>\n<td><code>--drop_negative</code></td>\n<td>忽略负值差异</td>\n</tr>\n<tr>\n<td><strong>Call-graph Options</strong></td>\n<td><strong>调用图选项</strong></td>\n</tr>\n<tr>\n<td><code>--nodecount=&lt;n&gt;</code></td>\n<td>显示最多 <code>&lt;n&gt;</code> 个节点（默认80）</td>\n</tr>\n<tr>\n<td><code>--nodefraction=&lt;f&gt;</code></td>\n<td>隐藏占总数小于 <code>&lt;f&gt;</code> 的节点（默认0.005）</td>\n</tr>\n<tr>\n<td><code>--edgefraction=&lt;f&gt;</code></td>\n<td>隐藏占总数小于 <code>&lt;f&gt;</code> 的边（默认0.001）</td>\n</tr>\n<tr>\n<td><code>--focus=&lt;regexp&gt;</code></td>\n<td>只聚焦匹配 <code>&lt;regexp&gt;</code> 的节点</td>\n</tr>\n<tr>\n<td><code>--ignore=&lt;regexp&gt;</code></td>\n<td>忽略匹配 <code>&lt;regexp&gt;</code> 的节点</td>\n</tr>\n<tr>\n<td><code>--scale=&lt;n&gt;</code></td>\n<td>设置 GV 渲染的缩放比例（默认0）</td>\n</tr>\n</tbody></table>\n<h2 id=\"四、工具集成与调优\"><a href=\"#四、工具集成与调优\" class=\"headerlink\" title=\"四、工具集成与调优\"></a>四、工具集成与调优</h2><h3 id=\"集成与调试\"><a href=\"#集成与调试\" class=\"headerlink\" title=\"集成与调试\"></a><strong>集成与调试</strong></h3><ul>\n<li>配合 <strong>perf</strong> 或 <strong>Valgrind</strong> 使用，进行内存、CPU 性能多角度分析。</li>\n<li>与 <strong>gdb</strong> 配合，调试性能问题和内存泄漏。</li>\n</ul>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a><strong>性能优化</strong></h3><ul>\n<li>优化内存使用，减少内存分配开销。</li>\n<li>通过 <code>CPU profiler</code> 定位 CPU 瓶颈函数，优化代码热点。</li>\n<li>使用 <code>Heap Profiler</code> 分析程序内存消耗，减少不必要的内存分配。</li>\n</ul>\n<h2 id=\"五、工作原理与源码分析\"><a href=\"#五、工作原理与源码分析\" class=\"headerlink\" title=\"五、工作原理与源码分析\"></a>五、工作原理与源码分析</h2><h3 id=\"tcmalloc\"><a href=\"#tcmalloc\" class=\"headerlink\" title=\"tcmalloc\"></a>tcmalloc</h3><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>tcmalloc是google开发的一个专门为高并发场景优化的内存分配器，全称为”thread cache malloc”。按照<a href=\"http://goog-perftools.sourceforge.net/doc/tcmalloc.html\">官网</a>的介绍，tcmalloc相比于glibc2.3的malloc(底层实现为ptmalloc2)主要有以下优点：</p>\n<ol>\n<li>快速：一台2.8GHz的P4机器上，执行一次malloc及free大约需要300纳秒;而tcmalloc的版本同样的操作大约只需要50纳秒。</li>\n<li>空间占用小：相比ptmalloc2，tcmalloc对小对象占用空间进行了优化。例如：分配N个8字节对象只需要占用8N<em>1.01字节的空间。即，只需要多使用1%的空间。而ptmalloc2中每个对象都需要使用一个4字节的头信息，最后占用的字节可能达到8N</em>8。</li>\n<li>不容易出现内存暴涨</li>\n</ol>\n<h4 id=\"替换原理\"><a href=\"#替换原理\" class=\"headerlink\" title=\"替换原理\"></a>替换原理</h4><p>glibc中的memory-allocation方法均被为声明为<a href=\"https://en.wikipedia.org/wiki/Weak_symbol\">弱符号</a>，只需要在tcmalloc中将其重新定义即可。 具体的重新定义代码在src&#x2F;libc_override*.h中(不同平台实现不同)，下面是Linux平台下部分memory-allocation函数的重新定义实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span>                  </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tc_new</span>(size);       &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-title\">delete</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span> __THROW            </span>&#123; <span class=\"hljs-built_in\">tc_delete</span>(p);              &#125;<br><span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">new</span>[](<span class=\"hljs-type\">size_t</span> size)                &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tc_newarray</span>(size);  &#125;<br><span class=\"hljs-type\">void</span> <span class=\"hljs-keyword\">operator</span> <span class=\"hljs-keyword\">delete</span>[](<span class=\"hljs-type\">void</span>* p) __THROW          &#123; <span class=\"hljs-built_in\">tc_deletearray</span>(p);         &#125;<br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">malloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> s)</span> __THROW                 </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tc_malloc</span>(s);       &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title\">free</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span> __THROW                    </span>&#123; <span class=\"hljs-built_in\">tc_free</span>(p);                &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">realloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p, <span class=\"hljs-type\">size_t</span> s)</span> __THROW       </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tc_realloc</span>(p, s);   &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">calloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> n, <span class=\"hljs-type\">size_t</span> s)</span> __THROW       </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">tc_calloc</span>(n, s);    &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>  <span class=\"hljs-title\">cfree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* p)</span> __THROW                   </span>&#123; <span class=\"hljs-built_in\">tc_cfree</span>(p);               &#125;<br>&#125;  <span class=\"hljs-comment\">// extern &quot;C&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"整体结构\"><a href=\"#整体结构\" class=\"headerlink\" title=\"整体结构\"></a>整体结构</h4><p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518171450479.png\" alt=\"结构图\"></p>\n<p>上图展示了tcmalloc的整体结构, tcmalloc主要由三个组件组成：ThreadCache、CentralFreeList及PageHeap。 其中：</p>\n<ul>\n<li>ThreadCache: 线程缓存，它是一个TSL(线程本地存储)对象，尺寸小于256K的小内存申请均由ThreadCache进行分配；通过ThreadCache分配过程中不需要任何锁，可以极大的提高分配速度</li>\n<li>PageHeap: 中央堆分配器，被所有线程共享(分配时需要全局锁定)，负责与操作系统的直接交互(申请及释放内存)，并且大尺寸的内存申请直接通过PageHeap进行分配</li>\n<li>CentralFreeList：作为PageHeap与ThreadCache的中间人，负责<ol>\n<li>将PageHeap中的内存切分为小块，在恰当时机分配给ThreadCache。</li>\n<li>获取从ThreadCache中回收的内存并在恰当的时机将部分内存归还给PageHeap</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"核心思想：Segregated-Free-List-离散式空闲列表\"><a href=\"#核心思想：Segregated-Free-List-离散式空闲列表\" class=\"headerlink\" title=\"核心思想：Segregated Free List(离散式空闲列表)\"></a>核心思想：Segregated Free List(离散式空闲列表)</h4><p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518171727566.png\" alt=\"结构图\"></p>\n<h5 id=\"小内存分配：ThreadCache\"><a href=\"#小内存分配：ThreadCache\" class=\"headerlink\" title=\"小内存分配：ThreadCache\"></a>小内存分配：ThreadCache</h5><p>tcmalloc实现中，每个thread独立维护了各自的离散式空闲列表，它的核心结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FreeList</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br> <span class=\"hljs-type\">void</span>*    list_;<br> <span class=\"hljs-type\">uint32_t</span> length_;<br> <span class=\"hljs-type\">uint32_t</span> lowater_;<br> <span class=\"hljs-type\">uint32_t</span> max_length_;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ThreadCache</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>     FreeList      list_[kNumClasses];    <br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">flowchart TD<br>    A[请求分配小内存] --&gt; B[通过 SizeMap 获取 size class 和 object size]<br>    B --&gt; C&#123;ThreadCache 中的 free list 是否为空？&#125;<br>    C -- 是 --&gt; D[从 free list 中取出第一个 object 返回]<br>    C -- 否 --&gt; E[从 CentralFreeList 获取若干 object]<br>    E --&gt; F[取出一个 object 返回，剩下的放入 ThreadCache]<br>    E --&gt; G&#123;CentralFreeList 是否也不够？&#125;<br>    G -- 是 --&gt; H[CentralFreeList 向 PageHeap 申请一串页面（Span）]<br>    H --&gt; I[切割页面为多个 object]<br>    I --&gt; J[将部分 object 转移给 ThreadCache]<br>    J --&gt; F<br>    G -- 否 --&gt; F<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"大内存分配：PageHeap\"><a href=\"#大内存分配：PageHeap\" class=\"headerlink\" title=\"大内存分配：PageHeap\"></a>大内存分配：PageHeap</h5><p>PageHeap的职能之一是向操作系统申请内存，与大多数现代分配器一样，tcmalloc使用基于页的分配方式，即每次至少像系统申请1页空间。tcmalloc中定义的页大小为8K个字节(多数linux系统中一页大小为4K字节，也就是说tcmalloc中的一页对应linux中两页)。 虽然PageHeap是按页申请内存，但是它管理内存的基本单位为Span(跨度)，Span对象代表了表示连续的页面。 如下图所示，分别有a，b，c，d四个Span；a占据了2个页面，b占据了1个页面，c占据了4个页面，d占据了3个页面。</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518172159207.png\" alt=\"结构图\"></p>\n<p>下面是Span的定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Span</span> &#123;<br>  PageID        start;          <span class=\"hljs-comment\">// Span描述的内存的起始地址</span><br>  Length        length;         <span class=\"hljs-comment\">// Span页面数量</span><br>  Span*         next;           <span class=\"hljs-comment\">// Span由双向链表组成，PageHeap和CentralFreeList中都用的到</span><br>  Span*         prev;           <span class=\"hljs-comment\">//</span><br>  <span class=\"hljs-type\">void</span>*         objects;        <span class=\"hljs-comment\">// Span会在CentralFreeList中拆分成由object组成的free list</span><br>  <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>  refcount : <span class=\"hljs-number\">16</span>;  <span class=\"hljs-comment\">// Span的object被引用次数，当refcount=0时，表示此Span没有被使用</span><br>  <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>  sizeclass : <span class=\"hljs-number\">8</span>;  <span class=\"hljs-comment\">// Span属于的size class</span><br>  <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>  location : <span class=\"hljs-number\">2</span>;   <span class=\"hljs-comment\">// Span在的位置IN_USE？normal？returned？</span><br>  <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>  sample : <span class=\"hljs-number\">1</span>;     <span class=\"hljs-comment\">// Sampled object?</span><br>  <span class=\"hljs-comment\">// What freelist the span is on: IN_USE if on none, or normal or returned</span><br>  <span class=\"hljs-keyword\">enum</span> &#123; IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>来看下PageHeap的主要结构及示意图：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">PageMap pagemap_; <span class=\"hljs-comment\">// page id 到 Span的映射</span><br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SpanList</span> &#123;<br>   Span        normal;<br>   Span        returned;<br>&#125;;<br><br>SpanList large_;<br><br>SpanList free_[kMaxPages]; <span class=\"hljs-comment\">// kMaxPages = 128</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250518172237981.png\" alt=\"结构图\"></p>\n<h5 id=\"中间人：CentralFreeList\"><a href=\"#中间人：CentralFreeList\" class=\"headerlink\" title=\"中间人：CentralFreeList\"></a>中间人：CentralFreeList</h5><p>tcmalloc为每个size class设置设置了一个CentralFreeList(中央自由列表)，ThreadCache之间共享这些CentralFreeList</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">static</span> CentralFreeListPadded central_cache_[kNumClasses];<br> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CentralFreeList</span> &#123;<br> <span class=\"hljs-keyword\">private</span>:<br>     SpinLock lock_;<br>     <span class=\"hljs-type\">size_t</span> size_class_;<br>     Span empty_;       <br>     Span nonempty_;<br> &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>作为中间人，CentralFreeList的功能之一就是从PageHeap中取出部分Span并按照预定大小(SizeMap中定义)将其拆分成大小固定的object供ThreadCache共享；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">flowchart TD<br>  A[从 PageHeap 获取 Span] --&gt; B[RegisterSizeClass&lt;br/&gt;设置location和sizeclass]<br>  B --&gt; C[Span 切分为 objects&lt;br/&gt;挂到 Span::objects 链表]<br>  C --&gt; D[挂到 CentralFreeList::nonempty_]<br><br>  E[ThreadCache 请求 object] --&gt; F[从 nonempty_ Span 取 object]<br>  F --&gt; G[refcount += 1]<br><br>  F --&gt;|Span 空| H[从 nonempty_ 移除&lt;br/&gt;挂到 empty_]<br><br>  I[ThreadCache 归还 object] --&gt; J[添加 object 到 Span::objects]<br>  J --&gt; K[refcount -= 1]<br><br>  K --&gt;|refcount == 0| L[&quot;从链表移除&lt;br/&gt;PageHeap::Delete(Span)&quot;]<br>  K --&gt;|Span 在 empty_| M[挂回 nonempty_]<br></code></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">sequenceDiagram<br>  participant CentralFreeList<br>  participant PageHeap<br>  participant Span<br>  participant ThreadCache<br><br>  Note over CentralFreeList: 从 PageHeap 获取 Span<br>  CentralFreeList-&gt;&gt;PageHeap: Request Span<br>  PageHeap--&gt;&gt;CentralFreeList: Return Span<br>  CentralFreeList-&gt;&gt;Span: RegisterSizeClass (location=IN_USE, sizeclass=X)<br>  CentralFreeList-&gt;&gt;Span: Split Span into objects (free list)<br>  CentralFreeList-&gt;&gt;CentralFreeList: Add Span to nonempty_ list<br><br>  Note over ThreadCache: 从 CentralFreeList 分配 object<br>  ThreadCache-&gt;&gt;CentralFreeList: Request object<br>  CentralFreeList-&gt;&gt;Span: Get object from free list<br>  Span-&gt;&gt;Span: refcount++<br><br>  alt No object left in Span<br>    CentralFreeList-&gt;&gt;CentralFreeList: Move Span to empty_ list<br>  end<br><br>  Note over ThreadCache: 归还 object 给 CentralFreeList<br>  ThreadCache-&gt;&gt;CentralFreeList: Return object<br>  CentralFreeList-&gt;&gt;Span: Add object back to free list<br>  Span-&gt;&gt;Span: refcount--<br><br>  alt refcount == 0<br>    CentralFreeList-&gt;&gt;CentralFreeList: Remove Span from list<br>    CentralFreeList-&gt;&gt;PageHeap: Delete(Span)<br>  else Span in empty_<br>    CentralFreeList-&gt;&gt;CentralFreeList: Move Span to nonempty_ list<br>  end<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"cpu-profiler\"><a href=\"#cpu-profiler\" class=\"headerlink\" title=\"cpu profiler\"></a>cpu profiler</h3><h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>这是最初由 Google 开发的 CPU 分析器。使用方法分为三个部分：将库链接到应用程序、运行代码以及分析输出。</p>\n<h4 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">flowchart TD<br>    Start([程序开始运行])<br>    InitProfiler[初始化 Profiler&lt;br&gt;（ProfilerStart）]<br>    SetupSignal[设置定时器&lt;br&gt;定期触发 SIGPROF 信号]<br>    InstallHandler[安装 SIGPROF 的信号处理器&lt;br&gt;（ProfilerSignalHandler）]<br>    Wait[程序继续运行，等待采样时刻]<br>    OnSignal[定时器触发 SIGPROF 信号]<br>    GetPC[信号处理器中获取当前函数调用地址&lt;br&gt;使用 backtrace 等方法]<br>    RecordSample[记录当前调用栈&lt;br&gt;写入 profile 数据结构]<br>    WriteToFile[周期性写入 profile 数据文件]<br>    StopProfiler[ProfilerStop 停止分析，关闭文件]<br>    End([程序结束运行])<br><br>    Start --&gt; InitProfiler --&gt; SetupSignal --&gt; InstallHandler --&gt; Wait<br>    Wait --&gt; OnSignal --&gt; GetPC --&gt; RecordSample --&gt; Wait<br>    RecordSample --&gt; WriteToFile --&gt; Wait<br>    Wait --&gt; StopProfiler --&gt; End<br>  classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"关键源码\"><a href=\"#关键源码\" class=\"headerlink\" title=\"关键源码\"></a>关键源码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 启动 CPU Profiler，采样逻辑主入口</span><br><span class=\"hljs-keyword\">extern</span> “C” <span class=\"hljs-function\">PERFTOOLS_DLL_DECL <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">ProfilerStart</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* fname)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> CpuProfiler::instance_.<span class=\"hljs-built_in\">Start</span>(fname, <span class=\"hljs-literal\">NULL</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">CpuProfiler::Start</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* fname, <span class=\"hljs-type\">const</span> ProfilerOptions* options)</span> </span>&#123;<br>    collector_.<span class=\"hljs-built_in\">Start</span>(fname, collector_options);<br>    <span class=\"hljs-comment\">// Setup handler for SIGPROF interrupts</span><br>    <span class=\"hljs-built_in\">EnableHandler</span>();<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><span class=\"hljs-comment\">// 初始化数据收集需要的数据结构</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">ProfileData::Start</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* fname, <span class=\"hljs-type\">const</span> ProfileData::Options&amp; options)</span> </span>&#123;<br> <br>    <span class=\"hljs-comment\">// Open output file and initialize various data structures</span><br>    <span class=\"hljs-type\">int</span> fd =<span class=\"hljs-built_in\">open</span>(fname, O_CREAT | O_WRONLY | O_TRUNC, <span class=\"hljs-number\">0666</span>);<br>    start_time_ = <span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">NULL</span>);<br>    fname_ = <span class=\"hljs-built_in\">strdup</span>(fname);<br> <br>    <span class=\"hljs-comment\">// Reset counters</span><br>    num_evicted_ = <span class=\"hljs-number\">0</span>;<br>    count_ = <span class=\"hljs-number\">0</span>;<br>    evictions_ = <span class=\"hljs-number\">0</span>;<br>    total_bytes_ = <span class=\"hljs-number\">0</span>;<br> <br>    hash_ = <span class=\"hljs-keyword\">new</span> Bucket[kBuckets];<br>    evict_ = <span class=\"hljs-keyword\">new</span> Slot[kBufferLength];<br>    <span class=\"hljs-built_in\">memset</span>(hash_, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(hash_[<span class=\"hljs-number\">0</span>]) * kBuckets);<br> <br>    <span class=\"hljs-comment\">// Record special entries</span><br>    evict_[num_evicted_++] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// count for header</span><br>    evict_[num_evicted_++] = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// depth for header</span><br>    evict_[num_evicted_++] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Version number</span><br>    <span class=\"hljs-built_in\">CHECK_NE</span>(<span class=\"hljs-number\">0</span>, options.<span class=\"hljs-built_in\">frequency</span>());<br>    <span class=\"hljs-type\">int</span> period =<span class=\"hljs-number\">1000000</span>/ options.<span class=\"hljs-built_in\">frequency</span>();<br>    evict_[num_evicted_++] = period; <span class=\"hljs-comment\">// Period (microseconds)</span><br>    evict_[num_evicted_++] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// Padding</span><br>    out_ = fd;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 把prof_handler这个函数注册到了某个地方</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CpuProfiler::EnableHandler</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    prof_handler_token_ = <span class=\"hljs-built_in\">ProfileHandlerRegisterCallback</span>(prof_handler, <span class=\"hljs-keyword\">this</span>);<br>&#125;<br><span class=\"hljs-function\">ProfileHandlerToken* <span class=\"hljs-title\">ProfileHandlerRegisterCallback</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    ProfileHandlerCallback callback, <span class=\"hljs-type\">void</span>* callback_arg)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> ProfileHandler::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">RegisterCallback</span>(callback, callback_arg);<br>&#125;<br><span class=\"hljs-comment\">// 根据环境变量CPUPROFILE_REALTIME的配置，来决定让SIGPROF还是SIGALRM信号来触发SignalHandler信号处理函数，并根据环境变量CPUPROFILE_FREQUENCY的配置来设置自己的一个频率变量 frequency_</span><br>ProfileHandler::<span class=\"hljs-built_in\">ProfileHandler</span>() &#123;<br> <br>    timer_type_ = (<span class=\"hljs-built_in\">getenv</span>(“CPUPROFILE_REALTIME”) ? ITIMER_REAL : ITIMER_PROF);<br>    signal_number_ = (timer_type_ == ITIMER_PROF ? SIGPROF : SIGALRM);<br> <br>    <span class=\"hljs-comment\">// Get frequency of interrupts (if specified)</span><br>    <span class=\"hljs-type\">char</span> junk;<br>    constchar* fr =<span class=\"hljs-built_in\">getenv</span>(“CPUPROFILE_FREQUENCY”);<br> <br>    <span class=\"hljs-keyword\">if</span> (fr != <span class=\"hljs-literal\">NULL</span> &amp;&amp; (<span class=\"hljs-built_in\">sscanf</span>(fr, <span class=\"hljs-string\">&quot;%u%c&quot;</span>, &amp;frequency_, &amp;junk) == <span class=\"hljs-number\">1</span>) &amp;&amp; (frequency_ &gt; <span class=\"hljs-number\">0</span>)) &#123;<br>        <span class=\"hljs-comment\">// Limit to kMaxFrequency</span><br>        frequency_ = (frequency_ &gt; kMaxFrequency) ? kMaxFrequency : frequency_;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        frequency_ = kDefaultFrequency;<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// Install the signal handler.</span><br>    structsigaction sa;<br>    sa.sa_sigaction = SignalHandler;<br>    sa.sa_flags = SA_RESTART | SA_SIGINFO;<br>    <span class=\"hljs-built_in\">sigemptyset</span>(&amp;sa.sa_mask);<br>    <span class=\"hljs-built_in\">sigaction</span>(signal_number_, &amp;sa, <span class=\"hljs-literal\">NULL</span>);<br>&#125;<br><span class=\"hljs-comment\">// 加入第一个callback的时候调用StartTimer（）函数来启动定时器，然后调用EnableHander函数来开启回调</span><br><span class=\"hljs-function\">ProfileHandlerToken* <span class=\"hljs-title\">ProfileHandler::RegisterCallback</span><span class=\"hljs-params\">(ProfileHandlerCallback callback, <span class=\"hljs-type\">void</span>* callback_arg)</span> </span>&#123;<br> <br>    ProfileHandlerToken* token = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ProfileHandlerToken</span>(callback, callback_arg);<br>    <span class=\"hljs-function\">SpinLockHolder <span class=\"hljs-title\">cl</span><span class=\"hljs-params\">(&amp;control_lock_)</span></span>;<br>    <span class=\"hljs-built_in\">DisableHandler</span>();<br>    &#123;<br>        <span class=\"hljs-function\">SpinLockHolder <span class=\"hljs-title\">sl</span><span class=\"hljs-params\">(&amp;signal_lock_)</span></span>;<br>        callbacks_.<span class=\"hljs-built_in\">push_back</span>(token);<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// Start the timer if timer is shared and this is a first callback.</span><br>    <span class=\"hljs-keyword\">if</span> ((callback_count_ == <span class=\"hljs-number\">0</span>) &amp;&amp; (timer_sharing_ == TIMERS_SHARED)) &#123;<br>        <span class=\"hljs-built_in\">StartTimer</span>();<br>    &#125;<br>    ++callback_count_;<br>    <span class=\"hljs-built_in\">EnableHandler</span>();<br>    <span class=\"hljs-keyword\">return</span> token;<br>&#125;<br><span class=\"hljs-comment\">// </span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ProfileHandler::StartTimer</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">itimerval</span> timer;<br>    timer.it_interval.tv_sec = <span class=\"hljs-number\">0</span>;<br>    timer.it_interval.tv_usec = <span class=\"hljs-number\">1000000</span> / frequency_;<br>    timer.it_value = timer.it_interval;<br>    <span class=\"hljs-built_in\">setitimer</span>(timer_type_, &amp;timer, <span class=\"hljs-number\">0</span>);<br>&#125;<br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ProfileHandler::EnableHandler</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">sigaction</span> sa;<br>    sa.sa_sigaction = SignalHandler;<br>    sa.sa_flags = SA_RESTART | SA_SIGINFO;<br>    <span class=\"hljs-built_in\">sigemptyset</span>(&amp;sa.sa_mask);<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> signal_number = (timer_type_ == ITIMER_PROF ? SIGPROF : SIGALRM);<br>    <span class=\"hljs-built_in\">RAW_CHECK</span>(<span class=\"hljs-built_in\">sigaction</span>(signal_number, &amp;sa, <span class=\"hljs-literal\">NULL</span>) == <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;sigprof (enable)&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"heap-profiler\"><a href=\"#heap-profiler\" class=\"headerlink\" title=\"heap profiler\"></a>heap profiler</h3><h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>Heap Profiling 通常指对应用程序的堆分配进行收集或采样，来向我们报告程序的内存使用情况，以便分析内存占用原因或定位内存泄漏根源。</p>\n<h4 id=\"工作流程-1\"><a href=\"#工作流程-1\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h4><p><strong>Heap Profile 的 stack trace + statistics 数据模型与 CPU Proflie 是一致的</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">flowchart TD<br>    A[&quot;HeapProfilerStart()&quot;] --&gt; B[初始化采样参数与文件输出路径]<br>    B --&gt; C[注册 malloc/free hook]<br>    C --&gt; D[用户程序 malloc]<br>    D --&gt; E&#123;是否触发采样?&#125;:::important<br><br>    E -- 否 --&gt; F[正常 malloc]<br>    E -- 是 --&gt; G[记录采样信息]<br>    <br>    G --&gt; H[获取调用栈 stacktrace]<br>    H --&gt; I[记录 size + stacktrace 到 ProfileTable]<br>    I --&gt; J[继续 malloc 执行]<br>    <br>    J --&gt; K[用户程序运行中多次采样]<br><br>    K --&gt; L[&quot;HeapProfilerDump() 或 Stop()&quot;]<br>    L --&gt; M[导出 .heap 文件]<br>    M --&gt; N[使用 pprof 工具进行分析]<br>classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"关键源码-1\"><a href=\"#关键源码-1\" class=\"headerlink\" title=\"关键源码\"></a>关键源码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 启动入口</span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">HeapProfilerStart</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* prefix)</span> </span>&#123;<br>  (<span class=\"hljs-type\">void</span>)tcmalloc::<span class=\"hljs-built_in\">GetProgramInvocationName</span>();<br>  <span class=\"hljs-function\">SpinLockHolder <span class=\"hljs-title\">l</span><span class=\"hljs-params\">(&amp;heap_lock)</span></span>;<br>  <span class=\"hljs-keyword\">if</span> (is_on) <span class=\"hljs-keyword\">return</span>;<br>  is_on = <span class=\"hljs-literal\">true</span>;<br>  <span class=\"hljs-built_in\">RAW_VLOG</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&quot;Starting tracking the heap&quot;</span>);<br>    <br>  MallocExtension::<span class=\"hljs-built_in\">Initialize</span>();<br>  heap_profiler_memory = LowLevelAlloc::<span class=\"hljs-built_in\">NewArena</span>();<br>  heap_profile = <span class=\"hljs-built_in\">new</span>(<span class=\"hljs-built_in\">ProfilerMalloc</span>(<span class=\"hljs-built_in\">sizeof</span>(HeapProfileTable)))<br>      <span class=\"hljs-built_in\">HeapProfileTable</span>(ProfilerMalloc, ProfilerFree);<br><br>  last_dump_alloc = <span class=\"hljs-number\">0</span>;<br>  last_dump_free = <span class=\"hljs-number\">0</span>;<br>  high_water_mark = <span class=\"hljs-number\">0</span>;<br>  last_dump_time = <span class=\"hljs-number\">0</span>;<br>    <br>  <span class=\"hljs-comment\">// Now set the hooks that capture new/delete and malloc/free.</span><br>  <span class=\"hljs-built_in\">RAW_CHECK</span>(MallocHook::<span class=\"hljs-built_in\">AddNewHook</span>(&amp;NewHook), <span class=\"hljs-string\">&quot;&quot;</span>);<br>  <span class=\"hljs-built_in\">RAW_CHECK</span>(MallocHook::<span class=\"hljs-built_in\">AddDeleteHook</span>(&amp;DeleteHook), <span class=\"hljs-string\">&quot;&quot;</span>);<br>  ……<br>&#125;<br><span class=\"hljs-comment\">// tcmalloc 在 malloc() 和 operator new 中增加了一些采样逻辑，当根据条件触发采样 hook 时，会执行以下函数</span><br><span class=\"hljs-comment\">// Record an allocation in the profile.</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">RecordAlloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* ptr, <span class=\"hljs-type\">size_t</span> bytes, <span class=\"hljs-type\">int</span> skip_count)</span> </span>&#123;<br>  <span class=\"hljs-comment\">// Take the stack trace outside the critical section.</span><br><span class=\"hljs-type\">void</span>* stack[HeapProfileTable::kMaxStackDepth];<br>  <span class=\"hljs-type\">int</span> depth = HeapProfileTable::<span class=\"hljs-built_in\">GetCallerStackTrace</span>(skip_count + <span class=\"hljs-number\">1</span>, stack);<br>  <span class=\"hljs-function\">SpinLockHolder <span class=\"hljs-title\">l</span><span class=\"hljs-params\">(&amp;heap_lock)</span></span>;<br>  <span class=\"hljs-keyword\">if</span> (is_on) &#123;<br>    heap_profile-&gt;<span class=\"hljs-built_in\">RecordAlloc</span>(ptr, bytes, depth, stack);<br>    <span class=\"hljs-built_in\">MaybeDumpProfileLocked</span>();<br>  &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">HeapProfileTable::RecordAlloc</span><span class=\"hljs-params\">(</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* ptr, <span class=\"hljs-type\">size_t</span> bytes, <span class=\"hljs-type\">int</span> stack_depth,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-type\">const</span> call_stack[])</span> </span>&#123;<br>  Bucket* b = <span class=\"hljs-built_in\">GetBucket</span>(stack_depth, call_stack);<br>  b-&gt;allocs++;<br>  b-&gt;alloc_size += bytes;<br>  total_.allocs++;<br>  total_.alloc_size += bytes;<br>  AllocValue v;<br>  v.<span class=\"hljs-built_in\">set_bucket</span>(b);  <span class=\"hljs-comment\">// also did set_live(false); set_ignore(false)</span><br>  v.bytes = bytes;<br>  address_map_-&gt;<span class=\"hljs-built_in\">Insert</span>(ptr, v);<br>&#125;<br><span class=\"hljs-comment\">// 在 free() 或 operator delete 中同样需要增加一些逻辑来记录内存释放情况</span><br><span class=\"hljs-comment\">// Record a deallocation in the profile.</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">RecordFree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* ptr)</span> </span>&#123;<br>  <span class=\"hljs-function\">SpinLockHolder <span class=\"hljs-title\">l</span><span class=\"hljs-params\">(&amp;heap_lock)</span></span>;<br>  <span class=\"hljs-keyword\">if</span> (is_on) &#123;<br>    heap_profile-&gt;<span class=\"hljs-built_in\">RecordFree</span>(ptr);<br>    <span class=\"hljs-built_in\">MaybeDumpProfileLocked</span>();<br>  &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">HeapProfileTable::RecordFree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* ptr)</span> </span>&#123;<br>  AllocValue v;<br>  <span class=\"hljs-keyword\">if</span> (address_map_-&gt;<span class=\"hljs-built_in\">FindAndRemove</span>(ptr, &amp;v)) &#123;<br>    Bucket* b = v.<span class=\"hljs-built_in\">bucket</span>();<br>    b-&gt;frees++;<br>    b-&gt;free_size += v.bytes;<br>    total_.frees++;<br>    total_.free_size += v.bytes;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 调用 GetCallerStackTrace() 获取调用栈。</span><br><span class=\"hljs-keyword\">extern</span> <span class=\"hljs-string\">&quot;C&quot;</span> <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">MallocHook_GetCallerStackTrace</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>** result, <span class=\"hljs-type\">int</span> max_depth,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">                                              <span class=\"hljs-type\">int</span> skip_count)</span> </span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(NO_TCMALLOC_SAMPLES)</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>  <span class=\"hljs-keyword\">if</span> (max_depth &lt; <span class=\"hljs-number\">1</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>  &#125;<br>  <span class=\"hljs-type\">int</span> retval = tcmalloc::<span class=\"hljs-built_in\">GrabBacktrace</span>(result, max_depth, skip_count);<br>  <span class=\"hljs-comment\">// prevent tail-call above</span><br>  *(<span class=\"hljs-type\">void</span>* <span class=\"hljs-keyword\">volatile</span> *)result;<br>  <span class=\"hljs-keyword\">return</span> retval;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br><span class=\"hljs-comment\">// </span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"六、实战案例与分析\"><a href=\"#六、实战案例与分析\" class=\"headerlink\" title=\"六、实战案例与分析\"></a>六、实战案例与分析</h2><h3 id=\"案例-1：使用-tcmalloc-优化内存\"><a href=\"#案例-1：使用-tcmalloc-优化内存\" class=\"headerlink\" title=\"案例 1：使用 tcmalloc 优化内存\"></a><strong>案例 1：使用 tcmalloc 优化内存</strong></h3><ul>\n<li>比较 <code>malloc</code> 和 <code>tcmalloc</code> 在高频次分配下的性能差异。</li>\n<li>分析内存碎片、内存占用的变化。</li>\n</ul>\n<h3 id=\"案例-2：使用-CPU-Profiler-分析热点\"><a href=\"#案例-2：使用-CPU-Profiler-分析热点\" class=\"headerlink\" title=\"案例 2：使用 CPU Profiler 分析热点\"></a><strong>案例 2：使用 CPU Profiler 分析热点</strong></h3><ul>\n<li>编写一个包含复杂运算的程序，用 <code>CPU Profiler</code> 查找 CPU 使用的瓶颈函数。</li>\n<li>使用火焰图进行可视化分析，优化计算热点。</li>\n</ul>\n<h3 id=\"案例-3：内存泄漏定位与修复\"><a href=\"#案例-3：内存泄漏定位与修复\" class=\"headerlink\" title=\"案例 3：内存泄漏定位与修复\"></a><strong>案例 3：内存泄漏定位与修复</strong></h3><ul>\n<li>故意写一个内存泄漏示例，使用 <code>Heap Profiler</code> 进行检测，定位泄漏源并修复。</li>\n</ul>\n<h2 id=\"七、常见问题与坑\"><a href=\"#七、常见问题与坑\" class=\"headerlink\" title=\"七、常见问题与坑\"></a>七、常见问题与坑</h2><ul>\n<li><strong>性能开销</strong>：启用 <code>gperftools</code> 后会带来一定的性能开销，尤其是在高负载时。要注意选择合适的 profiling 级别。</li>\n<li><strong>与其他库的兼容性</strong>：某些情况下，<code>tcmalloc</code> 与第三方库的内存分配可能会发生冲突，需要根据具体情况选择关闭。</li>\n<li><strong>内存泄漏的误报</strong>：<code>Heap Profiler</code> 有时会报告不准确的内存泄漏，需要结合代码逐步排查。</li>\n</ul>\n<h2 id=\"八、总结与心得\"><a href=\"#八、总结与心得\" class=\"headerlink\" title=\"八、总结与心得\"></a>八、总结与心得</h2><ul>\n<li><strong>优点</strong>：<ul>\n<li>高效的内存管理，适合高性能应用。</li>\n<li>支持详细的性能分析，帮助定位 CPU 和内存瓶颈。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：<ul>\n<li>使用时有性能开销，建议仅在开发和调试阶段启用。</li>\n<li>配置较为复杂，需要一定的学习曲线。</li>\n</ul>\n</li>\n<li><strong>实用性</strong>：<ul>\n<li>在高性能要求的 C++ 项目中使用 <code>gperftools</code>，可以大幅提升内存管理效率和 CPU 性能。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2025-09-17T10:40:27.955Z","updated":"2025-09-17T10:39:16.686Z","comments":1,"layout":"post","photos":[],"_id":"cmfnx0xvw0005bsvp5xsia3z5","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"性能分析工具对比分析（开源 vs 商业）","date":"2025-09-17T12:00:00.000Z","_content":"\n# 性能分析工具对比分析（开源 vs 商业）\n\n## 一、概览\n\n本篇文档总结了常见开源性能分析工具（perf、valgrind、asan、gperftools）与主流闭源商业工具（Intel VTune Profiler、Dynatrace、New Relic）的功能特性、实现方式、适用场景及优劣势，为后续工具选型和实验设计提供依据。\n\n## 二、工具清单\n\n| 类型     | 工具名称              | 简介                               |\n|----------|-----------------------|------------------------------------|\n| 开源     | perf                  | Linux 原生性能采样工具             |\n| 开源     | valgrind              | 二进制插桩分析，擅长内存错误检测   |\n| 开源     | AddressSanitizer (ASan)| 编译期插桩，检测野指针/溢出等问题 |\n| 开源     | gperftools            | Google 开源的采样 profiler 工具    |\n| 商业闭源 | Intel VTune Profiler  | Intel 提供的硬件级性能分析平台     |\n| 商业闭源 | Dynatrace             | 全栈性能监控平台，支持 APM         |\n| 商业闭源 | New Relic             | 云原生监控，强调仪表盘与可观测性   |\n\n## 三、实现原理对比\n\n| 工具       | 实现方式                   | 特点                                       |\n|------------|----------------------------|--------------------------------------------|\n| perf       | 基于内核 `perf_event_open` 系统调用 | 低开销、依赖内核事件与 PMU 支持              |\n| valgrind   | 二进制插桩 + shadow memory | 无需源码，检测细致，开销大                   |\n| ASan       | 编译期插桩 + shadow memory | 精度高，速度快于 valgrind，需源码 & 重编译    |\n| gperftools | 函数 hook + 采样调用栈     | 适合生产环境调优，精度受限于采样频率         |\n| VTune      | 硬件 PMU + 内核采样 + GUI  | 精度高，支持内存、缓存、线程粒度分析         |\n| Dynatrace  | Agent 插桩 + 远程分析平台  | 云监控为主，适合大规模微服务监控             |\n| New Relic  | Agent SDK + Web 仪表盘     | 云原生集成好，聚焦应用层行为、指标、日志等   |\n\n## 四、使用场景对比\n\n| 场景                  | 推荐工具                              | 原因                                 |\n|-----------------------|---------------------------------------|--------------------------------------|\n| 内存泄漏与野指针分析  | valgrind、asan                        | 静态插桩，检测能力强                 |\n| CPU hotspot 分析      | perf、gperftools、VTune              | 支持采样、函数调用统计                |\n| 多线程竞争分析        | Helgrind（valgrind 子工具）、VTune   | 支持数据竞争检测                      |\n| 生产环境开销敏感场景  | gperftools、VTune                    | 低侵入性采样                         |\n| 云平台系统监控        | Dynatrace、New Relic                 | 云原生支持强，可视化强大              |\n| 精细缓存与分支分析    | VTune                                 | 支持 L1/L2 命中率、指令流水线分析等   |\n\n## 五、功能对比汇总表\n\n| 工具       | CPU 采样 | 内存泄漏检测 | 线程竞争 | 云平台支持 | 实时分析 | 插桩方式     | 是否需源码 |\n|------------|-----------|----------------|------------|--------------|------------|--------------|--------------|\n| perf       | ✅         | ❌             | ❌         | ❌           | ✅         | 系统调用采样 | 否           |\n| valgrind   | ❌         | ✅             | ✅         | ❌           | ❌         | 动态插桩     | 否           |\n| asan       | ❌         | ✅             | ❌         | ❌           | ❌         | 编译期插桩   | 是           |\n| gperftools | ✅         | ✅（部分）     | ❌         | ❌           | ✅         | 采样 hook    | 否           |\n| VTune      | ✅         | ✅             | ✅         | 部分         | ✅         | 多方式结合   | 否           |\n| Dynatrace  | ❌         | ❌             | ❌         | ✅           | ✅         | Agent 插桩   | 否           |\n| New Relic  | ❌         | ❌             | ❌         | ✅           | ✅         | Agent 插桩   | 否           |\n\n## 六、优缺点总结\n\n### 开源工具\n\n#### 优点\n\n- 免费开源、易于定制\n- 原理透明，适合研究与教学\n- 局部问题定位能力强\n\n#### 缺点\n- 不适用于大规模系统统一监控\n- 可视化较弱，使用门槛高\n- 多工具组合使用复杂度大\n\n### 商业工具\n\n#### 优点\n\n- 自动化程度高，GUI 友好\n- 可观测性强，适合运维/业务团队\n- 一体化监控链路（APM + 系统 + 网络）\n\n#### 缺点\n- 成本高、闭源不可定制\n- 有些只适合云平台 / 现代架构\n- 核心分析精度或能力受限\n\n## 七、总结与建议\n\n- **开发调优场景**：优先使用 `perf`、`gperftools`、`asan` 等开源工具，深入定位代码瓶颈。\n- **内存问题排查**：推荐使用 `asan` 或 `valgrind`，结合编译期插桩与动态检测。\n- **生产环境监控**：如需云平台可观测性，推荐使用 Dynatrace 或 New Relic。\n- **精细硬件分析**：涉及缓存、线程粒度优化可考虑 Intel VTune。\n\n\n\n","source":"_posts/tools_comparison.md","raw":"---\ntitle: \"性能分析工具对比分析（开源 vs 商业）\"\ndate: 2025-09-17 20:00:00\ntags:\n  - 学习笔记\n  - 算法\ncategories:\n  - 数据结构与算法\n---\n\n# 性能分析工具对比分析（开源 vs 商业）\n\n## 一、概览\n\n本篇文档总结了常见开源性能分析工具（perf、valgrind、asan、gperftools）与主流闭源商业工具（Intel VTune Profiler、Dynatrace、New Relic）的功能特性、实现方式、适用场景及优劣势，为后续工具选型和实验设计提供依据。\n\n## 二、工具清单\n\n| 类型     | 工具名称              | 简介                               |\n|----------|-----------------------|------------------------------------|\n| 开源     | perf                  | Linux 原生性能采样工具             |\n| 开源     | valgrind              | 二进制插桩分析，擅长内存错误检测   |\n| 开源     | AddressSanitizer (ASan)| 编译期插桩，检测野指针/溢出等问题 |\n| 开源     | gperftools            | Google 开源的采样 profiler 工具    |\n| 商业闭源 | Intel VTune Profiler  | Intel 提供的硬件级性能分析平台     |\n| 商业闭源 | Dynatrace             | 全栈性能监控平台，支持 APM         |\n| 商业闭源 | New Relic             | 云原生监控，强调仪表盘与可观测性   |\n\n## 三、实现原理对比\n\n| 工具       | 实现方式                   | 特点                                       |\n|------------|----------------------------|--------------------------------------------|\n| perf       | 基于内核 `perf_event_open` 系统调用 | 低开销、依赖内核事件与 PMU 支持              |\n| valgrind   | 二进制插桩 + shadow memory | 无需源码，检测细致，开销大                   |\n| ASan       | 编译期插桩 + shadow memory | 精度高，速度快于 valgrind，需源码 & 重编译    |\n| gperftools | 函数 hook + 采样调用栈     | 适合生产环境调优，精度受限于采样频率         |\n| VTune      | 硬件 PMU + 内核采样 + GUI  | 精度高，支持内存、缓存、线程粒度分析         |\n| Dynatrace  | Agent 插桩 + 远程分析平台  | 云监控为主，适合大规模微服务监控             |\n| New Relic  | Agent SDK + Web 仪表盘     | 云原生集成好，聚焦应用层行为、指标、日志等   |\n\n## 四、使用场景对比\n\n| 场景                  | 推荐工具                              | 原因                                 |\n|-----------------------|---------------------------------------|--------------------------------------|\n| 内存泄漏与野指针分析  | valgrind、asan                        | 静态插桩，检测能力强                 |\n| CPU hotspot 分析      | perf、gperftools、VTune              | 支持采样、函数调用统计                |\n| 多线程竞争分析        | Helgrind（valgrind 子工具）、VTune   | 支持数据竞争检测                      |\n| 生产环境开销敏感场景  | gperftools、VTune                    | 低侵入性采样                         |\n| 云平台系统监控        | Dynatrace、New Relic                 | 云原生支持强，可视化强大              |\n| 精细缓存与分支分析    | VTune                                 | 支持 L1/L2 命中率、指令流水线分析等   |\n\n## 五、功能对比汇总表\n\n| 工具       | CPU 采样 | 内存泄漏检测 | 线程竞争 | 云平台支持 | 实时分析 | 插桩方式     | 是否需源码 |\n|------------|-----------|----------------|------------|--------------|------------|--------------|--------------|\n| perf       | ✅         | ❌             | ❌         | ❌           | ✅         | 系统调用采样 | 否           |\n| valgrind   | ❌         | ✅             | ✅         | ❌           | ❌         | 动态插桩     | 否           |\n| asan       | ❌         | ✅             | ❌         | ❌           | ❌         | 编译期插桩   | 是           |\n| gperftools | ✅         | ✅（部分）     | ❌         | ❌           | ✅         | 采样 hook    | 否           |\n| VTune      | ✅         | ✅             | ✅         | 部分         | ✅         | 多方式结合   | 否           |\n| Dynatrace  | ❌         | ❌             | ❌         | ✅           | ✅         | Agent 插桩   | 否           |\n| New Relic  | ❌         | ❌             | ❌         | ✅           | ✅         | Agent 插桩   | 否           |\n\n## 六、优缺点总结\n\n### 开源工具\n\n#### 优点\n\n- 免费开源、易于定制\n- 原理透明，适合研究与教学\n- 局部问题定位能力强\n\n#### 缺点\n- 不适用于大规模系统统一监控\n- 可视化较弱，使用门槛高\n- 多工具组合使用复杂度大\n\n### 商业工具\n\n#### 优点\n\n- 自动化程度高，GUI 友好\n- 可观测性强，适合运维/业务团队\n- 一体化监控链路（APM + 系统 + 网络）\n\n#### 缺点\n- 成本高、闭源不可定制\n- 有些只适合云平台 / 现代架构\n- 核心分析精度或能力受限\n\n## 七、总结与建议\n\n- **开发调优场景**：优先使用 `perf`、`gperftools`、`asan` 等开源工具，深入定位代码瓶颈。\n- **内存问题排查**：推荐使用 `asan` 或 `valgrind`，结合编译期插桩与动态检测。\n- **生产环境监控**：如需云平台可观测性，推荐使用 Dynatrace 或 New Relic。\n- **精细硬件分析**：涉及缓存、线程粒度优化可考虑 Intel VTune。\n\n\n\n","slug":"tools_comparison","published":1,"updated":"2025-09-17T11:45:27.980Z","comments":1,"layout":"post","photos":[],"_id":"cmfnx0xvx0006bsvp2xhi9upm","content":"<h1 id=\"性能分析工具对比分析（开源-vs-商业）\"><a href=\"#性能分析工具对比分析（开源-vs-商业）\" class=\"headerlink\" title=\"性能分析工具对比分析（开源 vs 商业）\"></a>性能分析工具对比分析（开源 vs 商业）</h1><h2 id=\"一、概览\"><a href=\"#一、概览\" class=\"headerlink\" title=\"一、概览\"></a>一、概览</h2><p>本篇文档总结了常见开源性能分析工具（perf、valgrind、asan、gperftools）与主流闭源商业工具（Intel VTune Profiler、Dynatrace、New Relic）的功能特性、实现方式、适用场景及优劣势，为后续工具选型和实验设计提供依据。</p>\n<h2 id=\"二、工具清单\"><a href=\"#二、工具清单\" class=\"headerlink\" title=\"二、工具清单\"></a>二、工具清单</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>工具名称</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>开源</td>\n<td>perf</td>\n<td>Linux 原生性能采样工具</td>\n</tr>\n<tr>\n<td>开源</td>\n<td>valgrind</td>\n<td>二进制插桩分析，擅长内存错误检测</td>\n</tr>\n<tr>\n<td>开源</td>\n<td>AddressSanitizer (ASan)</td>\n<td>编译期插桩，检测野指针&#x2F;溢出等问题</td>\n</tr>\n<tr>\n<td>开源</td>\n<td>gperftools</td>\n<td>Google 开源的采样 profiler 工具</td>\n</tr>\n<tr>\n<td>商业闭源</td>\n<td>Intel VTune Profiler</td>\n<td>Intel 提供的硬件级性能分析平台</td>\n</tr>\n<tr>\n<td>商业闭源</td>\n<td>Dynatrace</td>\n<td>全栈性能监控平台，支持 APM</td>\n</tr>\n<tr>\n<td>商业闭源</td>\n<td>New Relic</td>\n<td>云原生监控，强调仪表盘与可观测性</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、实现原理对比\"><a href=\"#三、实现原理对比\" class=\"headerlink\" title=\"三、实现原理对比\"></a>三、实现原理对比</h2><table>\n<thead>\n<tr>\n<th>工具</th>\n<th>实现方式</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>perf</td>\n<td>基于内核 <code>perf_event_open</code> 系统调用</td>\n<td>低开销、依赖内核事件与 PMU 支持</td>\n</tr>\n<tr>\n<td>valgrind</td>\n<td>二进制插桩 + shadow memory</td>\n<td>无需源码，检测细致，开销大</td>\n</tr>\n<tr>\n<td>ASan</td>\n<td>编译期插桩 + shadow memory</td>\n<td>精度高，速度快于 valgrind，需源码 &amp; 重编译</td>\n</tr>\n<tr>\n<td>gperftools</td>\n<td>函数 hook + 采样调用栈</td>\n<td>适合生产环境调优，精度受限于采样频率</td>\n</tr>\n<tr>\n<td>VTune</td>\n<td>硬件 PMU + 内核采样 + GUI</td>\n<td>精度高，支持内存、缓存、线程粒度分析</td>\n</tr>\n<tr>\n<td>Dynatrace</td>\n<td>Agent 插桩 + 远程分析平台</td>\n<td>云监控为主，适合大规模微服务监控</td>\n</tr>\n<tr>\n<td>New Relic</td>\n<td>Agent SDK + Web 仪表盘</td>\n<td>云原生集成好，聚焦应用层行为、指标、日志等</td>\n</tr>\n</tbody></table>\n<h2 id=\"四、使用场景对比\"><a href=\"#四、使用场景对比\" class=\"headerlink\" title=\"四、使用场景对比\"></a>四、使用场景对比</h2><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐工具</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内存泄漏与野指针分析</td>\n<td>valgrind、asan</td>\n<td>静态插桩，检测能力强</td>\n</tr>\n<tr>\n<td>CPU hotspot 分析</td>\n<td>perf、gperftools、VTune</td>\n<td>支持采样、函数调用统计</td>\n</tr>\n<tr>\n<td>多线程竞争分析</td>\n<td>Helgrind（valgrind 子工具）、VTune</td>\n<td>支持数据竞争检测</td>\n</tr>\n<tr>\n<td>生产环境开销敏感场景</td>\n<td>gperftools、VTune</td>\n<td>低侵入性采样</td>\n</tr>\n<tr>\n<td>云平台系统监控</td>\n<td>Dynatrace、New Relic</td>\n<td>云原生支持强，可视化强大</td>\n</tr>\n<tr>\n<td>精细缓存与分支分析</td>\n<td>VTune</td>\n<td>支持 L1&#x2F;L2 命中率、指令流水线分析等</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、功能对比汇总表\"><a href=\"#五、功能对比汇总表\" class=\"headerlink\" title=\"五、功能对比汇总表\"></a>五、功能对比汇总表</h2><table>\n<thead>\n<tr>\n<th>工具</th>\n<th>CPU 采样</th>\n<th>内存泄漏检测</th>\n<th>线程竞争</th>\n<th>云平台支持</th>\n<th>实时分析</th>\n<th>插桩方式</th>\n<th>是否需源码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>perf</td>\n<td>✅</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>系统调用采样</td>\n<td>否</td>\n</tr>\n<tr>\n<td>valgrind</td>\n<td>❌</td>\n<td>✅</td>\n<td>✅</td>\n<td>❌</td>\n<td>❌</td>\n<td>动态插桩</td>\n<td>否</td>\n</tr>\n<tr>\n<td>asan</td>\n<td>❌</td>\n<td>✅</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>编译期插桩</td>\n<td>是</td>\n</tr>\n<tr>\n<td>gperftools</td>\n<td>✅</td>\n<td>✅（部分）</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>采样 hook</td>\n<td>否</td>\n</tr>\n<tr>\n<td>VTune</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n<td>部分</td>\n<td>✅</td>\n<td>多方式结合</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Dynatrace</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>✅</td>\n<td>Agent 插桩</td>\n<td>否</td>\n</tr>\n<tr>\n<td>New Relic</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>✅</td>\n<td>Agent 插桩</td>\n<td>否</td>\n</tr>\n</tbody></table>\n<h2 id=\"六、优缺点总结\"><a href=\"#六、优缺点总结\" class=\"headerlink\" title=\"六、优缺点总结\"></a>六、优缺点总结</h2><h3 id=\"开源工具\"><a href=\"#开源工具\" class=\"headerlink\" title=\"开源工具\"></a>开源工具</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>免费开源、易于定制</li>\n<li>原理透明，适合研究与教学</li>\n<li>局部问题定位能力强</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>不适用于大规模系统统一监控</li>\n<li>可视化较弱，使用门槛高</li>\n<li>多工具组合使用复杂度大</li>\n</ul>\n<h3 id=\"商业工具\"><a href=\"#商业工具\" class=\"headerlink\" title=\"商业工具\"></a>商业工具</h3><h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>自动化程度高，GUI 友好</li>\n<li>可观测性强，适合运维&#x2F;业务团队</li>\n<li>一体化监控链路（APM + 系统 + 网络）</li>\n</ul>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>成本高、闭源不可定制</li>\n<li>有些只适合云平台 &#x2F; 现代架构</li>\n<li>核心分析精度或能力受限</li>\n</ul>\n<h2 id=\"七、总结与建议\"><a href=\"#七、总结与建议\" class=\"headerlink\" title=\"七、总结与建议\"></a>七、总结与建议</h2><ul>\n<li><strong>开发调优场景</strong>：优先使用 <code>perf</code>、<code>gperftools</code>、<code>asan</code> 等开源工具，深入定位代码瓶颈。</li>\n<li><strong>内存问题排查</strong>：推荐使用 <code>asan</code> 或 <code>valgrind</code>，结合编译期插桩与动态检测。</li>\n<li><strong>生产环境监控</strong>：如需云平台可观测性，推荐使用 Dynatrace 或 New Relic。</li>\n<li><strong>精细硬件分析</strong>：涉及缓存、线程粒度优化可考虑 Intel VTune。</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"性能分析工具对比分析（开源-vs-商业）\"><a href=\"#性能分析工具对比分析（开源-vs-商业）\" class=\"headerlink\" title=\"性能分析工具对比分析（开源 vs 商业）\"></a>性能分析工具对比分析（开源 vs 商业）</h1><h2 id=\"一、概览\"><a href=\"#一、概览\" class=\"headerlink\" title=\"一、概览\"></a>一、概览</h2><p>本篇文档总结了常见开源性能分析工具（perf、valgrind、asan、gperftools）与主流闭源商业工具（Intel VTune Profiler、Dynatrace、New Relic）的功能特性、实现方式、适用场景及优劣势，为后续工具选型和实验设计提供依据。</p>\n<h2 id=\"二、工具清单\"><a href=\"#二、工具清单\" class=\"headerlink\" title=\"二、工具清单\"></a>二、工具清单</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>工具名称</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>开源</td>\n<td>perf</td>\n<td>Linux 原生性能采样工具</td>\n</tr>\n<tr>\n<td>开源</td>\n<td>valgrind</td>\n<td>二进制插桩分析，擅长内存错误检测</td>\n</tr>\n<tr>\n<td>开源</td>\n<td>AddressSanitizer (ASan)</td>\n<td>编译期插桩，检测野指针&#x2F;溢出等问题</td>\n</tr>\n<tr>\n<td>开源</td>\n<td>gperftools</td>\n<td>Google 开源的采样 profiler 工具</td>\n</tr>\n<tr>\n<td>商业闭源</td>\n<td>Intel VTune Profiler</td>\n<td>Intel 提供的硬件级性能分析平台</td>\n</tr>\n<tr>\n<td>商业闭源</td>\n<td>Dynatrace</td>\n<td>全栈性能监控平台，支持 APM</td>\n</tr>\n<tr>\n<td>商业闭源</td>\n<td>New Relic</td>\n<td>云原生监控，强调仪表盘与可观测性</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、实现原理对比\"><a href=\"#三、实现原理对比\" class=\"headerlink\" title=\"三、实现原理对比\"></a>三、实现原理对比</h2><table>\n<thead>\n<tr>\n<th>工具</th>\n<th>实现方式</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>perf</td>\n<td>基于内核 <code>perf_event_open</code> 系统调用</td>\n<td>低开销、依赖内核事件与 PMU 支持</td>\n</tr>\n<tr>\n<td>valgrind</td>\n<td>二进制插桩 + shadow memory</td>\n<td>无需源码，检测细致，开销大</td>\n</tr>\n<tr>\n<td>ASan</td>\n<td>编译期插桩 + shadow memory</td>\n<td>精度高，速度快于 valgrind，需源码 &amp; 重编译</td>\n</tr>\n<tr>\n<td>gperftools</td>\n<td>函数 hook + 采样调用栈</td>\n<td>适合生产环境调优，精度受限于采样频率</td>\n</tr>\n<tr>\n<td>VTune</td>\n<td>硬件 PMU + 内核采样 + GUI</td>\n<td>精度高，支持内存、缓存、线程粒度分析</td>\n</tr>\n<tr>\n<td>Dynatrace</td>\n<td>Agent 插桩 + 远程分析平台</td>\n<td>云监控为主，适合大规模微服务监控</td>\n</tr>\n<tr>\n<td>New Relic</td>\n<td>Agent SDK + Web 仪表盘</td>\n<td>云原生集成好，聚焦应用层行为、指标、日志等</td>\n</tr>\n</tbody></table>\n<h2 id=\"四、使用场景对比\"><a href=\"#四、使用场景对比\" class=\"headerlink\" title=\"四、使用场景对比\"></a>四、使用场景对比</h2><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐工具</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>内存泄漏与野指针分析</td>\n<td>valgrind、asan</td>\n<td>静态插桩，检测能力强</td>\n</tr>\n<tr>\n<td>CPU hotspot 分析</td>\n<td>perf、gperftools、VTune</td>\n<td>支持采样、函数调用统计</td>\n</tr>\n<tr>\n<td>多线程竞争分析</td>\n<td>Helgrind（valgrind 子工具）、VTune</td>\n<td>支持数据竞争检测</td>\n</tr>\n<tr>\n<td>生产环境开销敏感场景</td>\n<td>gperftools、VTune</td>\n<td>低侵入性采样</td>\n</tr>\n<tr>\n<td>云平台系统监控</td>\n<td>Dynatrace、New Relic</td>\n<td>云原生支持强，可视化强大</td>\n</tr>\n<tr>\n<td>精细缓存与分支分析</td>\n<td>VTune</td>\n<td>支持 L1&#x2F;L2 命中率、指令流水线分析等</td>\n</tr>\n</tbody></table>\n<h2 id=\"五、功能对比汇总表\"><a href=\"#五、功能对比汇总表\" class=\"headerlink\" title=\"五、功能对比汇总表\"></a>五、功能对比汇总表</h2><table>\n<thead>\n<tr>\n<th>工具</th>\n<th>CPU 采样</th>\n<th>内存泄漏检测</th>\n<th>线程竞争</th>\n<th>云平台支持</th>\n<th>实时分析</th>\n<th>插桩方式</th>\n<th>是否需源码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>perf</td>\n<td>✅</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>系统调用采样</td>\n<td>否</td>\n</tr>\n<tr>\n<td>valgrind</td>\n<td>❌</td>\n<td>✅</td>\n<td>✅</td>\n<td>❌</td>\n<td>❌</td>\n<td>动态插桩</td>\n<td>否</td>\n</tr>\n<tr>\n<td>asan</td>\n<td>❌</td>\n<td>✅</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>编译期插桩</td>\n<td>是</td>\n</tr>\n<tr>\n<td>gperftools</td>\n<td>✅</td>\n<td>✅（部分）</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>采样 hook</td>\n<td>否</td>\n</tr>\n<tr>\n<td>VTune</td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n<td>部分</td>\n<td>✅</td>\n<td>多方式结合</td>\n<td>否</td>\n</tr>\n<tr>\n<td>Dynatrace</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>✅</td>\n<td>Agent 插桩</td>\n<td>否</td>\n</tr>\n<tr>\n<td>New Relic</td>\n<td>❌</td>\n<td>❌</td>\n<td>❌</td>\n<td>✅</td>\n<td>✅</td>\n<td>Agent 插桩</td>\n<td>否</td>\n</tr>\n</tbody></table>\n<h2 id=\"六、优缺点总结\"><a href=\"#六、优缺点总结\" class=\"headerlink\" title=\"六、优缺点总结\"></a>六、优缺点总结</h2><h3 id=\"开源工具\"><a href=\"#开源工具\" class=\"headerlink\" title=\"开源工具\"></a>开源工具</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>免费开源、易于定制</li>\n<li>原理透明，适合研究与教学</li>\n<li>局部问题定位能力强</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>不适用于大规模系统统一监控</li>\n<li>可视化较弱，使用门槛高</li>\n<li>多工具组合使用复杂度大</li>\n</ul>\n<h3 id=\"商业工具\"><a href=\"#商业工具\" class=\"headerlink\" title=\"商业工具\"></a>商业工具</h3><h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>自动化程度高，GUI 友好</li>\n<li>可观测性强，适合运维&#x2F;业务团队</li>\n<li>一体化监控链路（APM + 系统 + 网络）</li>\n</ul>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>成本高、闭源不可定制</li>\n<li>有些只适合云平台 &#x2F; 现代架构</li>\n<li>核心分析精度或能力受限</li>\n</ul>\n<h2 id=\"七、总结与建议\"><a href=\"#七、总结与建议\" class=\"headerlink\" title=\"七、总结与建议\"></a>七、总结与建议</h2><ul>\n<li><strong>开发调优场景</strong>：优先使用 <code>perf</code>、<code>gperftools</code>、<code>asan</code> 等开源工具，深入定位代码瓶颈。</li>\n<li><strong>内存问题排查</strong>：推荐使用 <code>asan</code> 或 <code>valgrind</code>，结合编译期插桩与动态检测。</li>\n<li><strong>生产环境监控</strong>：如需云平台可观测性，推荐使用 Dynatrace 或 New Relic。</li>\n<li><strong>精细硬件分析</strong>：涉及缓存、线程粒度优化可考虑 Intel VTune。</li>\n</ul>\n"},{"title":"perf学习笔记","date":"2025-09-17T02:00:00.000Z","_content":"# perf学习笔记\n\n## 1. 工具概览\n\n### 1.1 perf是什么？\n\nperf：使用性能计数器进行 Linux 分析（Tracing Frameworks），perf也称为perf_events，perf 功能强大：它可以检测 CPU 性能计数器、跟踪点、kprobe 和 uprobe（动态跟踪）。它还能够进行轻量级性能分析，它包含在 Linux 内核的 tools/perf 下。\n\n- 性能计数器是 CPU 硬件寄存器，用于计数硬件事件，例如执行的指令、遭受的缓存未命中或错误预测的分支。\n- 跟踪点是放置在代码中逻辑位置的检测点，例如系统调用、TCP/IP 事件、文件系统操作等。（Event Sources静态探针）\n- perf 还可以使用 kprobes 和 uprobes 框架动态创建跟踪点（类似于内核驱动，可以热插拔），用于内核和用户空间的动态跟踪。（Event Sources动态探针）\n\n### 1.2 perf 解决什么问题？\n\n- 可消费事件源：tracepoints，kprobes，uprobes，硬件计数器\n- 比ftrace更安全\n- 不能做函数遍历\n\n### 1.3 使用场景举例\n\n用来调试程序和相关信息，具体场景如下：\n\n1. 寻找热点函数，定位性能瓶颈（通过采样）\n2. 用来分析CPU cache、CPU迁移、分支预测、指令周期等各种硬件事件\n3. 对感兴趣的事件进行动态追踪\n\n学习材料：\n\n- Brendan Gregg 的文章（经典入门）：Linux perf Examples\n- 中文推荐：阮一峰《Linux perf 工具入门教程》\n\n## 2. 安装与环境配置\n\n### 2.1 安装方法（apt/yum/brew等）\n\n```sh\n#  相关库\napt install linux-tools-common\napt-get install linux-toools-5.4.0-107-generic\n```\n\n### 2.2 编译配置参数\n\n### 2.3 常见问题及解决\n\n## 3. 基本用法\n\n### 3.1 常用命令汇总\n\n| 命令        | 含义                                                         | 备注                                                         |\n| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| man perf    | 使用说明                                                     |                                                              |\n| perf -h     | help                                                         |                                                              |\n| perf list   | 列出所有能够触发perf采样点的事件列出所有能够触发perf采样点的事件，类似/sys/kernel/debug/tracing/available_events的输出<br/>实测发现，perf 支持的事件要比ftrace多一 倍左右。 | eg：$ perf list \\| grep receive*skb net:netif*receive*skb* *[Tracepoint event] net:netif*receive*skb*entry [Tracepoint event] |\n| perf probe  | 定义新的动态tracepoint                                       | --add：添加一个probe event<br/>例如：perf probe --add do_sys_open<br/>--del：删除probe event<br/>例如：perf probe --del probe:do_sys_open<br/>perf record -e probe:do_sys_open -aR sleep 10 |\n| perf trace  | 类似strace，不过性能更佳                                     | 例如：perf trace ls                                          |\n| perf stat   | 运行命令并收集性能统计信息                                   | 查看在cpu0上的上下文切换次数：<br/>perf stat -e cs -C 0<br/>备注：-e表示事件，可通过perf list查看 |\n| perf top    | 可以实时查看当前系统进程函数占用率情况                       |                                                              |\n| perf record | 运行命令并保存profile到perf.data                             | -p {pid} 记录进程的events<br/>-a：从所有cpu上进行采集<br/>-e {event}：指定PMU（处理器监控单元） event ，默认是cycles:ppp（CPU周期数）<br/>-g：启用调用图(堆栈链/回溯)记录<br/>-F {freq}：采样频率<br/>例如：<br/>perf record -p 12069 -a -g -F 99 -- sleep 10<br/>perf record -p 12069 -a -g -F 999 -- sleep 10<br/>perf record -g -e cpu-clock ./perftest |\n| perf report | 从perf.data读取并显示profile，--no-children：不统计Children开销 | Self：Self 记录的是最后一列的符号（可以理解为函数）本身的采样数占总采样数的百分比；目的：找到最底层的热点函数<br/>Children：记录的是这个符号调用的其他符号（理解为子函数，包括直接调用和间接调用）的采样数**之和**占总采样数的百分比；目的：找到较高层的热点函数 |\n| perf script | 从perf.data读取并显示详细的采样数据                          |                                                              |\n| perf kmem   | 跟踪/测量内核内存属性                                        | record：记录kmem events（--slab：记录slab申请器的events，--page：记录page 申请器的events）<br/>stat：报告内核内存统计信息（--slab：统计slab申请器的events，--page：统计page 申请器的events） |\n| perf mem    | 分析内存访问                                                 |                                                              |\n| perf lock   | 分析锁性能                                                   |                                                              |\n| perf kvm    | 针对kvm虚拟化分析                                            |                                                              |\n| perf sched  | 分析内核调度器性能                                           | record：采集和记录scheduling events<br/>例如（全局）：perf sched record -- sleep 10<br/>例如（进程）：perf sched record -p 752 -- sleep 10<br/>script：报告采集到的事件<br/>latency：报告每个任务的调度延迟和进程的其他调度属性<br/>timehist：提供调度事件的分析报告 |\n\n### 3.2 示例项目中的实际使用步骤\n\n#### pref stat\n\n```sh\n# task-clock:用于执行程序的cpu时间；\n# context-switches：程序在运行过程中经历的上下文切换次数；\n# page-faults：进程运行过程中产生的缺页次数；\n# cpu-migrations：程序在运行过程中发生的CPU迁移次数，即被调度器从一个CPU转移到另外一个CPU上运行；\n# instructions：该进程在这段时间内完成的CPU指令数；\n\n# 开放非root的用户的perf权限\nsudo sh -c \"echo 1 > /proc/sys/kernel/perf_event_paranoid\"\n# 运行perf stat\nperf stat ./DG_server -k 1 -p 8001\n```\n\n![img](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426211523409.png)\n\n#### perf kmem record/stat\n\n```sh\n# 运行内核命令检测\nsudo perf kmem record\n159 out of order events recorded.\n[ perf record: Captured and wrote 504.678 MB perf.data (4969962 samples) ]\n# 查看结果\nsudo perf kmem stat\n```\n\n![image-20250426211759655](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426211759690.png)\n\n#### perf sched \n\n```sh\n# 运行内核调度检测\nsudo perf sched record -- sleep 10\n# 报告采集到的事件\nsudo perf sched script\n# 报告每个任务的调度延迟和进程的其他调度属性\nsudo perf sched latency\n# 提供调度事件的分析报告\nsudo perf sched timehist\n```\n\n![image-20250426215414588](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215414635.png)\n\n![image-20250426215441138](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215441190.png)\n\n![image-20250426215526565](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215526604.png)\n\n#### 结果解读说明\n\n## 4. 实战案例\n\n- 使用工具发现并优化性能问题\n- 结合截图或命令行结果分析问题原因\n- 修改优化建议 + 效果对比\n\n## 5. 原理分析（进阶）\n\n### 工具内部工作机制简析\n\n#### perf的整体架构\n\n![图片](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171450437.jpeg)\n\nLinux Perf 共由两部分组成：\n\n- Perf Tools：用户态的 Perf Tools 为用户提供了一系列丰富的工具集用于收集、分析性能数据。\n- Perf Event Subsystem：Perf Event 子系统是内核众多子系统中的一员，其主要功能是和 Perf Tool 共同完成数据采集的工作。另外，Linux Hard Lockup Detector 也是通过 Perf Event 子系统来实现的\n\n#### perf 工作模式\n\n1. Couting Mode\n   - Counting Mode 将会精确统计一段时间内 CPU 相关硬件计数器数值的变化。为了统计用户感兴趣的事件，Perf Tool 将设置性能控制相关的寄存器。这些寄存器的值将在监控周期结束后被读出。典型工具：Perf Stat。\n2. Sampling Mode\n   - Sampling Mode 将以定期采样方式获取性能数据。PMU 计数器将为某些特定事件配置溢出周期。当计数器溢出时，相关数据，如 IP、通用寄存器、EFLAG 将会被捕捉到。典型工具：Perf Record。\n\n#### 调用关系\n\n以perf record为例：\n\n```mermaid\ngraph TD\n  A[用户空间程序] --> B[perf record 工具]\n  B --> C[syscall: perf_event_open]\n  C --> D[内核：sys_perf_event_open]\n  D --> E[perf_install_in_context]\n  E --> F[perf_event_alloc]:::important\n  F --> G[初始化 perf_event 结构体]\n  G --> H[attach 到任务 / CPU 上]\n  H --> I[注册 PMU driver]:::important\n  I --> J[启动事件采样/计数]\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n#### 采样\n\n为了减小对程序性能的影响，perf 并不会在每个函数加入统计代码，取而代之的统计方式是：采样。\n\n采样的原理是：设置一个定时器，当定时器触发时，查看当前进程正在执行的函数，然后记录下来。如下图所示：\n\n![图片](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171857688.jpeg)\n\n如上图所示，每个 `cpu-clock` 是一个定时器的触发点。在 6 次定时器触发点中，函数 `func1` 被命中了 3 次，函数 `func2` 被命中了 1 次，函数 `func3` 被命中了 2 次。所以，我们可以推测出，函数 func1 的 CPU 使用率最高。\n\n采样的步骤如下：\n\n- 通过设置一个定时器，定时器的触发时间可以由用户设定。\n- 定时器被触发后，将会调用采集函数收集当前运行环境的数据（如当前正在执行的进程和函数等）。\n- 将采集到的数据写入到一个环形缓冲区（ring buffer）中。\n- 应用层可以通过内存映射来读取环形缓冲区中的采样数据。\n\n![图片](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171943596.png)\n\n采样过程的流程图：\n\n```mermaid\ngraph TD\n  A[perf_event 结构体] --> B[perf_event_context 结构体]\n  A --> C[pmu 结构体]\n  B --> D[连接所有属于当前上下文的事件]\n  C --> E[perf_ops_cpu_clock]\n  E --> F[cpu_clock_perf_event_enable 启用事件]\n  E --> G[cpu_clock_perf_event_disable 禁用事件]\n  E --> H[cpu_clock_perf_event_read 事件被触发时的回调]\n  F --> I[perf_swevent_start_hrtimer 初始化]\n  I --> J[perf_swevent_hrtimer 初始化定时器的回调函数]\n  J --> K[perf_event_overflow 对数据进行采样与收集]:::important\n  K --> L[__perf_event_overflow]\n  L --> M[perf_event_output 数据采样]\n  M --> N[perf_prepare_sample 采样数据保存到data中]:::important\n  M --> O[perf_output_sample 采样数据保存到环形缓冲区中]\n  O --> P[perf_output_put 采样数据保存到环形缓冲区中]:::important\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n\n```\n\n\n\n#### 排序\n\n如果程序有成千上万的函数，那么采样出来的数据可能非常多，这个时候就需要对采样的数据进行排序。\n\n为了对采样数据进行排序，perf 使用[红黑树](https://zhida.zhihu.com/search?content_id=215607053&content_type=Article&match_order=1&q=红黑树&zhida_source=entity)这种数据结构，如下图所示：\n\n![图片](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171928923.jpeg)\n\n如上图所示，在 perf 采样的数据中，有 7 个函数被统计了命中次数，perf 使用采样到的数据构建一棵红黑树。\n\n根据红黑树的特性，最右边的节点就是被命中最多的函数，这样就能把程序中 CPU 使用率最高的函数找出来。\n\n- 对程序性能的影响与副作用\n- 与其他工具的异同对比\n\n## 6. 小结与心得\n\n- 学到了什么？\n- 在实习中可以用在哪些场景？","source":"_posts/perf（Linux 下的性能分析器）.md","raw":"---\ntitle: \"perf学习笔记\"\ndate: 2025-09-17 10:00:00\ntags:\n  - 学习笔记\n  - 算法\ncategories:\n  - 数据结构与算法\n---\n# perf学习笔记\n\n## 1. 工具概览\n\n### 1.1 perf是什么？\n\nperf：使用性能计数器进行 Linux 分析（Tracing Frameworks），perf也称为perf_events，perf 功能强大：它可以检测 CPU 性能计数器、跟踪点、kprobe 和 uprobe（动态跟踪）。它还能够进行轻量级性能分析，它包含在 Linux 内核的 tools/perf 下。\n\n- 性能计数器是 CPU 硬件寄存器，用于计数硬件事件，例如执行的指令、遭受的缓存未命中或错误预测的分支。\n- 跟踪点是放置在代码中逻辑位置的检测点，例如系统调用、TCP/IP 事件、文件系统操作等。（Event Sources静态探针）\n- perf 还可以使用 kprobes 和 uprobes 框架动态创建跟踪点（类似于内核驱动，可以热插拔），用于内核和用户空间的动态跟踪。（Event Sources动态探针）\n\n### 1.2 perf 解决什么问题？\n\n- 可消费事件源：tracepoints，kprobes，uprobes，硬件计数器\n- 比ftrace更安全\n- 不能做函数遍历\n\n### 1.3 使用场景举例\n\n用来调试程序和相关信息，具体场景如下：\n\n1. 寻找热点函数，定位性能瓶颈（通过采样）\n2. 用来分析CPU cache、CPU迁移、分支预测、指令周期等各种硬件事件\n3. 对感兴趣的事件进行动态追踪\n\n学习材料：\n\n- Brendan Gregg 的文章（经典入门）：Linux perf Examples\n- 中文推荐：阮一峰《Linux perf 工具入门教程》\n\n## 2. 安装与环境配置\n\n### 2.1 安装方法（apt/yum/brew等）\n\n```sh\n#  相关库\napt install linux-tools-common\napt-get install linux-toools-5.4.0-107-generic\n```\n\n### 2.2 编译配置参数\n\n### 2.3 常见问题及解决\n\n## 3. 基本用法\n\n### 3.1 常用命令汇总\n\n| 命令        | 含义                                                         | 备注                                                         |\n| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| man perf    | 使用说明                                                     |                                                              |\n| perf -h     | help                                                         |                                                              |\n| perf list   | 列出所有能够触发perf采样点的事件列出所有能够触发perf采样点的事件，类似/sys/kernel/debug/tracing/available_events的输出<br/>实测发现，perf 支持的事件要比ftrace多一 倍左右。 | eg：$ perf list \\| grep receive*skb net:netif*receive*skb* *[Tracepoint event] net:netif*receive*skb*entry [Tracepoint event] |\n| perf probe  | 定义新的动态tracepoint                                       | --add：添加一个probe event<br/>例如：perf probe --add do_sys_open<br/>--del：删除probe event<br/>例如：perf probe --del probe:do_sys_open<br/>perf record -e probe:do_sys_open -aR sleep 10 |\n| perf trace  | 类似strace，不过性能更佳                                     | 例如：perf trace ls                                          |\n| perf stat   | 运行命令并收集性能统计信息                                   | 查看在cpu0上的上下文切换次数：<br/>perf stat -e cs -C 0<br/>备注：-e表示事件，可通过perf list查看 |\n| perf top    | 可以实时查看当前系统进程函数占用率情况                       |                                                              |\n| perf record | 运行命令并保存profile到perf.data                             | -p {pid} 记录进程的events<br/>-a：从所有cpu上进行采集<br/>-e {event}：指定PMU（处理器监控单元） event ，默认是cycles:ppp（CPU周期数）<br/>-g：启用调用图(堆栈链/回溯)记录<br/>-F {freq}：采样频率<br/>例如：<br/>perf record -p 12069 -a -g -F 99 -- sleep 10<br/>perf record -p 12069 -a -g -F 999 -- sleep 10<br/>perf record -g -e cpu-clock ./perftest |\n| perf report | 从perf.data读取并显示profile，--no-children：不统计Children开销 | Self：Self 记录的是最后一列的符号（可以理解为函数）本身的采样数占总采样数的百分比；目的：找到最底层的热点函数<br/>Children：记录的是这个符号调用的其他符号（理解为子函数，包括直接调用和间接调用）的采样数**之和**占总采样数的百分比；目的：找到较高层的热点函数 |\n| perf script | 从perf.data读取并显示详细的采样数据                          |                                                              |\n| perf kmem   | 跟踪/测量内核内存属性                                        | record：记录kmem events（--slab：记录slab申请器的events，--page：记录page 申请器的events）<br/>stat：报告内核内存统计信息（--slab：统计slab申请器的events，--page：统计page 申请器的events） |\n| perf mem    | 分析内存访问                                                 |                                                              |\n| perf lock   | 分析锁性能                                                   |                                                              |\n| perf kvm    | 针对kvm虚拟化分析                                            |                                                              |\n| perf sched  | 分析内核调度器性能                                           | record：采集和记录scheduling events<br/>例如（全局）：perf sched record -- sleep 10<br/>例如（进程）：perf sched record -p 752 -- sleep 10<br/>script：报告采集到的事件<br/>latency：报告每个任务的调度延迟和进程的其他调度属性<br/>timehist：提供调度事件的分析报告 |\n\n### 3.2 示例项目中的实际使用步骤\n\n#### pref stat\n\n```sh\n# task-clock:用于执行程序的cpu时间；\n# context-switches：程序在运行过程中经历的上下文切换次数；\n# page-faults：进程运行过程中产生的缺页次数；\n# cpu-migrations：程序在运行过程中发生的CPU迁移次数，即被调度器从一个CPU转移到另外一个CPU上运行；\n# instructions：该进程在这段时间内完成的CPU指令数；\n\n# 开放非root的用户的perf权限\nsudo sh -c \"echo 1 > /proc/sys/kernel/perf_event_paranoid\"\n# 运行perf stat\nperf stat ./DG_server -k 1 -p 8001\n```\n\n![img](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426211523409.png)\n\n#### perf kmem record/stat\n\n```sh\n# 运行内核命令检测\nsudo perf kmem record\n159 out of order events recorded.\n[ perf record: Captured and wrote 504.678 MB perf.data (4969962 samples) ]\n# 查看结果\nsudo perf kmem stat\n```\n\n![image-20250426211759655](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426211759690.png)\n\n#### perf sched \n\n```sh\n# 运行内核调度检测\nsudo perf sched record -- sleep 10\n# 报告采集到的事件\nsudo perf sched script\n# 报告每个任务的调度延迟和进程的其他调度属性\nsudo perf sched latency\n# 提供调度事件的分析报告\nsudo perf sched timehist\n```\n\n![image-20250426215414588](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215414635.png)\n\n![image-20250426215441138](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215441190.png)\n\n![image-20250426215526565](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215526604.png)\n\n#### 结果解读说明\n\n## 4. 实战案例\n\n- 使用工具发现并优化性能问题\n- 结合截图或命令行结果分析问题原因\n- 修改优化建议 + 效果对比\n\n## 5. 原理分析（进阶）\n\n### 工具内部工作机制简析\n\n#### perf的整体架构\n\n![图片](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171450437.jpeg)\n\nLinux Perf 共由两部分组成：\n\n- Perf Tools：用户态的 Perf Tools 为用户提供了一系列丰富的工具集用于收集、分析性能数据。\n- Perf Event Subsystem：Perf Event 子系统是内核众多子系统中的一员，其主要功能是和 Perf Tool 共同完成数据采集的工作。另外，Linux Hard Lockup Detector 也是通过 Perf Event 子系统来实现的\n\n#### perf 工作模式\n\n1. Couting Mode\n   - Counting Mode 将会精确统计一段时间内 CPU 相关硬件计数器数值的变化。为了统计用户感兴趣的事件，Perf Tool 将设置性能控制相关的寄存器。这些寄存器的值将在监控周期结束后被读出。典型工具：Perf Stat。\n2. Sampling Mode\n   - Sampling Mode 将以定期采样方式获取性能数据。PMU 计数器将为某些特定事件配置溢出周期。当计数器溢出时，相关数据，如 IP、通用寄存器、EFLAG 将会被捕捉到。典型工具：Perf Record。\n\n#### 调用关系\n\n以perf record为例：\n\n```mermaid\ngraph TD\n  A[用户空间程序] --> B[perf record 工具]\n  B --> C[syscall: perf_event_open]\n  C --> D[内核：sys_perf_event_open]\n  D --> E[perf_install_in_context]\n  E --> F[perf_event_alloc]:::important\n  F --> G[初始化 perf_event 结构体]\n  G --> H[attach 到任务 / CPU 上]\n  H --> I[注册 PMU driver]:::important\n  I --> J[启动事件采样/计数]\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n```\n\n#### 采样\n\n为了减小对程序性能的影响，perf 并不会在每个函数加入统计代码，取而代之的统计方式是：采样。\n\n采样的原理是：设置一个定时器，当定时器触发时，查看当前进程正在执行的函数，然后记录下来。如下图所示：\n\n![图片](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171857688.jpeg)\n\n如上图所示，每个 `cpu-clock` 是一个定时器的触发点。在 6 次定时器触发点中，函数 `func1` 被命中了 3 次，函数 `func2` 被命中了 1 次，函数 `func3` 被命中了 2 次。所以，我们可以推测出，函数 func1 的 CPU 使用率最高。\n\n采样的步骤如下：\n\n- 通过设置一个定时器，定时器的触发时间可以由用户设定。\n- 定时器被触发后，将会调用采集函数收集当前运行环境的数据（如当前正在执行的进程和函数等）。\n- 将采集到的数据写入到一个环形缓冲区（ring buffer）中。\n- 应用层可以通过内存映射来读取环形缓冲区中的采样数据。\n\n![图片](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171943596.png)\n\n采样过程的流程图：\n\n```mermaid\ngraph TD\n  A[perf_event 结构体] --> B[perf_event_context 结构体]\n  A --> C[pmu 结构体]\n  B --> D[连接所有属于当前上下文的事件]\n  C --> E[perf_ops_cpu_clock]\n  E --> F[cpu_clock_perf_event_enable 启用事件]\n  E --> G[cpu_clock_perf_event_disable 禁用事件]\n  E --> H[cpu_clock_perf_event_read 事件被触发时的回调]\n  F --> I[perf_swevent_start_hrtimer 初始化]\n  I --> J[perf_swevent_hrtimer 初始化定时器的回调函数]\n  J --> K[perf_event_overflow 对数据进行采样与收集]:::important\n  K --> L[__perf_event_overflow]\n  L --> M[perf_event_output 数据采样]\n  M --> N[perf_prepare_sample 采样数据保存到data中]:::important\n  M --> O[perf_output_sample 采样数据保存到环形缓冲区中]\n  O --> P[perf_output_put 采样数据保存到环形缓冲区中]:::important\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n\n```\n\n\n\n#### 排序\n\n如果程序有成千上万的函数，那么采样出来的数据可能非常多，这个时候就需要对采样的数据进行排序。\n\n为了对采样数据进行排序，perf 使用[红黑树](https://zhida.zhihu.com/search?content_id=215607053&content_type=Article&match_order=1&q=红黑树&zhida_source=entity)这种数据结构，如下图所示：\n\n![图片](https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171928923.jpeg)\n\n如上图所示，在 perf 采样的数据中，有 7 个函数被统计了命中次数，perf 使用采样到的数据构建一棵红黑树。\n\n根据红黑树的特性，最右边的节点就是被命中最多的函数，这样就能把程序中 CPU 使用率最高的函数找出来。\n\n- 对程序性能的影响与副作用\n- 与其他工具的异同对比\n\n## 6. 小结与心得\n\n- 学到了什么？\n- 在实习中可以用在哪些场景？","slug":"perf（Linux 下的性能分析器）","published":1,"updated":"2025-09-17T11:45:00.533Z","comments":1,"layout":"post","photos":[],"_id":"cmfnx0xvy0007bsvp9vy1d7gf","content":"<h1 id=\"perf学习笔记\"><a href=\"#perf学习笔记\" class=\"headerlink\" title=\"perf学习笔记\"></a>perf学习笔记</h1><h2 id=\"1-工具概览\"><a href=\"#1-工具概览\" class=\"headerlink\" title=\"1. 工具概览\"></a>1. 工具概览</h2><h3 id=\"1-1-perf是什么？\"><a href=\"#1-1-perf是什么？\" class=\"headerlink\" title=\"1.1 perf是什么？\"></a>1.1 perf是什么？</h3><p>perf：使用性能计数器进行 Linux 分析（Tracing Frameworks），perf也称为perf_events，perf 功能强大：它可以检测 CPU 性能计数器、跟踪点、kprobe 和 uprobe（动态跟踪）。它还能够进行轻量级性能分析，它包含在 Linux 内核的 tools&#x2F;perf 下。</p>\n<ul>\n<li>性能计数器是 CPU 硬件寄存器，用于计数硬件事件，例如执行的指令、遭受的缓存未命中或错误预测的分支。</li>\n<li>跟踪点是放置在代码中逻辑位置的检测点，例如系统调用、TCP&#x2F;IP 事件、文件系统操作等。（Event Sources静态探针）</li>\n<li>perf 还可以使用 kprobes 和 uprobes 框架动态创建跟踪点（类似于内核驱动，可以热插拔），用于内核和用户空间的动态跟踪。（Event Sources动态探针）</li>\n</ul>\n<h3 id=\"1-2-perf-解决什么问题？\"><a href=\"#1-2-perf-解决什么问题？\" class=\"headerlink\" title=\"1.2 perf 解决什么问题？\"></a>1.2 perf 解决什么问题？</h3><ul>\n<li>可消费事件源：tracepoints，kprobes，uprobes，硬件计数器</li>\n<li>比ftrace更安全</li>\n<li>不能做函数遍历</li>\n</ul>\n<h3 id=\"1-3-使用场景举例\"><a href=\"#1-3-使用场景举例\" class=\"headerlink\" title=\"1.3 使用场景举例\"></a>1.3 使用场景举例</h3><p>用来调试程序和相关信息，具体场景如下：</p>\n<ol>\n<li>寻找热点函数，定位性能瓶颈（通过采样）</li>\n<li>用来分析CPU cache、CPU迁移、分支预测、指令周期等各种硬件事件</li>\n<li>对感兴趣的事件进行动态追踪</li>\n</ol>\n<p>学习材料：</p>\n<ul>\n<li>Brendan Gregg 的文章（经典入门）：Linux perf Examples</li>\n<li>中文推荐：阮一峰《Linux perf 工具入门教程》</li>\n</ul>\n<h2 id=\"2-安装与环境配置\"><a href=\"#2-安装与环境配置\" class=\"headerlink\" title=\"2. 安装与环境配置\"></a>2. 安装与环境配置</h2><h3 id=\"2-1-安装方法（apt-yum-brew等）\"><a href=\"#2-1-安装方法（apt-yum-brew等）\" class=\"headerlink\" title=\"2.1 安装方法（apt&#x2F;yum&#x2F;brew等）\"></a>2.1 安装方法（apt&#x2F;yum&#x2F;brew等）</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\">#  相关库</span><br>apt install linux-tools-common<br>apt-get install linux-toools-5.4.0-107-generic<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-编译配置参数\"><a href=\"#2-2-编译配置参数\" class=\"headerlink\" title=\"2.2 编译配置参数\"></a>2.2 编译配置参数</h3><h3 id=\"2-3-常见问题及解决\"><a href=\"#2-3-常见问题及解决\" class=\"headerlink\" title=\"2.3 常见问题及解决\"></a>2.3 常见问题及解决</h3><h2 id=\"3-基本用法\"><a href=\"#3-基本用法\" class=\"headerlink\" title=\"3. 基本用法\"></a>3. 基本用法</h2><h3 id=\"3-1-常用命令汇总\"><a href=\"#3-1-常用命令汇总\" class=\"headerlink\" title=\"3.1 常用命令汇总\"></a>3.1 常用命令汇总</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>man perf</td>\n<td>使用说明</td>\n<td></td>\n</tr>\n<tr>\n<td>perf -h</td>\n<td>help</td>\n<td></td>\n</tr>\n<tr>\n<td>perf list</td>\n<td>列出所有能够触发perf采样点的事件列出所有能够触发perf采样点的事件，类似&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;available_events的输出<br/>实测发现，perf 支持的事件要比ftrace多一 倍左右。</td>\n<td>eg：$ perf list | grep receive<em>skb net:netif</em>receive<em>skb</em> <em>[Tracepoint event] net:netif</em>receive<em>skb</em>entry [Tracepoint event]</td>\n</tr>\n<tr>\n<td>perf probe</td>\n<td>定义新的动态tracepoint</td>\n<td>–add：添加一个probe event<br/>例如：perf probe –add do_sys_open<br/>–del：删除probe event<br/>例如：perf probe –del probe:do_sys_open<br/>perf record -e probe:do_sys_open -aR sleep 10</td>\n</tr>\n<tr>\n<td>perf trace</td>\n<td>类似strace，不过性能更佳</td>\n<td>例如：perf trace ls</td>\n</tr>\n<tr>\n<td>perf stat</td>\n<td>运行命令并收集性能统计信息</td>\n<td>查看在cpu0上的上下文切换次数：<br/>perf stat -e cs -C 0<br/>备注：-e表示事件，可通过perf list查看</td>\n</tr>\n<tr>\n<td>perf top</td>\n<td>可以实时查看当前系统进程函数占用率情况</td>\n<td></td>\n</tr>\n<tr>\n<td>perf record</td>\n<td>运行命令并保存profile到perf.data</td>\n<td>-p {pid} 记录进程的events<br/>-a：从所有cpu上进行采集<br/>-e {event}：指定PMU（处理器监控单元） event ，默认是cycles:ppp（CPU周期数）<br/>-g：启用调用图(堆栈链&#x2F;回溯)记录<br/>-F {freq}：采样频率<br/>例如：<br/>perf record -p 12069 -a -g -F 99 – sleep 10<br/>perf record -p 12069 -a -g -F 999 – sleep 10<br/>perf record -g -e cpu-clock .&#x2F;perftest</td>\n</tr>\n<tr>\n<td>perf report</td>\n<td>从perf.data读取并显示profile，–no-children：不统计Children开销</td>\n<td>Self：Self 记录的是最后一列的符号（可以理解为函数）本身的采样数占总采样数的百分比；目的：找到最底层的热点函数<br/>Children：记录的是这个符号调用的其他符号（理解为子函数，包括直接调用和间接调用）的采样数<strong>之和</strong>占总采样数的百分比；目的：找到较高层的热点函数</td>\n</tr>\n<tr>\n<td>perf script</td>\n<td>从perf.data读取并显示详细的采样数据</td>\n<td></td>\n</tr>\n<tr>\n<td>perf kmem</td>\n<td>跟踪&#x2F;测量内核内存属性</td>\n<td>record：记录kmem events（–slab：记录slab申请器的events，–page：记录page 申请器的events）<br/>stat：报告内核内存统计信息（–slab：统计slab申请器的events，–page：统计page 申请器的events）</td>\n</tr>\n<tr>\n<td>perf mem</td>\n<td>分析内存访问</td>\n<td></td>\n</tr>\n<tr>\n<td>perf lock</td>\n<td>分析锁性能</td>\n<td></td>\n</tr>\n<tr>\n<td>perf kvm</td>\n<td>针对kvm虚拟化分析</td>\n<td></td>\n</tr>\n<tr>\n<td>perf sched</td>\n<td>分析内核调度器性能</td>\n<td>record：采集和记录scheduling events<br/>例如（全局）：perf sched record – sleep 10<br/>例如（进程）：perf sched record -p 752 – sleep 10<br/>script：报告采集到的事件<br/>latency：报告每个任务的调度延迟和进程的其他调度属性<br/>timehist：提供调度事件的分析报告</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-2-示例项目中的实际使用步骤\"><a href=\"#3-2-示例项目中的实际使用步骤\" class=\"headerlink\" title=\"3.2 示例项目中的实际使用步骤\"></a>3.2 示例项目中的实际使用步骤</h3><h4 id=\"pref-stat\"><a href=\"#pref-stat\" class=\"headerlink\" title=\"pref stat\"></a>pref stat</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># task-clock:用于执行程序的cpu时间；</span><br><span class=\"hljs-comment\"># context-switches：程序在运行过程中经历的上下文切换次数；</span><br><span class=\"hljs-comment\"># page-faults：进程运行过程中产生的缺页次数；</span><br><span class=\"hljs-comment\"># cpu-migrations：程序在运行过程中发生的CPU迁移次数，即被调度器从一个CPU转移到另外一个CPU上运行；</span><br><span class=\"hljs-comment\"># instructions：该进程在这段时间内完成的CPU指令数；</span><br><br><span class=\"hljs-comment\"># 开放非root的用户的perf权限</span><br><span class=\"hljs-built_in\">sudo</span> sh -c <span class=\"hljs-string\">&quot;echo 1 &gt; /proc/sys/kernel/perf_event_paranoid&quot;</span><br><span class=\"hljs-comment\"># 运行perf stat</span><br>perf <span class=\"hljs-built_in\">stat</span> ./DG_server -k 1 -p 8001<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426211523409.png\" alt=\"img\"></p>\n<h4 id=\"perf-kmem-record-stat\"><a href=\"#perf-kmem-record-stat\" class=\"headerlink\" title=\"perf kmem record&#x2F;stat\"></a>perf kmem record&#x2F;stat</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 运行内核命令检测</span><br><span class=\"hljs-built_in\">sudo</span> perf kmem record<br>159 out of order events recorded.<br>[ perf record: Captured and wrote 504.678 MB perf.data (4969962 samples) ]<br><span class=\"hljs-comment\"># 查看结果</span><br><span class=\"hljs-built_in\">sudo</span> perf kmem <span class=\"hljs-built_in\">stat</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426211759690.png\" alt=\"image-20250426211759655\"></p>\n<h4 id=\"perf-sched\"><a href=\"#perf-sched\" class=\"headerlink\" title=\"perf sched\"></a>perf sched</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 运行内核调度检测</span><br><span class=\"hljs-built_in\">sudo</span> perf <span class=\"hljs-built_in\">sched</span> record -- <span class=\"hljs-built_in\">sleep</span> 10<br><span class=\"hljs-comment\"># 报告采集到的事件</span><br><span class=\"hljs-built_in\">sudo</span> perf <span class=\"hljs-built_in\">sched</span> script<br><span class=\"hljs-comment\"># 报告每个任务的调度延迟和进程的其他调度属性</span><br><span class=\"hljs-built_in\">sudo</span> perf <span class=\"hljs-built_in\">sched</span> latency<br><span class=\"hljs-comment\"># 提供调度事件的分析报告</span><br><span class=\"hljs-built_in\">sudo</span> perf <span class=\"hljs-built_in\">sched</span> timehist<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215414635.png\" alt=\"image-20250426215414588\"></p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215441190.png\" alt=\"image-20250426215441138\"></p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215526604.png\" alt=\"image-20250426215526565\"></p>\n<h4 id=\"结果解读说明\"><a href=\"#结果解读说明\" class=\"headerlink\" title=\"结果解读说明\"></a>结果解读说明</h4><h2 id=\"4-实战案例\"><a href=\"#4-实战案例\" class=\"headerlink\" title=\"4. 实战案例\"></a>4. 实战案例</h2><ul>\n<li>使用工具发现并优化性能问题</li>\n<li>结合截图或命令行结果分析问题原因</li>\n<li>修改优化建议 + 效果对比</li>\n</ul>\n<h2 id=\"5-原理分析（进阶）\"><a href=\"#5-原理分析（进阶）\" class=\"headerlink\" title=\"5. 原理分析（进阶）\"></a>5. 原理分析（进阶）</h2><h3 id=\"工具内部工作机制简析\"><a href=\"#工具内部工作机制简析\" class=\"headerlink\" title=\"工具内部工作机制简析\"></a>工具内部工作机制简析</h3><h4 id=\"perf的整体架构\"><a href=\"#perf的整体架构\" class=\"headerlink\" title=\"perf的整体架构\"></a>perf的整体架构</h4><p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171450437.jpeg\" alt=\"图片\"></p>\n<p>Linux Perf 共由两部分组成：</p>\n<ul>\n<li>Perf Tools：用户态的 Perf Tools 为用户提供了一系列丰富的工具集用于收集、分析性能数据。</li>\n<li>Perf Event Subsystem：Perf Event 子系统是内核众多子系统中的一员，其主要功能是和 Perf Tool 共同完成数据采集的工作。另外，Linux Hard Lockup Detector 也是通过 Perf Event 子系统来实现的</li>\n</ul>\n<h4 id=\"perf-工作模式\"><a href=\"#perf-工作模式\" class=\"headerlink\" title=\"perf 工作模式\"></a>perf 工作模式</h4><ol>\n<li>Couting Mode<ul>\n<li>Counting Mode 将会精确统计一段时间内 CPU 相关硬件计数器数值的变化。为了统计用户感兴趣的事件，Perf Tool 将设置性能控制相关的寄存器。这些寄存器的值将在监控周期结束后被读出。典型工具：Perf Stat。</li>\n</ul>\n</li>\n<li>Sampling Mode<ul>\n<li>Sampling Mode 将以定期采样方式获取性能数据。PMU 计数器将为某些特定事件配置溢出周期。当计数器溢出时，相关数据，如 IP、通用寄存器、EFLAG 将会被捕捉到。典型工具：Perf Record。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"调用关系\"><a href=\"#调用关系\" class=\"headerlink\" title=\"调用关系\"></a>调用关系</h4><p>以perf record为例：</p>\n<pre><code class=\" mermaid\">graph TD\n  A[用户空间程序] --&gt; B[perf record 工具]\n  B --&gt; C[syscall: perf_event_open]\n  C --&gt; D[内核：sys_perf_event_open]\n  D --&gt; E[perf_install_in_context]\n  E --&gt; F[perf_event_alloc]:::important\n  F --&gt; G[初始化 perf_event 结构体]\n  G --&gt; H[attach 到任务 / CPU 上]\n  H --&gt; I[注册 PMU driver]:::important\n  I --&gt; J[启动事件采样/计数]\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n</code></pre>\n\n<h4 id=\"采样\"><a href=\"#采样\" class=\"headerlink\" title=\"采样\"></a>采样</h4><p>为了减小对程序性能的影响，perf 并不会在每个函数加入统计代码，取而代之的统计方式是：采样。</p>\n<p>采样的原理是：设置一个定时器，当定时器触发时，查看当前进程正在执行的函数，然后记录下来。如下图所示：</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171857688.jpeg\" alt=\"图片\"></p>\n<p>如上图所示，每个 <code>cpu-clock</code> 是一个定时器的触发点。在 6 次定时器触发点中，函数 <code>func1</code> 被命中了 3 次，函数 <code>func2</code> 被命中了 1 次，函数 <code>func3</code> 被命中了 2 次。所以，我们可以推测出，函数 func1 的 CPU 使用率最高。</p>\n<p>采样的步骤如下：</p>\n<ul>\n<li>通过设置一个定时器，定时器的触发时间可以由用户设定。</li>\n<li>定时器被触发后，将会调用采集函数收集当前运行环境的数据（如当前正在执行的进程和函数等）。</li>\n<li>将采集到的数据写入到一个环形缓冲区（ring buffer）中。</li>\n<li>应用层可以通过内存映射来读取环形缓冲区中的采样数据。</li>\n</ul>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171943596.png\" alt=\"图片\"></p>\n<p>采样过程的流程图：</p>\n<pre><code class=\" mermaid\">graph TD\n  A[perf_event 结构体] --&gt; B[perf_event_context 结构体]\n  A --&gt; C[pmu 结构体]\n  B --&gt; D[连接所有属于当前上下文的事件]\n  C --&gt; E[perf_ops_cpu_clock]\n  E --&gt; F[cpu_clock_perf_event_enable 启用事件]\n  E --&gt; G[cpu_clock_perf_event_disable 禁用事件]\n  E --&gt; H[cpu_clock_perf_event_read 事件被触发时的回调]\n  F --&gt; I[perf_swevent_start_hrtimer 初始化]\n  I --&gt; J[perf_swevent_hrtimer 初始化定时器的回调函数]\n  J --&gt; K[perf_event_overflow 对数据进行采样与收集]:::important\n  K --&gt; L[__perf_event_overflow]\n  L --&gt; M[perf_event_output 数据采样]\n  M --&gt; N[perf_prepare_sample 采样数据保存到data中]:::important\n  M --&gt; O[perf_output_sample 采样数据保存到环形缓冲区中]\n  O --&gt; P[perf_output_put 采样数据保存到环形缓冲区中]:::important\n classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;\n\n</code></pre>\n\n\n\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><p>如果程序有成千上万的函数，那么采样出来的数据可能非常多，这个时候就需要对采样的数据进行排序。</p>\n<p>为了对采样数据进行排序，perf 使用<a href=\"https://zhida.zhihu.com/search?content_id=215607053&content_type=Article&match_order=1&q=%E7%BA%A2%E9%BB%91%E6%A0%91&zhida_source=entity\">红黑树</a>这种数据结构，如下图所示：</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171928923.jpeg\" alt=\"图片\"></p>\n<p>如上图所示，在 perf 采样的数据中，有 7 个函数被统计了命中次数，perf 使用采样到的数据构建一棵红黑树。</p>\n<p>根据红黑树的特性，最右边的节点就是被命中最多的函数，这样就能把程序中 CPU 使用率最高的函数找出来。</p>\n<ul>\n<li>对程序性能的影响与副作用</li>\n<li>与其他工具的异同对比</li>\n</ul>\n<h2 id=\"6-小结与心得\"><a href=\"#6-小结与心得\" class=\"headerlink\" title=\"6. 小结与心得\"></a>6. 小结与心得</h2><ul>\n<li>学到了什么？</li>\n<li>在实习中可以用在哪些场景？</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"perf学习笔记\"><a href=\"#perf学习笔记\" class=\"headerlink\" title=\"perf学习笔记\"></a>perf学习笔记</h1><h2 id=\"1-工具概览\"><a href=\"#1-工具概览\" class=\"headerlink\" title=\"1. 工具概览\"></a>1. 工具概览</h2><h3 id=\"1-1-perf是什么？\"><a href=\"#1-1-perf是什么？\" class=\"headerlink\" title=\"1.1 perf是什么？\"></a>1.1 perf是什么？</h3><p>perf：使用性能计数器进行 Linux 分析（Tracing Frameworks），perf也称为perf_events，perf 功能强大：它可以检测 CPU 性能计数器、跟踪点、kprobe 和 uprobe（动态跟踪）。它还能够进行轻量级性能分析，它包含在 Linux 内核的 tools&#x2F;perf 下。</p>\n<ul>\n<li>性能计数器是 CPU 硬件寄存器，用于计数硬件事件，例如执行的指令、遭受的缓存未命中或错误预测的分支。</li>\n<li>跟踪点是放置在代码中逻辑位置的检测点，例如系统调用、TCP&#x2F;IP 事件、文件系统操作等。（Event Sources静态探针）</li>\n<li>perf 还可以使用 kprobes 和 uprobes 框架动态创建跟踪点（类似于内核驱动，可以热插拔），用于内核和用户空间的动态跟踪。（Event Sources动态探针）</li>\n</ul>\n<h3 id=\"1-2-perf-解决什么问题？\"><a href=\"#1-2-perf-解决什么问题？\" class=\"headerlink\" title=\"1.2 perf 解决什么问题？\"></a>1.2 perf 解决什么问题？</h3><ul>\n<li>可消费事件源：tracepoints，kprobes，uprobes，硬件计数器</li>\n<li>比ftrace更安全</li>\n<li>不能做函数遍历</li>\n</ul>\n<h3 id=\"1-3-使用场景举例\"><a href=\"#1-3-使用场景举例\" class=\"headerlink\" title=\"1.3 使用场景举例\"></a>1.3 使用场景举例</h3><p>用来调试程序和相关信息，具体场景如下：</p>\n<ol>\n<li>寻找热点函数，定位性能瓶颈（通过采样）</li>\n<li>用来分析CPU cache、CPU迁移、分支预测、指令周期等各种硬件事件</li>\n<li>对感兴趣的事件进行动态追踪</li>\n</ol>\n<p>学习材料：</p>\n<ul>\n<li>Brendan Gregg 的文章（经典入门）：Linux perf Examples</li>\n<li>中文推荐：阮一峰《Linux perf 工具入门教程》</li>\n</ul>\n<h2 id=\"2-安装与环境配置\"><a href=\"#2-安装与环境配置\" class=\"headerlink\" title=\"2. 安装与环境配置\"></a>2. 安装与环境配置</h2><h3 id=\"2-1-安装方法（apt-yum-brew等）\"><a href=\"#2-1-安装方法（apt-yum-brew等）\" class=\"headerlink\" title=\"2.1 安装方法（apt&#x2F;yum&#x2F;brew等）\"></a>2.1 安装方法（apt&#x2F;yum&#x2F;brew等）</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\">#  相关库</span><br>apt install linux-tools-common<br>apt-get install linux-toools-5.4.0-107-generic<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-编译配置参数\"><a href=\"#2-2-编译配置参数\" class=\"headerlink\" title=\"2.2 编译配置参数\"></a>2.2 编译配置参数</h3><h3 id=\"2-3-常见问题及解决\"><a href=\"#2-3-常见问题及解决\" class=\"headerlink\" title=\"2.3 常见问题及解决\"></a>2.3 常见问题及解决</h3><h2 id=\"3-基本用法\"><a href=\"#3-基本用法\" class=\"headerlink\" title=\"3. 基本用法\"></a>3. 基本用法</h2><h3 id=\"3-1-常用命令汇总\"><a href=\"#3-1-常用命令汇总\" class=\"headerlink\" title=\"3.1 常用命令汇总\"></a>3.1 常用命令汇总</h3><table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>man perf</td>\n<td>使用说明</td>\n<td></td>\n</tr>\n<tr>\n<td>perf -h</td>\n<td>help</td>\n<td></td>\n</tr>\n<tr>\n<td>perf list</td>\n<td>列出所有能够触发perf采样点的事件列出所有能够触发perf采样点的事件，类似&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;available_events的输出<br/>实测发现，perf 支持的事件要比ftrace多一 倍左右。</td>\n<td>eg：$ perf list | grep receive<em>skb net:netif</em>receive<em>skb</em> <em>[Tracepoint event] net:netif</em>receive<em>skb</em>entry [Tracepoint event]</td>\n</tr>\n<tr>\n<td>perf probe</td>\n<td>定义新的动态tracepoint</td>\n<td>–add：添加一个probe event<br/>例如：perf probe –add do_sys_open<br/>–del：删除probe event<br/>例如：perf probe –del probe:do_sys_open<br/>perf record -e probe:do_sys_open -aR sleep 10</td>\n</tr>\n<tr>\n<td>perf trace</td>\n<td>类似strace，不过性能更佳</td>\n<td>例如：perf trace ls</td>\n</tr>\n<tr>\n<td>perf stat</td>\n<td>运行命令并收集性能统计信息</td>\n<td>查看在cpu0上的上下文切换次数：<br/>perf stat -e cs -C 0<br/>备注：-e表示事件，可通过perf list查看</td>\n</tr>\n<tr>\n<td>perf top</td>\n<td>可以实时查看当前系统进程函数占用率情况</td>\n<td></td>\n</tr>\n<tr>\n<td>perf record</td>\n<td>运行命令并保存profile到perf.data</td>\n<td>-p {pid} 记录进程的events<br/>-a：从所有cpu上进行采集<br/>-e {event}：指定PMU（处理器监控单元） event ，默认是cycles:ppp（CPU周期数）<br/>-g：启用调用图(堆栈链&#x2F;回溯)记录<br/>-F {freq}：采样频率<br/>例如：<br/>perf record -p 12069 -a -g -F 99 – sleep 10<br/>perf record -p 12069 -a -g -F 999 – sleep 10<br/>perf record -g -e cpu-clock .&#x2F;perftest</td>\n</tr>\n<tr>\n<td>perf report</td>\n<td>从perf.data读取并显示profile，–no-children：不统计Children开销</td>\n<td>Self：Self 记录的是最后一列的符号（可以理解为函数）本身的采样数占总采样数的百分比；目的：找到最底层的热点函数<br/>Children：记录的是这个符号调用的其他符号（理解为子函数，包括直接调用和间接调用）的采样数<strong>之和</strong>占总采样数的百分比；目的：找到较高层的热点函数</td>\n</tr>\n<tr>\n<td>perf script</td>\n<td>从perf.data读取并显示详细的采样数据</td>\n<td></td>\n</tr>\n<tr>\n<td>perf kmem</td>\n<td>跟踪&#x2F;测量内核内存属性</td>\n<td>record：记录kmem events（–slab：记录slab申请器的events，–page：记录page 申请器的events）<br/>stat：报告内核内存统计信息（–slab：统计slab申请器的events，–page：统计page 申请器的events）</td>\n</tr>\n<tr>\n<td>perf mem</td>\n<td>分析内存访问</td>\n<td></td>\n</tr>\n<tr>\n<td>perf lock</td>\n<td>分析锁性能</td>\n<td></td>\n</tr>\n<tr>\n<td>perf kvm</td>\n<td>针对kvm虚拟化分析</td>\n<td></td>\n</tr>\n<tr>\n<td>perf sched</td>\n<td>分析内核调度器性能</td>\n<td>record：采集和记录scheduling events<br/>例如（全局）：perf sched record – sleep 10<br/>例如（进程）：perf sched record -p 752 – sleep 10<br/>script：报告采集到的事件<br/>latency：报告每个任务的调度延迟和进程的其他调度属性<br/>timehist：提供调度事件的分析报告</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-2-示例项目中的实际使用步骤\"><a href=\"#3-2-示例项目中的实际使用步骤\" class=\"headerlink\" title=\"3.2 示例项目中的实际使用步骤\"></a>3.2 示例项目中的实际使用步骤</h3><h4 id=\"pref-stat\"><a href=\"#pref-stat\" class=\"headerlink\" title=\"pref stat\"></a>pref stat</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># task-clock:用于执行程序的cpu时间；</span><br><span class=\"hljs-comment\"># context-switches：程序在运行过程中经历的上下文切换次数；</span><br><span class=\"hljs-comment\"># page-faults：进程运行过程中产生的缺页次数；</span><br><span class=\"hljs-comment\"># cpu-migrations：程序在运行过程中发生的CPU迁移次数，即被调度器从一个CPU转移到另外一个CPU上运行；</span><br><span class=\"hljs-comment\"># instructions：该进程在这段时间内完成的CPU指令数；</span><br><br><span class=\"hljs-comment\"># 开放非root的用户的perf权限</span><br><span class=\"hljs-built_in\">sudo</span> sh -c <span class=\"hljs-string\">&quot;echo 1 &gt; /proc/sys/kernel/perf_event_paranoid&quot;</span><br><span class=\"hljs-comment\"># 运行perf stat</span><br>perf <span class=\"hljs-built_in\">stat</span> ./DG_server -k 1 -p 8001<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426211523409.png\" alt=\"img\"></p>\n<h4 id=\"perf-kmem-record-stat\"><a href=\"#perf-kmem-record-stat\" class=\"headerlink\" title=\"perf kmem record&#x2F;stat\"></a>perf kmem record&#x2F;stat</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 运行内核命令检测</span><br><span class=\"hljs-built_in\">sudo</span> perf kmem record<br>159 out of order events recorded.<br>[ perf record: Captured and wrote 504.678 MB perf.data (4969962 samples) ]<br><span class=\"hljs-comment\"># 查看结果</span><br><span class=\"hljs-built_in\">sudo</span> perf kmem <span class=\"hljs-built_in\">stat</span><br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426211759690.png\" alt=\"image-20250426211759655\"></p>\n<h4 id=\"perf-sched\"><a href=\"#perf-sched\" class=\"headerlink\" title=\"perf sched\"></a>perf sched</h4><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># 运行内核调度检测</span><br><span class=\"hljs-built_in\">sudo</span> perf <span class=\"hljs-built_in\">sched</span> record -- <span class=\"hljs-built_in\">sleep</span> 10<br><span class=\"hljs-comment\"># 报告采集到的事件</span><br><span class=\"hljs-built_in\">sudo</span> perf <span class=\"hljs-built_in\">sched</span> script<br><span class=\"hljs-comment\"># 报告每个任务的调度延迟和进程的其他调度属性</span><br><span class=\"hljs-built_in\">sudo</span> perf <span class=\"hljs-built_in\">sched</span> latency<br><span class=\"hljs-comment\"># 提供调度事件的分析报告</span><br><span class=\"hljs-built_in\">sudo</span> perf <span class=\"hljs-built_in\">sched</span> timehist<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215414635.png\" alt=\"image-20250426215414588\"></p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215441190.png\" alt=\"image-20250426215441138\"></p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250426215526604.png\" alt=\"image-20250426215526565\"></p>\n<h4 id=\"结果解读说明\"><a href=\"#结果解读说明\" class=\"headerlink\" title=\"结果解读说明\"></a>结果解读说明</h4><h2 id=\"4-实战案例\"><a href=\"#4-实战案例\" class=\"headerlink\" title=\"4. 实战案例\"></a>4. 实战案例</h2><ul>\n<li>使用工具发现并优化性能问题</li>\n<li>结合截图或命令行结果分析问题原因</li>\n<li>修改优化建议 + 效果对比</li>\n</ul>\n<h2 id=\"5-原理分析（进阶）\"><a href=\"#5-原理分析（进阶）\" class=\"headerlink\" title=\"5. 原理分析（进阶）\"></a>5. 原理分析（进阶）</h2><h3 id=\"工具内部工作机制简析\"><a href=\"#工具内部工作机制简析\" class=\"headerlink\" title=\"工具内部工作机制简析\"></a>工具内部工作机制简析</h3><h4 id=\"perf的整体架构\"><a href=\"#perf的整体架构\" class=\"headerlink\" title=\"perf的整体架构\"></a>perf的整体架构</h4><p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171450437.jpeg\" alt=\"图片\"></p>\n<p>Linux Perf 共由两部分组成：</p>\n<ul>\n<li>Perf Tools：用户态的 Perf Tools 为用户提供了一系列丰富的工具集用于收集、分析性能数据。</li>\n<li>Perf Event Subsystem：Perf Event 子系统是内核众多子系统中的一员，其主要功能是和 Perf Tool 共同完成数据采集的工作。另外，Linux Hard Lockup Detector 也是通过 Perf Event 子系统来实现的</li>\n</ul>\n<h4 id=\"perf-工作模式\"><a href=\"#perf-工作模式\" class=\"headerlink\" title=\"perf 工作模式\"></a>perf 工作模式</h4><ol>\n<li>Couting Mode<ul>\n<li>Counting Mode 将会精确统计一段时间内 CPU 相关硬件计数器数值的变化。为了统计用户感兴趣的事件，Perf Tool 将设置性能控制相关的寄存器。这些寄存器的值将在监控周期结束后被读出。典型工具：Perf Stat。</li>\n</ul>\n</li>\n<li>Sampling Mode<ul>\n<li>Sampling Mode 将以定期采样方式获取性能数据。PMU 计数器将为某些特定事件配置溢出周期。当计数器溢出时，相关数据，如 IP、通用寄存器、EFLAG 将会被捕捉到。典型工具：Perf Record。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"调用关系\"><a href=\"#调用关系\" class=\"headerlink\" title=\"调用关系\"></a>调用关系</h4><p>以perf record为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TD<br>  A[用户空间程序] --&gt; B[perf record 工具]<br>  B --&gt; C[syscall: perf_event_open]<br>  C --&gt; D[内核：sys_perf_event_open]<br>  D --&gt; E[perf_install_in_context]<br>  E --&gt; F[perf_event_alloc]:::important<br>  F --&gt; G[初始化 perf_event 结构体]<br>  G --&gt; H[attach 到任务 / CPU 上]<br>  H --&gt; I[注册 PMU driver]:::important<br>  I --&gt; J[启动事件采样/计数]<br> classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"采样\"><a href=\"#采样\" class=\"headerlink\" title=\"采样\"></a>采样</h4><p>为了减小对程序性能的影响，perf 并不会在每个函数加入统计代码，取而代之的统计方式是：采样。</p>\n<p>采样的原理是：设置一个定时器，当定时器触发时，查看当前进程正在执行的函数，然后记录下来。如下图所示：</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171857688.jpeg\" alt=\"图片\"></p>\n<p>如上图所示，每个 <code>cpu-clock</code> 是一个定时器的触发点。在 6 次定时器触发点中，函数 <code>func1</code> 被命中了 3 次，函数 <code>func2</code> 被命中了 1 次，函数 <code>func3</code> 被命中了 2 次。所以，我们可以推测出，函数 func1 的 CPU 使用率最高。</p>\n<p>采样的步骤如下：</p>\n<ul>\n<li>通过设置一个定时器，定时器的触发时间可以由用户设定。</li>\n<li>定时器被触发后，将会调用采集函数收集当前运行环境的数据（如当前正在执行的进程和函数等）。</li>\n<li>将采集到的数据写入到一个环形缓冲区（ring buffer）中。</li>\n<li>应用层可以通过内存映射来读取环形缓冲区中的采样数据。</li>\n</ul>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171943596.png\" alt=\"图片\"></p>\n<p>采样过程的流程图：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TD<br>  A[perf_event 结构体] --&gt; B[perf_event_context 结构体]<br>  A --&gt; C[pmu 结构体]<br>  B --&gt; D[连接所有属于当前上下文的事件]<br>  C --&gt; E[perf_ops_cpu_clock]<br>  E --&gt; F[cpu_clock_perf_event_enable 启用事件]<br>  E --&gt; G[cpu_clock_perf_event_disable 禁用事件]<br>  E --&gt; H[cpu_clock_perf_event_read 事件被触发时的回调]<br>  F --&gt; I[perf_swevent_start_hrtimer 初始化]<br>  I --&gt; J[perf_swevent_hrtimer 初始化定时器的回调函数]<br>  J --&gt; K[perf_event_overflow 对数据进行采样与收集]:::important<br>  K --&gt; L[__perf_event_overflow]<br>  L --&gt; M[perf_event_output 数据采样]<br>  M --&gt; N[perf_prepare_sample 采样数据保存到data中]:::important<br>  M --&gt; O[perf_output_sample 采样数据保存到环形缓冲区中]<br>  O --&gt; P[perf_output_put 采样数据保存到环形缓冲区中]:::important<br> classDef important fill:#fff3e0,stroke:#ff9800,stroke-width:2px;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><p>如果程序有成千上万的函数，那么采样出来的数据可能非常多，这个时候就需要对采样的数据进行排序。</p>\n<p>为了对采样数据进行排序，perf 使用<a href=\"https://zhida.zhihu.com/search?content_id=215607053&content_type=Article&match_order=1&q=%E7%BA%A2%E9%BB%91%E6%A0%91&zhida_source=entity\">红黑树</a>这种数据结构，如下图所示：</p>\n<p><img src=\"https://qnwang.oss-cn-hangzhou.aliyuncs.com/internship/20250508171928923.jpeg\" alt=\"图片\"></p>\n<p>如上图所示，在 perf 采样的数据中，有 7 个函数被统计了命中次数，perf 使用采样到的数据构建一棵红黑树。</p>\n<p>根据红黑树的特性，最右边的节点就是被命中最多的函数，这样就能把程序中 CPU 使用率最高的函数找出来。</p>\n<ul>\n<li>对程序性能的影响与副作用</li>\n<li>与其他工具的异同对比</li>\n</ul>\n<h2 id=\"6-小结与心得\"><a href=\"#6-小结与心得\" class=\"headerlink\" title=\"6. 小结与心得\"></a>6. 小结与心得</h2><ul>\n<li>学到了什么？</li>\n<li>在实习中可以用在哪些场景？</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmfnx0xvx0006bsvp2xhi9upm","category_id":"cmfnx0xvv0003bsvpas454uou","_id":"cmfnx0xvz000absvpcdkc2hz7"},{"post_id":"cmfnx0xvs0001bsvp8vojdnhu","category_id":"cmfnx0xvv0003bsvpas454uou","_id":"cmfnx0xw0000cbsvpa4x9e4nz"},{"post_id":"cmfnx0xvy0007bsvp9vy1d7gf","category_id":"cmfnx0xvv0003bsvpas454uou","_id":"cmfnx0xw0000ebsvp3i74es9l"},{"post_id":"cmfnx0xvu0002bsvpgn6aehf1","category_id":"cmfnx0xvv0003bsvpas454uou","_id":"cmfnx0xw0000hbsvp1lhp3hwg"}],"PostTag":[{"post_id":"cmfnx0xvs0001bsvp8vojdnhu","tag_id":"cmfnx0xvw0004bsvp7oylh185","_id":"cmfnx0xw0000dbsvpet0oezvf"},{"post_id":"cmfnx0xvs0001bsvp8vojdnhu","tag_id":"cmfnx0xvy0009bsvpcek99tzm","_id":"cmfnx0xw0000fbsvpb9ev0jpl"},{"post_id":"cmfnx0xvu0002bsvpgn6aehf1","tag_id":"cmfnx0xvw0004bsvp7oylh185","_id":"cmfnx0xw0000jbsvp1142caxr"},{"post_id":"cmfnx0xvu0002bsvpgn6aehf1","tag_id":"cmfnx0xvy0009bsvpcek99tzm","_id":"cmfnx0xw0000kbsvp7b8ua67b"},{"post_id":"cmfnx0xvx0006bsvp2xhi9upm","tag_id":"cmfnx0xvw0004bsvp7oylh185","_id":"cmfnx0xw0000mbsvp82wu832b"},{"post_id":"cmfnx0xvx0006bsvp2xhi9upm","tag_id":"cmfnx0xvy0009bsvpcek99tzm","_id":"cmfnx0xw0000nbsvp51fifu67"},{"post_id":"cmfnx0xvy0007bsvp9vy1d7gf","tag_id":"cmfnx0xvw0004bsvp7oylh185","_id":"cmfnx0xw0000obsvpd7k36hx3"},{"post_id":"cmfnx0xvy0007bsvp9vy1d7gf","tag_id":"cmfnx0xvy0009bsvpcek99tzm","_id":"cmfnx0xw0000pbsvp0aa2co35"}],"Tag":[{"name":"学习笔记","_id":"cmfnx0xvw0004bsvp7oylh185"},{"name":"算法","_id":"cmfnx0xvy0009bsvpcek99tzm"}]}}